<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><script>((function() {var callbacks = [],timeLimit = 50,open = false;setInterval(loop, 1);return {addListener: function(fn) {callbacks.push(fn);},cancleListenr: function(fn) {callbacks = callbacks.filter(function(v) {return v !== fn;});}}
function loop() {var startTime = new Date();debugger;if (new Date() - startTime > timeLimit) {if (!open) {callbacks.forEach(function(fn) {fn.call(null);});}open = true;window.stop();alert('你真坏，请关闭控制台！');document.body.innerHTML = "";} else {open = false;}}})()).addListener(function() {window.location.reload();});</script><script>function toDevtools(){
  let num = 0; 
  let devtools = new Date();
  devtools.toString = function() {
    num++;
    if (num > 1) {
        alert('你想干嘛，真坏，请关闭控制台！')
        window.location.href = "about:blank"
        blast();
    }
  }
  console.log('', devtools);
}
toDevtools();</script><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python基础(day66-80) | 嘉明のBlog</title><meta name="author" content="马嘉明"><meta name="copyright" content="马嘉明"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Python基础(day66-80)">
<meta property="og:type" content="article">
<meta property="og:title" content="Python基础(day66-80)">
<meta property="og:url" content="https://jiaming-blog.top/post/4462ea98.html">
<meta property="og:site_name" content="嘉明のBlog">
<meta property="og:description" content="Python基础(day66-80)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picture.jiaming-blog.top/wallpaper/103.webp">
<meta property="article:published_time" content="2024-01-23T03:16:08.000Z">
<meta property="article:modified_time" content="2024-01-23T03:16:08.000Z">
<meta property="article:author" content="马嘉明">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picture.jiaming-blog.top/wallpaper/103.webp"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://jiaming-blog.top/post/4462ea98.html"><link rel="preconnect" href="//cdnjs.cloudflare.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"KG9RT2VP09","apiKey":"1f9919167bb0d75f90709cbf736f09ea","indexName":"Blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdnjs.cloudflare.com/ajax/libs/egjs-infinitegrid/4.11.0/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python基础(day66-80)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-23 11:16:08'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/ethan4116-blog/lib/css/plane_v2.css"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/emoji.css"><script type="text/javascript" src="https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js"></script><span id="fps"></span><link rel="stylesheet" href="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.14/tianli_gpt.css"<div id="myscoll"></div><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/12/22/-1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-home"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-home"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-book"></use></svg><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guidang">                   </use></svg><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-biaoqian">                   </use></svg><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei">                   </use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:randomPost();"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tabzujidianliang">                   </use></svg><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xingquaihao"></use></svg><span> 兴趣</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/interesting/exercise/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-jianshen">                   </use></svg><span> 健身</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/interesting/ride/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zihangchesaiche">                   </use></svg><span> 骑行</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/interesting/photography/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-sheying">                   </use></svg><span> 摄影</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/interesting/journey/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lvhang-">                   </use></svg><span> 旅行</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/interesting/mountaineer/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-climber">                   </use></svg><span> 爬山</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/interesting/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinle">                   </use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/interesting/movie/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-dianying">                   </use></svg><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyanban">                   </use></svg><span> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie">                   </use></svg><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-EC_gerenwengao-gerenjianli"></use></svg><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/talk/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-talk">                   </use></svg><span> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-love-sign">                   </use></svg><span> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-aixin">                   </use></svg><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://picture.jiaming-blog.top/wallpaper/103.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="嘉明のBlog"><span class="site-name">嘉明のBlog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-home"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-home"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-book"></use></svg><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guidang">                   </use></svg><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-biaoqian">                   </use></svg><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei">                   </use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:randomPost();"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tabzujidianliang">                   </use></svg><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xingquaihao"></use></svg><span> 兴趣</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/interesting/exercise/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-jianshen">                   </use></svg><span> 健身</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/interesting/ride/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zihangchesaiche">                   </use></svg><span> 骑行</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/interesting/photography/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-sheying">                   </use></svg><span> 摄影</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/interesting/journey/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lvhang-">                   </use></svg><span> 旅行</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/interesting/mountaineer/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-climber">                   </use></svg><span> 爬山</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/interesting/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinle">                   </use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/interesting/movie/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-dianying">                   </use></svg><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyanban">                   </use></svg><span> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie">                   </use></svg><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-EC_gerenwengao-gerenjianli"></use></svg><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/talk/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-talk">                   </use></svg><span> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-love-sign">                   </use></svg><span> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-aixin">                   </use></svg><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python基础(day66-80)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-23T03:16:08.000Z" title="发表于 2024-01-23 11:16:08">2024-01-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-23T03:16:08.000Z" title="更新于 2024-01-23 11:16:08">2024-01-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python-day100/">Python(day100)</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">50.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>188分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Python基础(day66-80)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs></svg><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="background-image: url('https://picture.jiaming-blog.top/wallpaper/103.webp')"></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="数据分析概述"><a href="#数据分析概述" class="headerlink" title="数据分析概述"></a>数据分析概述</h2><p>当今世界对信息技术的依赖程度在不断加深，每天都会有大量的数据产生，我们经常会感到数据越来越多，但是要从中发现有价值的信息却越来越难。这里所说的信息，可以理解为对数据集处理之后的结果，是从数据集中提炼出的可用于其他场合的结论性的东西，而<strong>从原始数据中抽取出有价值的信息</strong>的这个过程我们就称之为<strong>数据分析</strong>，它是数据科学工作的一部分。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/data_science.png" style="zoom:50%;"></p>
<blockquote>
<p>定义：<strong>数据分析是有针对性的收集、加工、整理数据并采用统计、挖掘等技术对数据进行探索、分析、呈现和解释的科学</strong>。</p>
</blockquote>
<h3 id="数据分析师的职责和技能栈"><a href="#数据分析师的职责和技能栈" class="headerlink" title="数据分析师的职责和技能栈"></a>数据分析师的职责和技能栈</h3><p>HR在发布招聘需求时，通常将数据工程、数据分析、数据挖掘等岗位都统称为数据分析岗位，但是根据工作性质的不同，又可以分为偏工程的<strong>数据治理方向</strong>、偏业务的<strong>数据分析方向</strong>、偏算法的<strong>数据挖掘方向</strong>、偏开发的<strong>数据开发方向</strong>、偏产品的<strong>数据产品经理</strong>。我们通常所说的数据分析师主要是指<strong>业务数据分析师</strong>，很多数据分析师的职业生涯都是从这个岗位开始的，而且这个岗位也是招聘数量最多的岗位。业务数据分析师在公司通常不属于研发部门而属于运营部门，所以这个岗位也称为<strong>数据运营</strong>或<strong>商业分析</strong>，这类人员通常也被称为“BI工程师”。通常招聘信息对这个岗位的描述（JD）是：</p>
<ol>
<li>负责相关报表的输出。</li>
<li>建立和优化指标体系。</li>
<li>监控数据波动和异常，找出问题。</li>
<li>优化和驱动业务，推动数字化运营。</li>
<li>找出潜在的市场和产品的上升空间。</li>
</ol>
<p>根据上面的描述，作为业务数据分析师，我们的工作不是给领导一个简单浅显的结论，而是结合公司的业务，完成<strong>监控数据</strong>、<strong>揪出异常</strong>、<strong>找到原因</strong>、<strong>探索趋势</strong>等工作。作为数据分析师，不管是用 Python 语言、Excel、SPSS或其他的商业智能工具，工具只是达成目标的手段，<strong>数据思维是核心技能</strong>，从实际业务问题出发到最终<strong>发现数据中的商业价值</strong>是终极目标。数据分析师在很多公司只是一个基础岗位，精于业务的数据分析师可以向<strong>数据分析经理</strong>或<strong>数据运营总监</strong>等管理岗位发展；对于熟悉机器学习算法的数据分析师来说，可以向<strong>数据挖掘工程师</strong>或<strong>算法专家</strong>方向发展，而这些岗位除了需要相应的数学和统计学知识，在编程能力方面也比数据分析师有更高的要求，可能还需要有大数据存储和处理的相关经验。数据治理岗位主要是帮助公司建设数据仓库或数据湖，实现数据从业务系统、埋点系统、日志系统到分析库的转移，为后续的数据分析和挖掘提供基础设施。数据治理岗位对 SQL 和 HiveSQL 有着较高的要求，需要熟练的使用 ETL 工具，此外还需要对 Hadoop 生态圈有一个较好的认知。作为数据产品经理，除了传统产品经理的技能栈之外，也需要较强的技术能力，例如要了解常用的推荐算法、机器学习模型，能够为算法的改进提供依据，能够制定相关埋点的规范和口径，虽然不需要精通各种算法，但是要站在产品的角度去考虑数据模型、指标、算法等的落地。</p>
<p>以下是我总结的数据分析师的技能栈，仅供参考。</p>
<ol>
<li>计算机科学（数据分析工具、编程语言、数据库）</li>
<li>数学和统计学（数据思维、统计思维）</li>
<li>人工智能（机器学习中的数据挖掘算法）</li>
<li>业务理解能力（沟通、表达、经验）</li>
<li>总结和表述能力（商业PPT、文字总结）</li>
</ol>
<h3 id="数据分析的流程"><a href="#数据分析的流程" class="headerlink" title="数据分析的流程"></a>数据分析的流程</h3><p>我们提到数分析这个词很多时候可能指的都是<strong>狭义的数据分析</strong>，这类数据分析主要目标就是生成可视化报表并通过这些报表来洞察业务中的问题，这类工作一般都是具有滞后性的。<strong>广义的数据分析</strong>还包含了数据挖掘的部分，不仅要通过数据实现对业务的监控和分析，还要利用机器学习算法，找出隐藏在数据背后的知识，并利用这些知识为将来的决策提供支撑，具备一定的前瞻性。</p>
<p>基本的数据分析工作一般包含以下几个方面的内容，当然因为行业和工作内容的不同会略有差异。</p>
<ol>
<li>确定目标（输入）：理解业务，确定指标口径</li>
<li>获取数据：数据仓库（SQL提数）、电子表格、三方接口、网络爬虫、开放数据集等</li>
<li>清洗数据：包括对缺失值、重复值、异常值的处理以及相关的预处理（格式化、离散化、二值化等）</li>
<li>数据透视：排序、统计、分组聚合、交叉表、透视表等</li>
<li>数据呈现（输出）：数据可视化，发布工作成果（数据分析报告）</li>
<li>分析洞察（后续）：解释数据的变化，提出对应的方案</li>
</ol>
<p>深入的数据挖掘工作通常包含以下几个方面的内容，当然因为行业和工作内容的不同会略有差异。</p>
<ol>
<li>确定目标（输入）：理解业务，明确挖掘目标</li>
<li>数据准备：数据采集、数据描述、数据探索、质量判定等</li>
<li>数据加工：提取数据、清洗数据、数据变换、特殊编码、降维、特征选择等</li>
<li>数据建模：模型比较、模型选择、算法应用</li>
<li>模型评估：交叉检验、参数调优、结果评价</li>
<li>模型部署（输出）：模型落地、业务改进、运营监控、报告撰写</li>
</ol>
<h3 id="数据分析相关库"><a href="#数据分析相关库" class="headerlink" title="数据分析相关库"></a>数据分析相关库</h3><p>使用 Python 从事数据科学相关的工作是一个非常棒的选择，因为 Python 整个生态圈中，有大量的成熟的用于数据科学的软件包（工具库）。而且不同于其他的用于数据科学的编程语言（如：Julia、R），Python 除了可以用于数据科学，还能做很多其他的事情，可以说 Python 语言几乎是无所不能的。</p>
<h4 id="三大神器"><a href="#三大神器" class="headerlink" title="三大神器"></a>三大神器</h4><ol>
<li><a target="_blank" rel="noopener" href="https://numpy.org/">NumPy</a>：支持常见的数组和矩阵操作，通过<code>ndarray</code>类实现了对多维数组的封装，提供了操作这些数组的方法和函数集。由于 NumPy 内置了并行运算功能，当使用多核 CPU 时，Numpy会自动做并行计算。</li>
<li><a target="_blank" rel="noopener" href="https://pandas.pydata.org/">Pandas</a>：pandas 的核心是其特有的数据结构<code>DataFrame</code>和<code>Series</code>，这使得 pandas 可以处理包含不同类型数据的表格和时间序列，这一点是NumPy的<code>ndarray</code>做不到的。使用 pandas，可以轻松顺利的加载各种形式的数据，然后对数据进行切片、切块、处理缺失值、聚合、重塑和可视化等操作。</li>
<li><a target="_blank" rel="noopener" href="https://matplotlib.org/">Matplotlib</a>：matplotlib 是一个包含各种绘图模块的库，能够根据我们提供的数据创建高质量的图表。此外，matplotlib 还提供了 pylab 模块，这个模块包含了很多像 <a target="_blank" rel="noopener" href="https://www.mathworks.com/products/matlab.html">MATLAB</a> 一样的绘图组件。</li>
</ol>
<h4 id="其他相关库"><a href="#其他相关库" class="headerlink" title="其他相关库"></a>其他相关库</h4><ol>
<li><a target="_blank" rel="noopener" href="https://scipy.org/">SciPy</a>：完善了 NumPy 的功能，封装了大量科学计算的算法，包括线性代数、统计检验、稀疏矩阵、信号和图像处理、最优化问题、快速傅里叶变换等。</li>
<li><a target="_blank" rel="noopener" href="https://seaborn.pydata.org/">Seaborn</a>：seaborn 是基于 matplotlib 的图形可视化工具，直接使用 matplotlib 虽然可以定制出漂亮的统计图表，但是总体来说还不够简单方便，seaborn 相当于是对 matplotlib 做了封装，让用户能够以更简洁有效的方式做出各种有吸引力的统计图表。</li>
<li><a target="_blank" rel="noopener" href="https://scikit-learn.org/">Scikit-learn</a>：scikit-learn 最初是 SciPy 的一部分，提供了大量机器学习可能用到的工具，包括数据预处理、监督学习（分类、回归）、无监督学习（聚类）、模式选择、交叉检验等。</li>
<li><a target="_blank" rel="noopener" href="https://www.statsmodels.org/stable/index.html">Statsmodels</a>：包含了经典统计学和经济计量学算法的库。</li>
</ol>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>如果希望快速开始使用 Python 处理数据科学相关的工作，建议大家直接安装 Anaconda，然后使用 Anaconda 中集成的 Notebook 或 JupyterLab 工具来编写代码。因为对于新手来说，先安装官方的 Python 解释器，再逐个安装工作中会使用到的三方库文件会比较麻烦，尤其是在 Windows 环境下，经常会因为构建工具或 DLL 文件的缺失导致安装失败，而一般新手也很难根据错误提示信息采取正确的解决措施，容易产生严重的挫败感。如果计算机上已经有 Python 解释器环境了，也可以直接使用 Python 的包管理工具 pip 安装 Jupyter，再根据实际工作的需要安装三方库，这种方式适合有一定经验的用户。</p>
<h3 id="安装和使用-Anaconda"><a href="#安装和使用-Anaconda" class="headerlink" title="安装和使用 Anaconda"></a>安装和使用 Anaconda</h3><p>对于个人用户来说，可以从 Anaconda 的<a target="_blank" rel="noopener" href="https://www.anaconda.com/">官方网站</a>下载它的“个人版（Individual Edition）”安装程序，安装完成后，你的计算机上不仅拥有了 Python 环境和 Spyder（类似于 PyCharm 的集成开发工具），还拥有了与数据科学工作相关的近200个工具包，包括我们上面提到 Python 数据分析三大神器。除此之外，Anaconda 还提供了一个名为 conda 的包管理工具，通过这个工具不仅可以管理 Python 的工具包，还可以用于创建运行 Python 程序的虚拟环境。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/download-anaconda.png" style="zoom:50%;"></p>
<p>如上图所示，可以通过 Anaconda 官网提供的下载链接选择适合自己操作系统的安装程序，建议大家选择图形化的安装程序，下载完成后双击安装程序开始安装。安装过程基本使用默认设置即可，完成安装后，macOS 用户可以在“应用程序”或“启动台”中找到名为“Anaconda-Navigator”的应用程序，运行该程序可以看到如下所示的界面，我们可以在这里选择需要执行的操作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/anaconda_navigator.png" style="zoom:50%;"></p>
<p>对于 Windows 用户，建议按照安装向导的提示和推荐的选项来安装 Anaconda（除了安装路径，基本也没有什么需要选择的），安装完成后可以在“开始菜单”中找到“Anaconda3”。</p>
<blockquote>
<p><strong>提示</strong>：可以选择 Miniconda 作为 Anaconda 的替代品，Miniconda 只会安装 Python 解释器环境和一些必要的工具，其他的三方库由用户自行选择安装。<strong>其实我个人并不喜欢 Anaconda，因为它是给小白用户使用的，我们有了 Python 环境以后完全可以按照自己的意愿来安装需要的三方库</strong>。</p>
</blockquote>
<h4 id="conda命令"><a href="#conda命令" class="headerlink" title="conda命令"></a>conda命令</h4><p>对于非新手用户，如果希望使用 conda 工具来管理依赖项或者创建项目的虚拟环境，可以在终端或命令行提示符中使用 conda 命令。Windows 用户可以在“开始菜单”中找到“Anaconda3”，然后点击“Anaconda Prompt”或“Anaconda PowerShell”来启动支持 conda 的命令行提示符。新手用户如果想创建新的虚拟环境或管理三方库（依赖项），建议直接使用“Anaconda-Navigator”中的“Environments”，通过可视化的方式对虚拟环境和依赖项进行管理。</p>
<ol>
<li><p>版本和帮助信息。</p>
<ul>
<li>查看版本：<code>conda -V</code>或<code>conda --version</code></li>
<li>获取帮助：<code>conda -h</code>或<code>conda --help</code></li>
<li>相关信息：<code>conda list</code></li>
</ul>
</li>
<li><p>虚拟环境相关。</p>
<ul>
<li>显示所有虚拟环境：<code>conda env list</code></li>
<li>创建虚拟环境：<code>conda create --name venv</code></li>
<li>指定 Python 版本创建虚拟环境：<code>conda create --name venv python=3.7</code></li>
<li>指定 Python 版本创建虚拟环境并安装指定依赖项：<code>conda create --name venv python=3.7 numpy pandas</code></li>
<li>通过克隆现有虚拟环境的方式创建虚拟环境：<code>conda create --name venv2 --clone venv</code></li>
<li>分享虚拟环境并重定向到指定的文件中：<code>conda env export &gt; environment.yml</code></li>
<li>通过分享的虚拟环境文件创建虚拟环境：<code>conda env create -f environment.yml</code></li>
<li>激活虚拟环境：<code>conda activate venv</code></li>
<li>退出虚拟环境：<code>conda deactivate</code></li>
<li><p>删除虚拟环境：<code>conda remove --name venv --all</code></p>
<blockquote>
<p><strong>说明</strong>：上面的命令中，<code>venv</code>和<code>venv2</code>是虚拟环境文件夹的名字，可以将其替换为自己喜欢的名字，但是<strong>强烈建议</strong>使用英文且不要有特殊字符。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>包（三方库或工具）管理。</p>
<ul>
<li>查看已经安装的包：<code>conda list</code></li>
<li>搜索指定的包：<code>conda search matplotlib</code></li>
<li>安装指定的包：<code>conda install matplotlib</code></li>
<li>更新指定的包：<code>conda update matplotlib</code></li>
<li><p>移除指定的包：<code>conda remove matplotlib</code></p>
<blockquote>
<p><strong>说明</strong>：在搜索、安装和更新软件包时，默认会连接到官方网站进行操作，如果觉得速度不给力，可以将默认的官方网站替换为国内的镜像网站，推荐使用清华大学的开源镜像网站。将默认源更换为国内镜像的命令是：<code>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</code>和<code>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</code>。如果需要换回默认源，可以使用命令<code>conda config --remove-key channels</code>。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="安装和使用JupyterLab"><a href="#安装和使用JupyterLab" class="headerlink" title="安装和使用JupyterLab"></a>安装和使用JupyterLab</h3><h4 id="安装和启动"><a href="#安装和启动" class="headerlink" title="安装和启动"></a>安装和启动</h4><p>如果已经安装了 Anaconda，可以按照上面所说的方式在“Anaconda-Navigator”中直接启动 Notebook 或 JupyterLab。按照官方的说法，JupyterLab 是下一代的 Notebook，提供了更友好的界面和更强大的功能，我们也推荐大家使用 JupyterLab。Windows 用户也可以在开始菜单中打开“Anaconda Prompt”或“Anaconda PowerShell”，由于已经激活了 Anaconda 默认的虚拟环境，只需要输入<code>jupyter lab</code>命令来启动JupyterLab。macOS 系统在安装 Anaconda以后，每次打开终端时会自动激活 Anaconda 默认的虚拟环境，也是通过输入<code>jupyter lab</code>命令就可以启动JupyterLab。</p>
<p>对于安装了 Python 环境但是没有安装 Anaconda 的用户，可以用 Python 的包管理工具<code>pip</code>来安装 JupyterLab，安装成功后在终端或命令行提示符中执行<code>jupyter lab</code>命令来启动 JupyterLab，如下所示。</p>
<p>安装 JupyterLab：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyterlab</span><br></pre></td></tr></table></figure>
<p>安装 Python 数据分析三大神器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy pandas matplotlib</span><br></pre></td></tr></table></figure>
<p>启动 JupyterLab：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter lab</span><br></pre></td></tr></table></figure>
<p>JupyterLab 是基于网页的用于交互计算的应用程序，可以用于代码开发、文档撰写、代码运行和结果展示。简单的说，你可以在网页中直接<strong>编写代码</strong>和<strong>运行代码</strong>，代码的运行结果也会直接在代码块下方进行展示。如在编写代码的过程中需要编写说明文档，可在同一个页面中使用 Markdown 格式进行编写，而且可以直接看到渲染后的效果。此外，Notebook 的设计初衷是提供一个能够支持多种编程语言的工作环境，目前它能够支持超过40种编程语言，包括 Python、R、Julia、Scala 等。</p>
<p>首先，我们可以创建一个用于书写 Python 代码的 Notebook，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/JupyterLab_1.png" style="zoom:50%;"></p>
<p>接下来，我们就可以编写代码、撰写文档和运行程序啦，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/JupyterLab_2.png" style="zoom:50%;"></p>
<h4 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h4><p>如果使用 Python 做工程化的项目开发，PyCharm 肯定是最好的选择，它提供了一个集成开发环境应该具有的所有功能，尤其是智能提示、代码补全、自动纠错这类功能会让开发人员感到非常舒服。如果使用 Python 做数据科学相关的工作，JupyterLab 并不比 PyCharm 逊色，在数据和图表展示方面 JupyterLab 更加优秀。为此，JetBrains 公司还专门开发了一个对标 JupyterLab 的新工具 DataSpell，有兴趣的读者可以自行了解。下面我们为大家介绍一些 JupyterLab 的使用技巧，希望能够帮助大家提升工作效率。</p>
<ol>
<li><p>自动补全。在使用 JupyterLab 编写代码时，按<code>Tab</code>键会获得代码提示和补全功能。</p>
</li>
<li><p>获得帮助。如果希望了解一个对象（如变量、类、函数等）的相关信息或使用方式，可以在对象后面使用<code>?</code>并运行代码， 窗口下方会显示出对应的信息，帮助我们了解该对象，如下所示。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/JupyterLab_3.png" style="zoom:100%;"></p>
</li>
<li><p>搜索命名。如果只记得一个类或一个函数名字的一部分，可以使用通配符<code>*</code>并配合<code>?</code>进行搜索，如下所示。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/JupyterLab_4.png" style="zoom:100%;"></p>
</li>
<li><p>调用命令。可以在 JupyterLab 中使用<code>!</code>后面跟系统命令的方式来执行系统命令。</p>
</li>
<li><p>魔法指令。JupyterLab 中有很多非常有趣且有用的魔法指令，例如可以使用<code>%timeit</code>测试语句的执行时间，可以使用<code>%pwd</code>查看当前工作目录等。如果想查看所有的魔法指令，可以使用<code>%lsmagic</code>，如果了解魔法指令的用法，可以使用<code>%magic</code>来查看，如下图所示。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/JupyterLab_5.png" style="zoom:100%;"></p>
<p> 常用的魔法指令有：</p>
<p> | 魔法指令                                    | 功能说明                                   |<br> | —————————————————————- | ————————————————————— |<br> | <code>%pwd</code>                                      | 查看当前工作目录                           |<br> | <code>%ls</code>                                       | 列出当前或指定文件夹下的内容               |<br> | <code>%cat</code>                                      | 查看指定文件的内容                         |<br> | <code>%hist</code>                                     | 查看输入历史                               |<br> | <code>%matplotlib inline</code>                        | 设置在页面中嵌入matplotlib输出的统计图表   |<br> | <code>%config Inlinebackend.figure_format=&#39;svg&#39;</code> | 设置统计图表使用SVG格式（矢量图）          |<br> | <code>%run</code>                                      | 运行指定的程序                             |<br> | <code>%load</code>                                     | 加载指定的文件到单元格中                   |<br> | <code>%quickref</code>                                 | 显示IPython的快速参考                      |<br> | <code>%timeit</code>                                   | 多次运行代码并统计代码执行时间             |<br> | <code>%prun</code>                                     | 用<code>cProfile.run</code>运行代码并显示分析器的输出 |<br> | <code>%who</code> / <code>%whos</code>                            | 显示命名空间中的变量                       |<br> | <code>%xdel</code>                                     | 删除一个对象并清理所有对它的引用           |</p>
</li>
<li><p>快捷键。JupyterLab 中的很多操作可以通过快捷键来实现，使用快捷键可以提升工作效率。JupyterLab 的快捷键可以分为命令模式下的快捷键和编辑模式下的快捷键，所谓编辑模式就是处于输入代码或撰写文档状态的模式，在编辑模式下按<code>Esc</code>可以回到命令模式，在命令模式下按<code>Enter</code>可以进入编辑模式。</p>
<p> 命令模式下的快捷键：</p>
<p> | 快捷键                                   | 功能说明                                     |<br> | ———————————————————— | —————————————————————— |<br> | <code>Alt</code> + <code>Enter</code>                          | 运行当前单元格并在下面插入新的单元格         |<br> | <code>Shift</code> + <code>Enter</code>                        | 运行当前单元格并选中下方的单元格             |<br> | <code>Ctrl</code> + <code>Enter</code>                         | 运行当前单元格                               |<br> | <code>j</code> / <code>k</code>、<code>Shift</code> + <code>j</code> / <code>Shift</code> + <code>k</code> | 选中下方/上方单元格、连续选中下方/上方单元格 |<br> | <code>a</code> / <code>b</code>                                | 在下方/上方插入新的单元格                    |<br> | <code>c</code> / <code>x</code>                                | 复制单元格 / 剪切单元格                      |<br> | <code>v</code> / <code>Shift</code> + <code>v</code>                      | 在下方/上方粘贴单元格                        |<br> | <code>dd</code> / <code>z</code>                               | 删除单元格 / 恢复删除的单元格                |<br> | <code>Shift</code> + <code>l</code>                            | 显示或隐藏当前/所有单元格行号                |<br> | <code>Space</code> / <code>Shift</code> + <code>Space</code>              | 向下/向上滚动页面                            |</p>
<p> 编辑模式下的快捷键：</p>
<p> | 快捷键                     | 功能说明                               |<br> | ————————————— | ——————————————————— |<br> | <code>Shift</code> + <code>Tab</code>            | 获得提示信息                           |<br> | <code>Ctrl</code> + <code>]</code>/ <code>Ctrl</code> + <code>[</code> | 增加/减少缩进                          |<br> | <code>Alt</code> + <code>Enter</code>            | 运行当前单元格并在下面插入新的单元格   |<br> | <code>Shift</code> + <code>Enter</code>          | 运行当前单元格并选中下方的单元格       |<br> | <code>Ctrl</code> + <code>Enter</code>           | 运行当前单元格                         |<br> | <code>Ctrl</code> + <code>Left</code> / <code>Right</code>  | 光标移到行首/行尾                      |<br> | <code>Ctrl</code> + <code>Up</code> / <code>Down</code>     | 光标移动代码开头/结尾处                |<br> | <code>Up</code> / <code>Down</code>              | 光标上移/下移一行或移到上/下一个单元格 |</p>
<blockquote>
<p><strong>说明</strong>：对于 macOS 系统可以将<code>Alt</code>键替换成<code>Option</code>键，将<code>Ctrl</code>键替换成<code>Command</code>键。</p>
</blockquote>
</li>
</ol>
<h2 id="NumPy的应用-1"><a href="#NumPy的应用-1" class="headerlink" title="NumPy的应用-1"></a>NumPy的应用-1</h2><p>Numpy 是一个开源的 Python 科学计算库，<strong>用于快速处理任意维度的数组</strong>。Numpy <strong>支持常见的数组和矩阵操作</strong>，对于同样的数值计算任务，使用 NumPy 不仅代码要简洁的多，而且 NumPy 在性能上也远远优于原生 Python，至少是一到两个数量级的差距，而且数据量越大，NumPy 的优势就越明显。</p>
<p>NumPy 最为核心的数据类型是<code>ndarray</code>，使用<code>ndarray</code>可以处理一维、二维和多维数组，该对象相当于是一个快速而灵活的大数据容器。NumPy 底层代码使用 C 语言编写，解决了 GIL 的限制，<code>ndarray</code>在存取数据的时候，数据与数据的地址都是连续的，这确保了可以进行高效率的批量操作，性能上远远优于 Python 中的<code>list</code>；另一方面<code>ndarray</code>对象提供了更多的方法来处理数据，尤其获取数据统计特征的方法，这些方法也是 Python 原生的<code>list</code>没有的。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li><p>启动 JupyterLab</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter lab</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示</strong>：在启动 JupyterLab 之前，建议先安装好数据分析相关依赖项，包括之前提到的三大神器以及相关依赖项。如果使用 Anaconda，则无需单独安装，可以通过 Anaconda 的 Navigator 来启动。</p>
</blockquote>
</li>
<li><p>导入</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：如果已经启动了 JupyterLab 但尚未安装相关依赖库，例如尚未安装<code>numpy</code>，可以在单元格中输入<code>%pip install numpy</code>并运行该单元格来安装 NumPy。当然，我们也可以在单元格中输入<code>%pip install numpy pandas matplotlib</code>把 Python 数据分析三个核心的三方库都安装上。注意上面的代码，我们不仅导入了 NumPy，还将 pandas 和 matplotlib 库一并导入了。</p>
</blockquote>
</li>
</ol>
<h3 id="创建数组对象"><a href="#创建数组对象" class="headerlink" title="创建数组对象"></a>创建数组对象</h3><p>创建<code>ndarray</code>对象有很多种方法，下面我们介绍一些常用的方法。</p>
<p>方法一：使用<code>array</code>函数，通过<code>list</code>创建数组对象</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">array1</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([1, 2, 3, 4, 5])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array2 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">array2</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[1, 2, 3],</span><br><span class="line">       [4, 5, 6]])</span><br></pre></td></tr></table></figure>
<p>方法二：使用<code>arange</code>函数，指定取值范围和跨度创建数组对象</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array3 = np.arange(<span class="number">0</span>, <span class="number">20</span>, <span class="number">2</span>)</span><br><span class="line">array3</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18])</span><br></pre></td></tr></table></figure>
<p>方法三：使用<code>linspace</code>函数，用指定范围和元素个数创建数组对象，生成等差数列</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array4 = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">11</span>)</span><br><span class="line">array4</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([-1. , -0.8, -0.6, -0.4, -0.2,  0. ,  0.2,  0.4,  0.6,  0.8,  1. ])</span><br></pre></td></tr></table></figure>
<p>方法四：使用<code>logspace</code>函数，生成等比数列</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array5 = np.logspace(<span class="number">1</span>, <span class="number">10</span>, num=<span class="number">10</span>, base=<span class="number">2</span>)</span><br><span class="line">array5</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：等比数列的起始值是$2^1$，等比数列的终止值是$2^{10}$，<code>num</code>是元素的个数，<code>base</code>就是底数。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([   2.,    4.,    8.,   16.,   32.,   64.,  128.,  256.,  512., 1024.])</span><br></pre></td></tr></table></figure>
<p>方法五：通过<code>fromstring</code>函数从字符串提取数据创建数组对象</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array6 = np.fromstring(<span class="string">&#x27;1, 2, 3, 4, 5&#x27;</span>, sep=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="string">&#x27;i8&#x27;</span>)</span><br><span class="line">array6 </span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([1, 2, 3, 4, 5])</span><br></pre></td></tr></table></figure>
<p>方法六：通过<code>fromiter</code>函数从生成器（迭代器）中获取数据创建数组对象</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">how_many</span>):</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(how_many):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gen = fib(<span class="number">20</span>)</span><br><span class="line">array7 = np.fromiter(gen, dtype=<span class="string">&#x27;i8&#x27;</span>)</span><br><span class="line">array7</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([   1,    1,    2,    3,    5,    8,   13,   21,   34,   55,   89,</span><br><span class="line">        144,  233,  377,  610,  987, 1597, 2584, 4181, 6765])</span><br></pre></td></tr></table></figure>
<p>方法七：使用<code>numpy.random</code>模块的函数生成随机数创建数组对象</p>
<p>产生10个$[0, 1)$范围的随机小数，代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array8 = np.random.rand(<span class="number">10</span>)</span><br><span class="line">array8</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([0.45556132, 0.67871326, 0.4552213 , 0.96671509, 0.44086463,</span><br><span class="line">       0.72650875, 0.79877188, 0.12153022, 0.24762739, 0.6669852 ])</span><br></pre></td></tr></table></figure>
<p>产生10个$[1, 100)$范围的随机整数，代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array9 = np.random.randint(<span class="number">1</span>, <span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">array9</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([29, 97, 87, 47, 39, 19, 71, 32, 79, 34])</span><br></pre></td></tr></table></figure>
<p>产生20个$\small{\mu=50}$，$\small{\sigma=10}$的正态分布随机数，代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array10 = np.random.normal(<span class="number">50</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">array10</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array([55.04155586, 46.43510797, 20.28371158, 62.67884053, 61.23185964,</span><br><span class="line">       38.22682148, 53.17126151, 43.54741592, 36.11268017, 40.94086676,</span><br><span class="line">       63.27911699, 46.92688903, 37.1593374 , 67.06525656, 67.47269463,</span><br><span class="line">       23.37925889, 31.45312239, 48.34532466, 55.09180924, 47.95702787])</span><br></pre></td></tr></table></figure>
<p>产生$[0, 1)$范围的随机小数构成的3行4列的二维数组，代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array11 = np.random.rand(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">array11</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[0.54017809, 0.46797771, 0.78291445, 0.79501326],</span><br><span class="line">       [0.93973783, 0.21434806, 0.03592874, 0.88838892],</span><br><span class="line">       [0.84130479, 0.3566601 , 0.99935473, 0.26353598]])</span><br></pre></td></tr></table></figure>
<p>产生$[1, 100)$范围的随机整数构成的三维数组，代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array12 = np.random.randint(<span class="number">1</span>, <span class="number">100</span>, (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">array12</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">array([[[94, 26, 49, 24, 43],</span><br><span class="line">        [27, 27, 33, 98, 33],</span><br><span class="line">        [13, 73,  6,  1, 77],</span><br><span class="line">        [54, 32, 51, 86, 59]],</span><br><span class="line"></span><br><span class="line">       [[62, 75, 62, 29, 87],</span><br><span class="line">        [90, 26,  6, 79, 41],</span><br><span class="line">        [31, 15, 32, 56, 64],</span><br><span class="line">        [37, 84, 61, 71, 71]],</span><br><span class="line"></span><br><span class="line">       [[45, 24, 78, 77, 41],</span><br><span class="line">        [75, 37,  4, 74, 93],</span><br><span class="line">        [ 1, 36, 36, 60, 43],</span><br><span class="line">        [23, 84, 44, 89, 79]]])</span><br></pre></td></tr></table></figure>
<p>方法八：创建全0、全1或指定元素的数组</p>
<p>使用<code>zeros</code>函数，代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array13 = np.zeros((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">array13</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[0., 0., 0., 0.],</span><br><span class="line">       [0., 0., 0., 0.],</span><br><span class="line">       [0., 0., 0., 0.]])</span><br></pre></td></tr></table></figure>
<p>使用<code>ones</code>函数，代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array14 = np.ones((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">array14</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[1., 1., 1., 1.],</span><br><span class="line">       [1., 1., 1., 1.],</span><br><span class="line">       [1., 1., 1., 1.]])</span><br></pre></td></tr></table></figure>
<p>使用<code>full</code>函数，代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array15 = np.full((<span class="number">3</span>, <span class="number">4</span>), <span class="number">10</span>)</span><br><span class="line">array15</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[10, 10, 10, 10],</span><br><span class="line">       [10, 10, 10, 10],</span><br><span class="line">       [10, 10, 10, 10]])</span><br></pre></td></tr></table></figure>
<p>方法九：使用<code>eye</code>函数创建单位矩阵</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.eye(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array([[1., 0., 0., 0.],</span><br><span class="line">       [0., 1., 0., 0.],</span><br><span class="line">       [0., 0., 1., 0.],</span><br><span class="line">       [0., 0., 0., 1.]])</span><br></pre></td></tr></table></figure>
<p>方法十：读取图片获得对应的三维数组</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array16 = plt.imread(<span class="string">&#x27;res/guido.jpg&#x27;</span>)</span><br><span class="line">array16</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">array([[[ 36,  33,  28],</span><br><span class="line">        [ 36,  33,  28],</span><br><span class="line">        [ 36,  33,  28],</span><br><span class="line">        ...,</span><br><span class="line">        [ 32,  31,  29],</span><br><span class="line">        [ 32,  31,  27],</span><br><span class="line">        [ 31,  32,  26]],</span><br><span class="line"></span><br><span class="line">       [[ 37,  34,  29],</span><br><span class="line">        [ 38,  35,  30],</span><br><span class="line">        [ 38,  35,  30],</span><br><span class="line">        ...,</span><br><span class="line">        [ 31,  30,  28],</span><br><span class="line">        [ 31,  30,  26],</span><br><span class="line">        [ 30,  31,  25]],</span><br><span class="line"></span><br><span class="line">       [[ 38,  35,  30],</span><br><span class="line">        [ 38,  35,  30],</span><br><span class="line">        [ 38,  35,  30],</span><br><span class="line">        ...,</span><br><span class="line">        [ 30,  29,  27],</span><br><span class="line">        [ 30,  29,  25],</span><br><span class="line">        [ 29,  30,  25]],</span><br><span class="line"></span><br><span class="line">       ...,</span><br><span class="line"></span><br><span class="line">       [[239, 178, 123],</span><br><span class="line">        [237, 176, 121],</span><br><span class="line">        [235, 174, 119],</span><br><span class="line">        ...,</span><br><span class="line">        [ 78,  68,  56],</span><br><span class="line">        [ 75,  67,  54],</span><br><span class="line">        [ 73,  65,  52]],</span><br><span class="line"></span><br><span class="line">       [[238, 177, 120],</span><br><span class="line">        [236, 175, 118],</span><br><span class="line">        [234, 173, 116],</span><br><span class="line">        ...,</span><br><span class="line">        [ 82,  70,  58],</span><br><span class="line">        [ 78,  68,  56],</span><br><span class="line">        [ 75,  66,  51]],</span><br><span class="line"></span><br><span class="line">       [[238, 176, 119],</span><br><span class="line">        [236, 175, 118],</span><br><span class="line">        [234, 173, 116],</span><br><span class="line">        ...,</span><br><span class="line">        [ 84,  70,  61],</span><br><span class="line">        [ 81,  69,  57],</span><br><span class="line">        [ 79,  67,  53]]], dtype=uint8)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：上面的代码读取了当前路径下<code>res</code>目录中名为<code>guido.jpg</code> 的图片文件，计算机系统中的图片通常由若干行若干列的像素点构成，而每个像素点又是由红绿蓝三原色构成的，刚好可以用三维数组来表示。读取图片用到了<code>matplotlib</code>库的<code>imread</code>函数。</p>
</blockquote>
<h3 id="数组对象的属性"><a href="#数组对象的属性" class="headerlink" title="数组对象的属性"></a>数组对象的属性</h3><p><code>size</code>属性：获取数组元素个数。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array17 = np.arange(<span class="number">1</span>, <span class="number">100</span>, <span class="number">2</span>)</span><br><span class="line">array18 = np.random.rand(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(array16.size)</span><br><span class="line"><span class="built_in">print</span>(array17.size)</span><br><span class="line"><span class="built_in">print</span>(array18.size)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1125000</span><br><span class="line">50</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<p><code>shape</code>属性：获取数组的形状。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(array16.shape)</span><br><span class="line"><span class="built_in">print</span>(array17.shape)</span><br><span class="line"><span class="built_in">print</span>(array18.shape)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(750, 500, 3)</span><br><span class="line">(50,)</span><br><span class="line">(3, 4)</span><br></pre></td></tr></table></figure>
<p><code>dtype</code>属性：获取数组元素的数据类型。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(array16.dtype)</span><br><span class="line"><span class="built_in">print</span>(array17.dtype)</span><br><span class="line"><span class="built_in">print</span>(array18.dtype)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint8</span><br><span class="line">int64</span><br><span class="line">float64</span><br></pre></td></tr></table></figure>
<p><code>ndarray</code>对象元素的数据类型可以参考如下所示的表格。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/dtype.jpg" style="zoom:50%;"></p>
<p><code>ndim</code>属性：获取数组的维度。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(array16.ndim)</span><br><span class="line"><span class="built_in">print</span>(array17.ndim)</span><br><span class="line"><span class="built_in">print</span>(array18.ndim)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p><code>itemsize</code>属性：获取数组单个元素占用内存空间的字节数。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(array16.itemsize)</span><br><span class="line"><span class="built_in">print</span>(array17.itemsize)</span><br><span class="line"><span class="built_in">print</span>(array18.itemsize)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">8</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<p><code>nbytes</code>属性：获取数组所有元素占用内存空间的字节数。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(array16.nbytes)</span><br><span class="line"><span class="built_in">print</span>(array17.nbytes)</span><br><span class="line"><span class="built_in">print</span>(array18.nbytes)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1125000</span><br><span class="line">400</span><br><span class="line">96</span><br></pre></td></tr></table></figure>
<h3 id="数组的索引运算"><a href="#数组的索引运算" class="headerlink" title="数组的索引运算"></a>数组的索引运算</h3><p>和 Python 中的列表类似，NumPy 的<code>ndarray</code>对象可以进行索引和切片操作，通过索引可以获取或修改数组中的元素，通过切片操作可以取出数组的一部分，我们把切片操作也称为切片索引。</p>
<h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p>类似于 Python 中<code>list</code>类型的索引运算。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array19 = np.arange(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(array19[<span class="number">0</span>], array19[array19.size - <span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(array19[-array20.size], array19[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 9</span><br><span class="line">1 9</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array20 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">array20[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([7, 8, 9])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(array20[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(array20[-<span class="number">1</span>][-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(array20[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(array20[<span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array20[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">array20</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[ 1,  2,  3],</span><br><span class="line">       [ 4, 10,  6],</span><br><span class="line">       [ 7,  8,  9]])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array20[<span class="number">1</span>] = [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line">array20</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[ 1,  2,  3],</span><br><span class="line">       [10, 11, 12],</span><br><span class="line">       [ 7,  8,  9]])</span><br></pre></td></tr></table></figure>
<h4 id="切片索引"><a href="#切片索引" class="headerlink" title="切片索引"></a>切片索引</h4><p>切片索引是形如<code>[开始索引:结束索引:跨度]</code>的语法，通过指定<strong>开始索引</strong>（默认值无穷小）、<strong>结束索引</strong>（默认值无穷大）和<strong>跨度</strong>（默认值1），从数组中取出指定部分的元素并构成新的数组。因为开始索引、结束索引和步长都有默认值，所以它们都可以省略，如果不指定步长，第二个冒号也可以省略。一维数组的切片运算跟 Python 中的<code>list</code>类型的切片非常类似，此处不再赘述，二维数组的切片可以参考下面的代码，相信非常容易理解。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array20[:<span class="number">2</span>, <span class="number">1</span>:]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[ 2,  3],</span><br><span class="line">       [11, 12]])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array20[<span class="number">2</span>, :]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([7, 8, 9])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array20[<span class="number">2</span>:, :]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([[7, 8, 9]])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array20[:, :<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[ 1,  2],</span><br><span class="line">       [10, 11],</span><br><span class="line">       [ 7,  8]])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array20[::<span class="number">2</span>, ::<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[1, 3],</span><br><span class="line">       [7, 9]])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array20[::-<span class="number">2</span>, ::-<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[9, 7],</span><br><span class="line">       [3, 1]])</span><br></pre></td></tr></table></figure>
<p>关于数组的索引和切片运算，大家可以通过下面的两张图来增强印象，这两张图来自<a target="_blank" rel="noopener" href="https://item.jd.com/12398725.html">《利用Python进行数据分析》</a>一书，它是 pandas 库的作者 Wes McKinney 撰写的 Python 数据分析领域的经典教科书，有兴趣的读者可以购买和阅读原书。</p>
<p>图1：二维数组的普通索引</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/ndarray-index.png" style="zoom:60%;"></p>
<p>图2：二维数组的切片索引</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/ndarray-slice.png" style="zoom:60%;"></p>
<h4 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h4><p>花式索引是用保存整数的数组充当一个数组的索引，这里所说的数组可以是 NumPy 的<code>ndarray</code>，也可以是 Python 中<code>list</code>、<code>tuple</code>等可迭代类型，可以使用正向或负向索引。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array19[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([1, 2, 2, 9, 5, 9])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array20[[<span class="number">0</span>, <span class="number">2</span>]]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[1, 2, 3],</span><br><span class="line">       [7, 8, 9]])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array20[[<span class="number">0</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>]]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([2, 9])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array20[[<span class="number">0</span>, <span class="number">2</span>], <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([2, 8])</span><br></pre></td></tr></table></figure>
<h4 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h4><p>布尔索引就是通过保存布尔值的数组充当一个数组的索引，布尔值为<code>True</code>的元素保留，布尔值为<code>False</code>的元素不会被选中。布尔值的数组可以手动构造，也可以通过关系运算来产生。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array19[[<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>]]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([1, 2, 5, 8, 9])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array19 &gt; <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([False, False, False, False, False,  True,  True,  True,  True])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~(array19 &gt; <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([ True,  True,  True,  True,  True, False, False, False, False])</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：<code>~</code>运算符可以对布尔数组中的布尔值进行逻辑取反，也就是原来的<code>True</code>会变成<code>False</code>，原来的<code>False</code>会变成<code>True</code>。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array19[array20 &gt; <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([6, 7, 8, 9])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array19 % <span class="number">2</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([False,  True, False,  True, False,  True, False,  True, False])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array19[array20 % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([2, 4, 6, 8])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(array19 &gt; <span class="number">5</span>) &amp; (array19 % <span class="number">2</span> == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([False, False, False, False, False,  True, False,  True, False])</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：<code>&amp;</code>运算符可以作用于两个布尔数组，如果两个数组对应元素都是<code>True</code>，那么运算的结果就是<code>True</code>，否则就是<code>False</code>，该运算符的运算规则类似于 Python 中的 <code>and</code> 运算符，只不过作用的对象是两个布尔数组。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array19[(array19 &gt; <span class="number">5</span>) &amp; (array19 % <span class="number">2</span> == <span class="number">0</span>)]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([6, 8])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array19[(array19 &gt; <span class="number">5</span>) | (array19 % <span class="number">2</span> == <span class="number">0</span>)]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([2, 4, 6, 7, 8, 9])</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：<code>|</code>运算符可以作用于两个布尔数组，如果两个数组对应元素都是<code>False</code>，那么运算的结果就是<code>False</code>，否则就是<code>True</code>，该运算符的运算规则类似于 Python 中的 <code>or</code> 运算符，只不过作用的对象是两个布尔数组。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array20[array21 % <span class="number">2</span> != <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([1, 3, 5, 7, 9])</span><br></pre></td></tr></table></figure>
<p>关于索引运算需要说明的是，切片索引虽然创建了新的数组对象，但是新数组和原数组共享了数组中的数据，简单的说，无论你通过新数组对象或原数组对象修改数组中的数据，修改的其实是内存中的同一块数据。花式索引和布尔索引也会创建新的数组对象，而且新数组复制了原数组的元素，新数组和原数组并不是共享数据的关系，这一点可以查看数组对象的<code>base</code>属性，有兴趣的读者可以自行探索。</p>
<h3 id="案例：通过数组切片处理图像"><a href="#案例：通过数组切片处理图像" class="headerlink" title="案例：通过数组切片处理图像"></a>案例：通过数组切片处理图像</h3><p>学习基础知识总是比较枯燥且没有成就感的，所以我们还是来个案例为大家演示下上面学习的数组索引和切片操作到底有什么用。前面我们说到过，可以用三维数组来表示图像，那么通过图像对应的三维数组进行操作，就可以实现对图像的处理，如下所示。</p>
<p>读入图片创建三维数组对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">guido_image = plt.imread(<span class="string">&#x27;guido.jpg&#x27;</span>)</span><br><span class="line">plt.imshow(guido_image)</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/guido_slice_1.png" style="zoom:65%;"></p>
<p>对数组的0轴进行反向切片，实现图像的垂直翻转。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(guido_image[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/guido_slice_2.png" style="zoom:65%;"></p>
<p>对数组的1轴进行反向切片，实现图像的水平翻转。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(guido_image[:,::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/guido_slice_3.png" style="zoom:65%;"></p>
<p>通过切片操作实现抠图，将吉多大叔的头抠出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(guido_image[<span class="number">30</span>:<span class="number">350</span>, <span class="number">90</span>:<span class="number">300</span>])</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/guido_slice_4.png" style="zoom:65%;"></p>
<p>通过切片操作实现降采样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(guido_image[::<span class="number">10</span>, ::<span class="number">10</span>])</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/guido_slice_5.png" style="zoom:65%;"></p>
<h2 id="NumPy的应用-2"><a href="#NumPy的应用-2" class="headerlink" title="NumPy的应用-2"></a>NumPy的应用-2</h2><h3 id="数组对象的方法"><a href="#数组对象的方法" class="headerlink" title="数组对象的方法"></a>数组对象的方法</h3><h4 id="获取描述统计信息"><a href="#获取描述统计信息" class="headerlink" title="获取描述统计信息"></a>获取描述统计信息</h4><p>描述统计信息主要包括数据的集中趋势、离散程度和频数分析等，其中集中趋势主要看均值和中位数，离散程度可以看极值、方差、标准差等，详细的内容大家可以阅读<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/595273755">《统计思维系列课程01：解读数据》</a>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array1 = np.random.randint(<span class="number">1</span>, <span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">array1</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([46, 51, 15, 42, 53, 71, 20, 62,  6, 94])</span><br></pre></td></tr></table></figure>
<p><strong>计算总和、均值和中位数。</strong></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(array1.<span class="built_in">sum</span>())</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(array1))</span><br><span class="line"><span class="built_in">print</span>(array1.mean())</span><br><span class="line"><span class="built_in">print</span>(np.mean(array1))</span><br><span class="line"><span class="built_in">print</span>(np.median(array1))</span><br><span class="line"><span class="built_in">print</span>(np.quantile(array1, <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：上面代码中的<code>mean</code>、<code>median</code>和<code>quantile</code>分别是 NumPy 中计算算术平均值、中位数和分位数的函数，其中<code>quantitle</code>函数的第二个参数设置为0.5表示计算50%分位数，也就是中位数。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">460</span><br><span class="line">460</span><br><span class="line">46.0</span><br><span class="line">46.0</span><br><span class="line">48.5</span><br><span class="line">48.5</span><br></pre></td></tr></table></figure>
<p><strong>极值、全距和四分位距离。</strong></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(array1.<span class="built_in">max</span>())</span><br><span class="line"><span class="built_in">print</span>(np.amax(array1))</span><br><span class="line"><span class="built_in">print</span>(array1.<span class="built_in">min</span>())</span><br><span class="line"><span class="built_in">print</span>(np.amin(array1))</span><br><span class="line"><span class="built_in">print</span>(array1.ptp())</span><br><span class="line"><span class="built_in">print</span>(np.ptp(array1))</span><br><span class="line">q1, q3 = np.quantile(array1, [<span class="number">0.25</span>, <span class="number">0.75</span>])</span><br><span class="line"><span class="built_in">print</span>(q3 - q1)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">94</span><br><span class="line">94</span><br><span class="line">6</span><br><span class="line">6</span><br><span class="line">88</span><br><span class="line">88</span><br><span class="line">34.25</span><br></pre></td></tr></table></figure>
<p><strong>方差、标准差和变异系数。</strong></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(array1.var())</span><br><span class="line"><span class="built_in">print</span>(np.var(array1))</span><br><span class="line"><span class="built_in">print</span>(array1.std())</span><br><span class="line"><span class="built_in">print</span>(np.std(array1))</span><br><span class="line"><span class="built_in">print</span>(array1.std() / array1.mean())</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">651.2</span><br><span class="line">651.2</span><br><span class="line">25.51862065237853</span><br><span class="line">25.51862065237853</span><br><span class="line">0.5547526228777941</span><br></pre></td></tr></table></figure>
<p><strong>绘制箱线图。</strong></p>
<p>箱线图又称为盒须图，是显示一组数据分散情况的统计图，因形状如箱子而得名。 它主要用于反映原始数据分布的特征，还可以进行多组数据分布特征的比较。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.boxplot(array1, showmeans=<span class="literal">True</span>)</span><br><span class="line">plt.ylim([-<span class="number">20</span>, <span class="number">120</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/box_plot_1.png" style="zoom:40%;"></p>
<p>值得注意的是，对于二维或更高维的数组，在获取描述统计信息时，可以通过名为<code>axis</code>的参数指定均值、方差等运算是沿着哪一个轴来执行，<code>axis</code>参数不同，执行的结果可能是大相径庭的，如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array2 = np.random.randint(<span class="number">60</span>, <span class="number">101</span>, (<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">array2</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([[72, 64, 73],</span><br><span class="line">       [61, 73, 61],</span><br><span class="line">       [76, 85, 77],</span><br><span class="line">       [97, 88, 90],</span><br><span class="line">       [63, 93, 82]])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array2.mean()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">77.0</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array2.mean(axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([73.8, 80.6, 76.6])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array2.mean(axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([69.66666667, 65.        , 79.33333333, 91.66666667, 79.33333333])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array2.<span class="built_in">max</span>(axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([97, 93, 90])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array2.<span class="built_in">max</span>(axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([73, 73, 85, 97, 93])</span><br></pre></td></tr></table></figure>
<p>再看看绘制箱线图，对于二维数组每一列都会产生一个统计图形，如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.boxplot(array2, showmeans=<span class="literal">True</span>)</span><br><span class="line">plt.ylim([-<span class="number">20</span>, <span class="number">120</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/box_plot_2.png" style="zoom:75%;"></p>
<blockquote>
<p><strong>说明</strong>：箱线图中的小圆圈用来表示离群点，也就是大于$\small{Q_3 + 1.5 \times IQR}$或小于$\small{Q_1 - 1.5 \times IQR}$的值。公式中的常量<code>1.5</code>可以通过绘制箱线图的<code>boxplot</code>函数的<code>whis</code>参数进行修改，常用的值是<code>1.5</code>和<code>3</code>，修改为<code>3</code>通常是为了标识出极度离群点。</p>
</blockquote>
<p>需要说明的是，NumPy 的数组对象并没有提供计算几何平均值、调和平均值、去尾平均值等的方法，如果有这方面的需求，可以使用名为 scipy 的三方库，它的<code>stats</code>模块中提供了这些函数。此外，该模块还提供了计算众数、变异系数、偏态、峰度的函数，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.mean(array1))                <span class="comment"># 算术平均值</span></span><br><span class="line"><span class="built_in">print</span>(stats.gmean(array1))            <span class="comment"># 几何平均值</span></span><br><span class="line"><span class="built_in">print</span>(stats.hmean(array1))            <span class="comment"># 调和平均值</span></span><br><span class="line"><span class="built_in">print</span>(stats.tmean(array1, [<span class="number">10</span>, <span class="number">90</span>]))  <span class="comment"># 去尾平均值</span></span><br><span class="line"><span class="built_in">print</span>(stats.variation(array1))        <span class="comment"># 变异系数</span></span><br><span class="line"><span class="built_in">print</span>(stats.skew(array1))             <span class="comment"># 偏态系数</span></span><br><span class="line"><span class="built_in">print</span>(stats.kurtosis(array1))         <span class="comment"># 峰度系数</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">46.0</span><br><span class="line">36.22349548825599</span><br><span class="line">24.497219530825497</span><br><span class="line">45.0</span><br><span class="line">0.5547526228777941</span><br><span class="line">0.11644192634527782</span><br><span class="line">-0.7106251396024126</span><br></pre></td></tr></table></figure>
<h4 id="其他相关方法概述"><a href="#其他相关方法概述" class="headerlink" title="其他相关方法概述"></a>其他相关方法概述</h4><ol>
<li><p><code>all()</code> / <code>any()</code>方法：判断数组是否所有元素都是<code>True</code> / 判断数组是否有为<code>True</code>的元素。</p>
</li>
<li><p><code>astype()</code>方法：拷贝数组，并将数组中的元素转换为指定的类型。</p>
</li>
<li><p><code>reshape()</code>方法：调整数组对象的形状。</p>
</li>
<li><p><code>dump()</code>方法：保存数组到二进制文件中，可以通过 NumPy 中的<code>load()</code>函数从保存的文件中加载数据创建数组。</p>
<p> 代码：</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.dump(<span class="string">&#x27;array1-data&#x27;</span>)</span><br><span class="line">array3 = np.load(<span class="string">&#x27;array1-data&#x27;</span>, allow_pickle=<span class="literal">True</span>)</span><br><span class="line">array3</span><br></pre></td></tr></table></figure>
<p> 输出：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([46, 51, 15, 42, 53, 71, 20, 62,  6, 94])</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>tofile()</code>方法：将数组对象写入文件中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array1.tofile(<span class="string">&#x27;res/array.txt&#x27;</span>, sep=<span class="string">&#x27;,&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>fill()</code>方法：向数组中填充指定的元素。</p>
</li>
<li><p><code>flatten()</code>方法：将多维数组扁平化为一维数组。</p>
<p> 代码：</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array2.flatten()</span><br></pre></td></tr></table></figure>
<p> 输出：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>nonzero()</code>方法：返回非0元素的索引。</p>
</li>
<li><p><code>round()</code>方法：对数组中的元素做四舍五入操作。</p>
</li>
<li><p><code>sort()</code>方法：对数组进行就地排序。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array1.sort()</span><br><span class="line">array1</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([ 6, 15, 20, 42, 46, 51, 53, 62, 71, 94])</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>swapaxes()</code>和<code>transpose()</code>方法：交换数组指定的轴和转置。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array2.swapaxes(<span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[1, 4, 7],</span><br><span class="line">       [2, 5, 8],</span><br><span class="line">       [3, 6, 9]])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array2.transpose()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[1, 4, 7],</span><br><span class="line">       [2, 5, 8],</span><br><span class="line">       [3, 6, 9]])</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>tolist()</code>方法：将数组转成 Python 中的<code>list</code>。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(array2.tolist())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(array2.tolist()))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span><br><span class="line">&lt;class &#x27;list&#x27;&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="NumPy的应用-3"><a href="#NumPy的应用-3" class="headerlink" title="NumPy的应用-3"></a>NumPy的应用-3</h2><h3 id="数组的运算"><a href="#数组的运算" class="headerlink" title="数组的运算"></a>数组的运算</h3><p>使用 NumPy 最为方便的是当需要对数组元素进行运算时，不用编写循环代码遍历每个元素，所有的运算都会自动的<strong>矢量化</strong>。简单的说就是，NumPy 中的数学运算和数学函数会自动作用于数组中的每个成员。</p>
<h4 id="数组跟标量的运算"><a href="#数组跟标量的运算" class="headerlink" title="数组跟标量的运算"></a>数组跟标量的运算</h4><p>NumPy 的数组可以跟一个数值进行加、减、乘、除、求模、求幂等运算，对应的运算会作用到数组的每一个元素上，如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array1 = np.arange(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(array1 + <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(array1 * <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[11 12 13 14 15 16 17 18 19]</span><br><span class="line">[10 20 30 40 50 60 70 80 90]</span><br></pre></td></tr></table></figure>
<p>除了上述的运算，关系运算也是没有问题的，之前讲布尔索引的时候已经遇到过了。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(array1 &gt; <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(array1 % <span class="number">2</span> == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[False False False False False  True  True  True  True]</span><br><span class="line">[False  True False  True False  True False  True False]</span><br></pre></td></tr></table></figure>
<h4 id="数组跟数组的运算"><a href="#数组跟数组的运算" class="headerlink" title="数组跟数组的运算"></a>数组跟数组的运算</h4><p>NumPy 的数组跟数组也可以执行算术运算和关系运算，运算会作用于两个数组对应的元素上，这就要求两个数组的形状（<code>shape</code>属性）要相同，如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array2 = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(array1 + array2)</span><br><span class="line"><span class="built_in">print</span>(array1 * array2)</span><br><span class="line"><span class="built_in">print</span>(array1 ** array2)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ 2  3  4  6  7  8 10 11 12]</span><br><span class="line">[ 1  2  3  8 10 12 21 24 27]</span><br><span class="line">[  1   2   3  16  25  36 343 512 729]</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(array1 &gt; array2)</span><br><span class="line"><span class="built_in">print</span>(array1 % array2 == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[False  True  True  True  True  True  True  True  True]</span><br><span class="line">[ True  True  True  True False  True False False  True]</span><br></pre></td></tr></table></figure>
<h4 id="通用一元函数"><a href="#通用一元函数" class="headerlink" title="通用一元函数"></a>通用一元函数</h4><p>NumPy 中通用一元函数的参数是一个数组对象，函数会对数组进行元素级的处理，例如：<code>sqrt</code>函数会对数组中的每个元素计算平方根，而<code>log2</code>函数会对数组中的每个元素计算以2为底的对数，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.sqrt(array1))</span><br><span class="line"><span class="built_in">print</span>(np.log2(array1))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1.         1.41421356 1.73205081 2.         2.23606798 2.44948974</span><br><span class="line"> 2.64575131 2.82842712 3.        ]</span><br><span class="line">[0.         1.         1.5849625  2.         2.32192809 2.5849625</span><br><span class="line"> 2.80735492 3.         3.169925  ]</span><br></pre></td></tr></table></figure>
<p><strong>表1：通用一元函数</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>abs</code> / <code>fabs</code></td>
<td>求绝对值的函数</td>
</tr>
<tr>
<td><code>sqrt</code></td>
<td>求平方根的函数，相当于<code>array ** 0.5</code></td>
</tr>
<tr>
<td><code>square</code></td>
<td>求平方的函数，相当于<code>array ** 2</code></td>
</tr>
<tr>
<td><code>exp</code></td>
<td>计算$e^x$的函数</td>
</tr>
<tr>
<td><code>log</code> / <code>log10</code> / <code>log2</code></td>
<td>对数函数（<code>e</code>为底 / <code>10</code>为底 / <code>2</code>为底）</td>
</tr>
<tr>
<td><code>sign</code></td>
<td>符号函数（<code>1</code> - 正数；<code>0</code> - 零；<code>-1</code> - 负数）</td>
</tr>
<tr>
<td><code>ceil</code> / <code>floor</code></td>
<td>上取整 /  下取整</td>
</tr>
<tr>
<td><code>isnan</code></td>
<td>返回布尔数组，NaN对应<code>True</code>，非NaN对应<code>False</code></td>
</tr>
<tr>
<td><code>isfinite</code> / <code>isinf</code></td>
<td>判断数值是否为无穷大的函数</td>
</tr>
<tr>
<td><code>cos</code> / <code>cosh</code> / <code>sin</code></td>
<td>三角函数</td>
</tr>
<tr>
<td><code>sinh</code> / <code>tan</code> / <code>tanh</code></td>
<td>三角函数</td>
</tr>
<tr>
<td><code>arccos</code> / <code>arccosh</code> / <code>arcsin</code></td>
<td>反三角函数</td>
</tr>
<tr>
<td><code>arcsinh</code> / <code>arctan</code> / <code>arctanh</code></td>
<td>反三角函数</td>
</tr>
<tr>
<td><code>rint</code> / <code>round</code></td>
<td>四舍五入函数</td>
</tr>
</tbody>
</table>
</div>
<h4 id="通用二元函数"><a href="#通用二元函数" class="headerlink" title="通用二元函数"></a>通用二元函数</h4><p>NumPy 中通用二元函数的参数是两个数组对象，函数会对两个数组中的对应元素进行运算，例如：<code>maximum</code>函数会对两个数组中对应的元素找最大值，而<code>power</code>函数会对两个数组中对应的元素进行求幂操作，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array3 = np.array([[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">array4 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span>(np.maximum(array3, array4))</span><br><span class="line"><span class="built_in">print</span>(np.power(array3, array4))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[4 5 6]</span><br><span class="line"> [7 8 9]]</span><br><span class="line">[[  4  25 216]</span><br><span class="line"> [343  64   9]]</span><br></pre></td></tr></table></figure>
<p><strong>表2：通用二元函数</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add(x, y)</code> / <code>substract(x, y)</code></td>
<td>加法函数 / 减法函数</td>
</tr>
<tr>
<td><code>multiply(x, y)</code> / <code>divide(x, y)</code></td>
<td>乘法函数 / 除法函数</td>
</tr>
<tr>
<td><code>floor_divide(x, y)</code> / <code>mod(x, y)</code></td>
<td>整除函数 / 求模函数</td>
</tr>
<tr>
<td><code>allclose(x, y)</code></td>
<td>检查数组<code>x</code>和<code>y</code>元素是否几乎相等</td>
</tr>
<tr>
<td><code>power(x, y)</code></td>
<td>数组$x$的元素$x_i$和数组$y$的元素$y_i$，计算$x_i^{y_i}$</td>
</tr>
<tr>
<td><code>maximum(x, y)</code> / <code>fmax(x, y)</code></td>
<td>两两比较元素获取最大值 / 获取最大值（忽略NaN）</td>
</tr>
<tr>
<td><code>minimum(x, y)</code> / <code>fmin(x, y)</code></td>
<td>两两比较元素获取最小值 / 获取最小值（忽略NaN）</td>
</tr>
<tr>
<td><code>dot(x, y)</code></td>
<td>点积运算（数量积，通常记为$\cdot$，用于欧几里得空间（Euclidean space））</td>
</tr>
<tr>
<td><code>inner(x, y)</code></td>
<td>内积运算（内积的含义要高于点积，点积相当于是内积在欧几里得空间$\mathbb{R}^n$的特例，而内积可以推广到赋范向量空间，只要它满足平行四边形法则即可）</td>
</tr>
<tr>
<td><code>cross(x, y)</code></td>
<td>叉积运算（向量积，通常记为$\times$，运算结果是一个向量）</td>
</tr>
<tr>
<td><code>outer(x, y)</code></td>
<td>外积运算（张量积，通常记为$\bigotimes$，运算结果通常是一个矩阵）</td>
</tr>
<tr>
<td><code>intersect1d(x, y)</code></td>
<td>计算<code>x</code>和<code>y</code>的交集，返回这些元素构成的有序数组</td>
</tr>
<tr>
<td><code>union1d(x, y)</code></td>
<td>计算<code>x</code>和<code>y</code>的并集，返回这些元素构成的有序数组</td>
</tr>
<tr>
<td><code>in1d(x, y)</code></td>
<td>返回由判断<code>x</code> 的元素是否在<code>y</code>中得到的布尔值构成的数组</td>
</tr>
<tr>
<td><code>setdiff1d(x, y)</code></td>
<td>计算<code>x</code>和<code>y</code>的差集，返回这些元素构成的数组</td>
</tr>
<tr>
<td><code>setxor1d(x, y)</code></td>
<td>计算<code>x</code>和<code>y</code>的对称差，返回这些元素构成的数组</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>说明</strong>：关于向量和矩阵的运算，我们在下一个章节加以说明。</p>
</blockquote>
<h4 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h4><p>上面数组运算的例子中，两个数组的形状（<code>shape</code>属性）是完全相同的，我们再来研究一下，两个形状不同的数组是否可以直接做二元运算或使用通用二元函数进行运算，请看下面的例子。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array5 = np.array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line">array6 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">array5 + array6</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array([[1, 2, 3],</span><br><span class="line">       [2, 3, 4],</span><br><span class="line">       [3, 4, 5],</span><br><span class="line">       [4, 5, 6]])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array7 = np.array([[<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>], [<span class="number">4</span>]])</span><br><span class="line">array5 + array7</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array([[1, 1, 1],</span><br><span class="line">       [3, 3, 3],</span><br><span class="line">       [5, 5, 5],</span><br><span class="line">       [7, 7, 7]])</span><br></pre></td></tr></table></figure>
<p>通过上面的例子，我们发现形状不同的数组仍然有机会进行二元运算，但这不代表任意形状的数组都可以进行二元运算。简单的说，只有两个数组后缘维度相同或者后缘维度不同但其中一个数组后缘维度为1时，广播机制才会被触发。通过广播机制，NumPy 将两个原本形状不相同的数组变成形状相同，才能进行二元运算。所谓后缘维度，指的是数组形状（<code>shape</code>属性）从后往前看对应的部分，我们举例说明。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/broadcast-1.png" style="zoom:100%;"></p>
<p>上图中，一个数组的形状是<code>(4, 3)</code>，另一个数组的形状是<code>(3, )</code>，从后往前看对应的部分都是<code>3</code>，属于后缘维度相同，可以应用广播机制，第二个数组会沿着缺失元素那个轴的方向去广播自己，最终让两个数组形状达成一致。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/broadcast-3.png" style="zoom:100%;"></p>
<p>上图中，一个数组的形状是<code>(3, 4, 2)</code>，另一个数组的形状是<code>(4, 2)</code>，从后往前看对应的部分都是<code>(4, 2)</code>，属于后缘维度相同，可以应用广播机制，第二个数组会沿着缺失元素那个轴的方向去广播自己，最终让两个数组形状达成一致。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/broadcast-2.png" style="zoom:100%;"></p>
<p>上图中，一个数组的形状是<code>(4, 3)</code>，另一个数组的形状是<code>(4, 1)</code>，这是后缘维度不相同的情况，但是第二个数组跟第一个数组不同的地方为<code>1</code>，第二个数组可以沿着为<code>1</code> 的那个轴广播自己，最终让两个数组形状达成一致。</p>
<blockquote>
<p><strong>思考</strong>：一个3行1列的二维数组和一个1行3列的二维数组能够执行加法运算吗？</p>
</blockquote>
<h3 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h3><p>除了上面讲到的函数外，NumPy 中还提供了很多用于处理数组的函数，<code>ndarray</code>对象的很多方法也可以通过调用函数来实现，下表给出了一些常用的函数。</p>
<p><strong>表3：NumPy其他常用函数</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>unique</code></td>
<td>去除数组重复元素，返回唯一元素构成的有序数组</td>
</tr>
<tr>
<td><code>copy</code></td>
<td>返回拷贝数组得到的数组</td>
</tr>
<tr>
<td><code>sort</code></td>
<td>返回数组元素排序后的拷贝</td>
</tr>
<tr>
<td><code>split</code> / <code>hsplit</code> / <code>vsplit</code></td>
<td>将数组拆成若干个子数组</td>
</tr>
<tr>
<td><code>stack</code> / <code>hstack</code> / <code>vstack</code></td>
<td>将多个数组堆叠成新数组</td>
</tr>
<tr>
<td><code>concatenate</code></td>
<td>沿着指定的轴连接多个数组构成新数组</td>
</tr>
<tr>
<td><code>append</code> / <code>insert</code></td>
<td>向数组末尾追加元素 / 在数组指定位置插入元素</td>
</tr>
<tr>
<td><code>argwhere</code></td>
<td>找出数组中非0元素的位置</td>
</tr>
<tr>
<td><code>extract</code> / <code>select</code> / <code>where</code></td>
<td>按照指定的条件从数组中抽取或处理数组元素</td>
</tr>
<tr>
<td><code>flip</code></td>
<td>沿指定的轴翻转数组中的元素</td>
</tr>
<tr>
<td><code>fromregex</code></td>
<td>通过读取文件和正则表达式解析获取数据创建数组对象</td>
</tr>
<tr>
<td><code>repeat</code> / <code>tile</code></td>
<td>通过对元素的重复来创建新数组</td>
</tr>
<tr>
<td><code>roll</code></td>
<td>沿指定轴对数组元素进行移位</td>
</tr>
<tr>
<td><code>resize</code></td>
<td>重新调整数组的大小</td>
</tr>
<tr>
<td><code>place</code> / <code>put</code></td>
<td>将数组中满足条件的元素/指定的元素替换为指定的值</td>
</tr>
<tr>
<td><code>partition</code></td>
<td>用选定的元素对数组进行一次划分并返回划分后的数组</td>
</tr>
</tbody>
</table>
</div>
<p><strong>去重（重复元素只保留一项）</strong>。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.unique(array5)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([0, 1, 2, 3])</span><br></pre></td></tr></table></figure>
<p><strong>堆叠和拼接</strong>。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array8 = np.array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line">array9 = np.array([[<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>]])</span><br><span class="line">np.hstack((array8, array9))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[1, 1, 1, 4, 4, 4],</span><br><span class="line">       [2, 2, 2, 5, 5, 5],</span><br><span class="line">       [3, 3, 3, 6, 6, 6]])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.vstack((array8, array9))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array([[1, 1, 1],</span><br><span class="line">       [2, 2, 2],</span><br><span class="line">       [3, 3, 3],</span><br><span class="line">       [4, 4, 4],</span><br><span class="line">       [5, 5, 5],</span><br><span class="line">       [6, 6, 6]])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.concatenate((array8, array9))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array([[1, 1, 1],</span><br><span class="line">       [2, 2, 2],</span><br><span class="line">       [3, 3, 3],</span><br><span class="line">       [4, 4, 4],</span><br><span class="line">       [5, 5, 5],</span><br><span class="line">       [6, 6, 6]])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.concatenate((array8, array9), axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[1, 1, 1, 4, 4, 4],</span><br><span class="line">       [2, 2, 2, 5, 5, 5],</span><br><span class="line">       [3, 3, 3, 6, 6, 6]])</span><br></pre></td></tr></table></figure>
<p><strong>追加和插入元素</strong>。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.append(array1, [<span class="number">10</span>, <span class="number">100</span>])</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([  1,   2,   3,   4,   5,   6,   7,   8,   9,  10, 100])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.insert(array1, <span class="number">1</span>, [<span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>])</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([  1,  98,  99, 100,   2,   3,   4,   5,   6,   7,   8,   9])</span><br></pre></td></tr></table></figure>
<p><strong>抽取和处理元素</strong>。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.extract(array1 % <span class="number">2</span> != <span class="number">0</span>, array1)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([1, 3, 5, 7, 9])</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：上面<code>extract</code>函数的操作相当于我们之前讲的布尔索引。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.select([array1 &lt;= <span class="number">3</span>, array1 &gt;= <span class="number">7</span>], [array1 * <span class="number">10</span>, array1 ** <span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([10, 20, 30,  0,  0,  0, 49, 64, 81])</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：上面<code>select</code>函数的第一个参数设置了两个条件，满足第一个条件的元素执行了乘以10的操作，满足第二个条件的元素执行了求平方的操作，两个条件都不能满足的数组元素会被处理为0。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.where(array1 &lt;= <span class="number">5</span>, array1 * <span class="number">10</span>, array1 ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([10, 20, 30, 40, 50, 36, 49, 64, 81])</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：上面<code>where</code>函数的第一个参数给出了条件，满足条件的元素执行了乘以10的操作，不能满足条件的元素执行了求平方的操作。</p>
</blockquote>
<p><strong>重复数组元素创建新数组</strong>。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.repeat(array1, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.tile(array1, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br></pre></td></tr></table></figure>
<p><strong>调整数组大小</strong>。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.resize(array1, (<span class="number">5</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([[1, 2, 3],</span><br><span class="line">       [4, 5, 6],</span><br><span class="line">       [7, 8, 9],</span><br><span class="line">       [1, 2, 3],</span><br><span class="line">       [4, 5, 6]])</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示</strong>：<code>array1</code>原本是一个有9个元素的一维数组，通过<code>resize</code>函数调整成为5行3列共15个元素的二维数组，缺少的元素通过复用原数组中的元素来补充。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.resize(array5, (<span class="number">2</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[0, 0, 0, 1],</span><br><span class="line">       [1, 1, 2, 2]])</span><br></pre></td></tr></table></figure>
<p><strong>替换数组元素</strong>。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.put(array1, [<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">100</span>, <span class="number">200</span>])</span><br><span class="line">array1</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([100, 200,   3, 200,   5, 100,   7,   8, 100])</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：上面<code>put</code>函的第二个参数给出了要被替换的元素的索引，但是用来作为替换值的元素只有<code>100</code>和<code>200</code>，所以这两个值会被循环使用，因此索引为<code>0</code>、<code>1</code>、<code>-1</code>、<code>3</code>、<code>5</code>的元素被依次替换成了<code>100</code>、<code>200</code>、<code>100</code>、<code>200</code>、<code>100</code>。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.place(array1, array1 &gt; <span class="number">5</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">array1</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([1, 2, 3, 3, 5, 1, 2, 3, 1])</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：<code>put</code>函数和<code>place</code>函数都没有返回新的数组对象，而是在原来的数组上直接进行替换。</p>
</blockquote>
<h2 id="NumPy的应用-4"><a href="#NumPy的应用-4" class="headerlink" title="NumPy的应用-4"></a>NumPy的应用-4</h2><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p><strong>向量</strong>（<em>vector</em>）也叫<strong>矢量</strong>，是一个同时具有大小和方向，且满足平行四边形法则的几何对象。与向量相对的概念叫<strong>标量</strong>或<strong>数量</strong>，标量只有大小，绝大多数情况下没有方向。我们通常用带箭头的线段来表示向量，在平面直角坐标系中的向量如下图所示。需要注意的是，向量是表达大小和方向的量，并没有规定起点和终点，所以相同的向量可以画在任意位置，例如下图中$\boldsymbol{w}$和$\boldsymbol{v}$两个向量并没有什么区别。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/vector_1.png" style="zoom:40%;"></p>
<p>向量有很多种代数表示法，对于二维空间的向量，下面几种写法都是可以的。</p>
<script type="math/tex; mode=display">
\boldsymbol{a} = \langle a_1, a_2 \rangle = (a_1, a_2) = \begin{pmatrix} a_1 \\ a_2 \end{pmatrix} = \begin{bmatrix} a_1 \\ a_2 \end{bmatrix}</script><p>向量的大小称为向量的模，它是一个标量，对于二维空间的向量，模可以通过下面的公式计算。</p>
<script type="math/tex; mode=display">
\lvert \boldsymbol{a} \rvert = \sqrt{a_{1}^{2} + a_{2}^{2}}</script><p>注意，这里的$\lvert \boldsymbol{a} \rvert$并不是绝对值，你可以将其称为向量$\boldsymbol{a}$的二范数，这是数学中的符号重用现象。上面的写法和概念也可以推广到$n$维空间，我们通常用$\boldsymbol{R^n}$表示$n$维空间，我们刚才说的二维空间可以记为$\boldsymbol{R^2}$，三维空间可以记为$\boldsymbol{R^3}$。虽然生活在三维空间的我们很难想象四维空间、五维空间是什么样子，但是这并不影响我们探讨高维空间，机器学习中，我们经常把有$n$个特征的训练样本称为一个$n$维向量。</p>
<h4 id="向量的加法"><a href="#向量的加法" class="headerlink" title="向量的加法"></a>向量的加法</h4><p>相同维度的向量可以相加得到一个新的向量，运算的方法是将向量的每个分量相加，如下所示。</p>
<script type="math/tex; mode=display">
\boldsymbol{u} = \begin{bmatrix} u_1 \\ u_2 \\ \vdots \\ u_n \end{bmatrix}, \quad
\boldsymbol{v} = \begin{bmatrix} v_1 \\ v_2 \\ \vdots \\ v_n \end{bmatrix}, \quad
\boldsymbol{u} + \boldsymbol{v} = \begin{bmatrix} u_1 + v_1 \\ u_2 + v_2 \\ \vdots \\ u_n + v_n \end{bmatrix}</script><p>向量的加法满足“平行四边形法则”，即两个向量$\boldsymbol{u}$和$\boldsymbol{v}$构成了平行四边形的两条邻边，相加的结果是平行四边形的对角线，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/vector_2.png" style="zoom:58%;"></p>
<h4 id="向量的数乘"><a href="#向量的数乘" class="headerlink" title="向量的数乘"></a>向量的数乘</h4><p>一个向量$\boldsymbol{v}$可以和一个标量$k$相乘，运算的方法是将向量中的每个分量与该标量相乘即可，如下所示。</p>
<script type="math/tex; mode=display">
\boldsymbol{v} = \begin{bmatrix} v_1 \\ v_2 \\ \vdots \\ v_n \end{bmatrix}, \quad
k \cdot \boldsymbol{v} = \begin{bmatrix} k \cdot v_1 \\ k \cdot v_2 \\ \vdots \\ k \cdot v_n \end{bmatrix}</script><p>我们可以用 NumPy 的数组来表示向量，向量的加法可以通过两个数组的加法来实现，向量的数乘可以通过数组和标量的乘法来实现，此处不再进行赘述。</p>
<h4 id="向量的点积"><a href="#向量的点积" class="headerlink" title="向量的点积"></a>向量的点积</h4><p>点积（<em>dot product</em>）是两个向量之间最为重要的运算之一，运算的方法是将两个向量对应分量的乘积求和，所以点积的结果是一个标量，其几何意义是两个向量的模乘以二者夹角的余弦如下所示。</p>
<script type="math/tex; mode=display">
\boldsymbol{u} = \begin{bmatrix} u_1 \\ u_2 \\ \vdots \\ u_n \end{bmatrix}, \quad
\boldsymbol{v} = \begin{bmatrix} v_1 \\ v_2 \\ \vdots \\ v_n \end{bmatrix} \quad \\
\boldsymbol{u} \cdot \boldsymbol{v} = \sum_{i=1}^{n}{u_iv_i} = \lvert \boldsymbol{u} \rvert \lvert \boldsymbol{v} \rvert cos\theta</script><p>假如我们用3维向量来表示用户对喜剧片、言情片和动作片这三类电影的偏好，我们用1到5的数字来表示喜欢的程度，其中5表示非常喜欢，4表示比较喜欢，3表示无感，2表示比较反感，1表示特别反感。那么，下面的向量表示用户非常喜欢喜剧片，特别反感言情片，对动作片不喜欢也不反感。</p>
<script type="math/tex; mode=display">
\boldsymbol{u} = \begin{pmatrix} 5 \\ 1 \\ 3 \end{pmatrix}</script><p>现在有两部电影上映了，一部属于言情喜剧片，一部属于喜剧动作片，我们把两部电影也通过3维向量的方式进行表示，如下所示。</p>
<script type="math/tex; mode=display">
\boldsymbol{m_1} = \begin{pmatrix} 4 \\ 5 \\ 1 \end{pmatrix}, \quad \boldsymbol{m_2} = \begin{pmatrix} 5 \\ 1 \\ 5 \end{pmatrix}</script><p>如果现在我们需要向刚才的用户推荐一部电影，我们应该给他推荐哪一部呢？我们可以将代表用户的向量$\boldsymbol{u}$和代表电影的向量$\boldsymbol{m_1}$和$\boldsymbol{m_2}$分别进行点积运算，再除以向量的模长，得到向量夹角的余弦值，余弦值越接近1，说明向量的夹角越接近0度，也就是两个向量的相似度越高。很显然，我们应该向用户推荐跟他观影喜好相似度更高的电影。</p>
<script type="math/tex; mode=display">
cos\theta_1 = \frac{\boldsymbol{u} \cdot \boldsymbol{m1}}{|\boldsymbol{u}||\boldsymbol{m1}|} \approx \frac{4 \times 5 + 5 \times 1 + 3 \times 1}{5.92 \times 6.48} \approx 0.73 \\
cos\theta_2 = \frac{\boldsymbol{u} \cdot \boldsymbol{m2}}{|\boldsymbol{u}||\boldsymbol{m2}|} \approx \frac{5 \times 5 + 1 \times 1 + 3 \times 5}{5.92 \times 7.14} \approx 0.97</script><p>大家可能会说，向量$\boldsymbol{m_2}$代表的电影肉眼可见跟用户是更加匹配的。的确，对于一个三维向量我们凭借直觉也能够给出正确的答案，但是对于一个$n$维向量，当$n$的值非常大时，你还有信心凭借肉眼的观察和本能的直觉给出准确的答案吗？向量的点积可以通过<code>dot</code>函数来计算，而向量的模长可以通过 NumPy 的<code>linalg</code>模块中的<code>norm</code>函数来计算，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u = np.array([<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">m1 = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>])</span><br><span class="line">m2 = np.array([<span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(np.dot(u, m1) / (np.linalg.norm(u) * np.linalg.norm(m1)))  <span class="comment"># 0.7302967433402214</span></span><br><span class="line"><span class="built_in">print</span>(np.dot(u, m2) / (np.linalg.norm(u) * np.linalg.norm(m2)))  <span class="comment"># 0.9704311900788593</span></span><br></pre></td></tr></table></figure>
<h4 id="向量的叉积"><a href="#向量的叉积" class="headerlink" title="向量的叉积"></a>向量的叉积</h4><p>在二维空间，两个向量的叉积是这样定义的：</p>
<script type="math/tex; mode=display">
\boldsymbol{A} = \begin{pmatrix} a_{1} \\ a_{2} \end{pmatrix}, \quad \boldsymbol{B} = \begin{pmatrix} b_{1} \\ b_{2} \end{pmatrix} \\
\boldsymbol{A} \times \boldsymbol{B} = \begin{vmatrix} a_{1} \quad a_{2} \\ b_{1} \quad b_{2} \end{vmatrix} = a_{1}b_{2} - a_{2}b_{1}</script><p>对于三维空间，两个向量的叉积结果是一个向量，如下所示：</p>
<script type="math/tex; mode=display">
\boldsymbol{A} = \begin{pmatrix} a_{1} \\ a_{2} \\ a_{3} \end{pmatrix}, \quad \boldsymbol{B} = \begin{pmatrix} b_{1} \\ b_{2} \\ b_{3} \end{pmatrix} \\
\boldsymbol{A} \times \boldsymbol{B} = \begin{vmatrix} \boldsymbol{\hat{i}} \quad \boldsymbol{\hat{j}} \quad \boldsymbol{\hat{k}} \\ a_{1} \quad a_{2} \quad a_{3} \\ b_{1} \quad b_{2} \quad b_{3} \end{vmatrix} = \langle \boldsymbol{\hat{i}}\begin{vmatrix} a_{2} \quad a_{3} \\ b_{2} \quad b_{3} \end{vmatrix}, -\boldsymbol{\hat{j}}\begin{vmatrix} a_{1} \quad a_{3} \\ b_{1} \quad b_{3} \end{vmatrix}, \boldsymbol{\hat{k}}\begin{vmatrix} a_{1} \quad a_{2} \\ b_{1} \quad b_{2} \end{vmatrix} \rangle</script><p>因为叉积的结果是向量，所以$\boldsymbol{A} \times \boldsymbol{B}$和$\boldsymbol{B} \times \boldsymbol{A}$的结果并不相同，事实上：</p>
<script type="math/tex; mode=display">
\boldsymbol{A} \times \boldsymbol{B} = -(\boldsymbol{B} \times \boldsymbol{A})</script><p>NumPy 中可以通过<code>cross</code>函数来计算向量的叉积，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.cross(u, m1))  <span class="comment"># [-14   7  21]</span></span><br><span class="line"><span class="built_in">print</span>(np.cross(m1, u))  <span class="comment"># [ 14  -7 -21]</span></span><br></pre></td></tr></table></figure>
<h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><p><strong>行列式</strong>（<em>determinant</em>）通常记作$det(\boldsymbol{A})$或$|\boldsymbol{A}|$，其中$\boldsymbol{A}$是一个$n$阶方阵。行列式可以看做是有向面积或体积的概念在一般欧几里得空间的推广，或者说行列式描述的是一个线性变换对“体积”所造成的影响。行列式的概念最早出现在解线性方程组的过程中，十七世纪晚期，关孝和（日本江户时代的数学家）与莱布尼茨的著作中已经使用行列式来确定线性方程组解的个数以及形式；十八世纪开始，行列式开始作为独立的数学概念被研究；十九世纪以后，行列式理论进一步得到发展和完善。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/Parallelogramme.jpeg" style="zoom:125%;"></p>
<h4 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h4><p>行列式是由向量引出的，所以行列式解释的其实是向量的性质。</p>
<p><strong>性质1</strong>：如果$det(\boldsymbol{A})$中某行（或某列）的元素全部为0，那么$det(\boldsymbol{A}) = 0$。</p>
<p><strong>性质2</strong>：如果$det(\boldsymbol{A})$中某行（或某列）有公共因子$k$，则可以提出$k$，得到行列式$det(\boldsymbol{A^{‘}})$，且$det(\boldsymbol{A}) = k \cdot det(\boldsymbol{A^{‘}})$。</p>
<script type="math/tex; mode=display">
det(\boldsymbol{A})={\begin{vmatrix}a_{11}&a_{12}&\dots &a_{1n}\\\vdots &\vdots &\ddots &\vdots \\{\color {blue}k}a_{i1}&{\color {blue}k}a_{i2}&\dots &{\color {blue}k}a_{in}\\\vdots &\vdots &\ddots &\vdots \\a_{n1}&a_{n2}&\dots &a_{nn}\end{vmatrix}}={\color {blue}k}{\begin{vmatrix}a_{11}&a_{12}&\dots &a_{1n}\\\vdots &\vdots &\ddots &\vdots \\a_{i1}&a_{i2}&\dots &a_{in}\\\vdots &\vdots &\ddots &\vdots \\a_{n1}&a_{n2}&\dots &a_{nn}\end{vmatrix}}={\color {blue}k} \cdot det(\boldsymbol{A^{'}})</script><p><strong>性质3</strong>：如果$det(\boldsymbol{A})$中某行（或某列）的每个元素是两数之和，则此行列式可拆分为两个行列式相加，如下所示。</p>
<script type="math/tex; mode=display">
{\begin{vmatrix}a_{11}&a_{12}&\dots &a_{1n}\\\vdots &\vdots &\ddots &\vdots \\{\color {blue}a_{i1}}+{\color {OliveGreen}b_{i1}}&{\color {blue}a_{i2}}+{\color {OliveGreen}b_{i2}}&\dots &{\color {blue}a_{in}}+{\color {OliveGreen}b_{in}}\\\vdots &\vdots &\ddots &\vdots \\a_{n1}&a_{n2}&\dots &a_{nn}\end{vmatrix}}={\begin{vmatrix}a_{11}&a_{12}&\dots &a_{1n}\\\vdots &\vdots &\ddots &\vdots \\{\color {blue}a_{i1}}&{\color {blue}a_{i2}}&\dots &{\color {blue}a_{in}}\\\vdots &\vdots &\ddots &\vdots \\a_{n1}&a_{n2}&\dots &a_{nn}\end{vmatrix}}+{\begin{vmatrix}a_{11}&a_{12}&\dots &a_{1n}\\\vdots &\vdots &\ddots &\vdots \\{\color {OliveGreen}b_{i1}}&{\color {OliveGreen}b_{i2}}&\dots &{\color {OliveGreen}b_{in}}\\\vdots &\vdots &\ddots &\vdots \\a_{n1}&a_{n2}&\dots &a_{nn}\end{vmatrix}}</script><p><strong>性质4</strong>：如果$det(\boldsymbol{A})$中两行（或两列）元素对应成比例，那么$det(\boldsymbol{A}) = 0$。</p>
<p><strong>性质5</strong>：如果$det(\boldsymbol{A})$中两行（或两列）互换得到$det(\boldsymbol{A^{‘}})$，那么$det(\boldsymbol{A}) = -det(\boldsymbol{A^{‘}})$。</p>
<p><strong>性质6</strong>：将$det(\boldsymbol{A})$中某行（或某列）的$k$倍加进另一行（或另一列）里，行列式的值不变，如下所示。</p>
<script type="math/tex; mode=display">
{\begin{vmatrix}\vdots &\vdots &\vdots &\vdots \\a_{i1}&a_{i2}&\dots &a_{in}\\a_{j1}&a_{j2}&\dots &a_{jn}\\\vdots &\vdots &\vdots &\vdots \\\end{vmatrix}}={\begin{vmatrix}\vdots &\vdots &\vdots &\vdots \\a_{i1}&a_{i2}&\dots &a_{in}\\a_{j1}{\color {blue}+ka_{i1}}&a_{j2}{\color {blue}+ka_{i2}}&\dots &a_{jn}{\color {blue}+ka_{in}}\\\vdots &\vdots &\vdots &\vdots \\\end{vmatrix}}</script><p><strong>性质7</strong>：将行列式的行列互换，行列式的值不变，如下所示。</p>
<script type="math/tex; mode=display">
{\begin{vmatrix}a_{11}&a_{12}&\dots &a_{1n}\\a_{21}&a_{22}&\dots &a_{2n}\\\vdots &\vdots &\ddots &\vdots \\a_{n1}&a_{n2}&\dots &a_{nn}\end{vmatrix}}={\begin{vmatrix}a_{11}&a_{21}&\dots &a_{n1}\\a_{12}&a_{22}&\dots &a_{n2}\\\vdots &\vdots &\ddots &\vdots \\a_{1n}&a_{2n}&\dots &a_{nn}\end{vmatrix}}</script><p><strong>性质8</strong>：方块矩阵$\boldsymbol{A}$和$\boldsymbol{B}$的乘积的行列式等于其行列式的乘积，即$det(\boldsymbol{A}\boldsymbol{B}) = det(\boldsymbol{A})det(\boldsymbol{B})$。特别的，若将矩阵中的每一行都乘以常数$r$，那么行列式的值将是原来的$r^{n}$倍，即$det(r\boldsymbol{A}) = det(r\boldsymbol{I<em>{n}} \cdot \boldsymbol{A}) = r^{n}det(\boldsymbol{A})$，其中$\boldsymbol{I</em>{n}}$是$n$阶单位矩阵。</p>
<p><strong>性质9</strong>：若$\boldsymbol{A}$是可逆矩阵，那么$det(\boldsymbol{A}^{-1}) = (det(\boldsymbol{A}))^{-1}$。</p>
<h4 id="行列式的计算"><a href="#行列式的计算" class="headerlink" title="行列式的计算"></a>行列式的计算</h4><p>$n$阶行列式的计算公式如下所示：</p>
<script type="math/tex; mode=display">
det(\boldsymbol{A})=\sum_{n!} \pm {a_{1\alpha}a_{2\beta} \cdots a_{n\omega}}</script><p>对于二阶行列式，上面的公式相当于：</p>
<script type="math/tex; mode=display">
\begin{vmatrix} a_{11} \quad a_{12} \\ a_{21} \quad a_{22} \end{vmatrix} = a_{11}a_{22} - a_{12}a_{21}</script><p>对于三阶行列式，上面的计算公式相当于：</p>
<script type="math/tex; mode=display">
\begin{vmatrix} a_{11} \quad a_{12} \quad a_{13} \\ a_{21} \quad a_{22} \quad a_{23} \\ a_{31} \quad a_{32} \quad a_{33} \end{vmatrix} = a_{11}a_{22}a_{33} + a_{12}a_{23}a_{31} + a_{13}a_{21}a_{32} - a_{11}a_{23}a_{32} - a_{12}a_{21}a_{33} - a_{13}a_{22}a_{31}</script><p>高阶行列式可以用<strong>代数余子式</strong>（<em>cofactor</em>）展开成多个低阶行列式，如下所示：</p>
<script type="math/tex; mode=display">
det(\boldsymbol{A})=a_{11}C_{11}+a_{12}C_{12}+ \cdots +a_{1n}C_{1n} = \sum_{i=1}^{n}{a_{1i}C_{1i}}</script><p>其中，$C<em>{11}$是原行列式去掉$a</em>{11}$所在行和列之后剩余的部分构成的行列式，以此类推。</p>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p><strong>矩阵</strong>（<em>matrix</em>）是由一系列元素排成的矩形阵列，矩阵里的元素可以是数字、符号或数学公式。矩阵可以进行<strong>加法</strong>、<strong>减法</strong>、<strong>数乘</strong>、<strong>转置</strong>、<strong>矩阵乘法</strong>等运算，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/matrix_operation.png" style="zoom:62%;"></p>
<p>值得一提的是矩阵乘法运算，该运算仅当第一个矩阵$\boldsymbol{A}$的列数和另一个矩阵$\boldsymbol{B}$的行数相等时才能定义。如果$\boldsymbol{A}$是一个$m \times n$的矩阵，$\boldsymbol{B}$是一个$n \times k$矩阵，它们的乘积是一个$m \times k$的矩阵，其中元素的计算公式如下所示：</p>
<script type="math/tex; mode=display">
 [\mathbf{AB}]_{i,j} = A_{i,1}B_{1,j} + A_{i,2}B_{2,j} + \cdots + A_{i,n}B_{n,j} = \sum_{r=1}^n A_{i,r}B_{r,j}</script><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/matrix_multiply.png" style="zoom:35%;"></p>
<p>例如：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
    1 & 0 & 2 \\
    -1 & 3 & 1 \\
  \end{bmatrix}
\times
  \begin{bmatrix}
    3 & 1 \\
    2 & 1 \\
    1 & 0
  \end{bmatrix}
=
  \begin{bmatrix}
     (1 \times 3  +  0 \times 2  +  2 \times 1) & (1 \times 1   +   0 \times 1   +   2 \times 0) \\
    (-1 \times 3  +  3 \times 2  +  1 \times 1) & (-1 \times 1   +   3 \times 1   +   1 \times 0) \\
  \end{bmatrix}
=
  \begin{bmatrix}
    5 & 1 \\
    4 & 2 \\
  \end{bmatrix}</script><p>矩阵的乘法满足结合律和对矩阵加法的分配律：</p>
<p>结合律： $(\boldsymbol{AB})\boldsymbol{C} = \boldsymbol{A}(\boldsymbol{BC})$。</p>
<p>左分配律：$(\boldsymbol{A} + \boldsymbol{B})\boldsymbol{C} = \boldsymbol{AC} + \boldsymbol{BC}$。</p>
<p>右分配律：$\boldsymbol{C}(\boldsymbol{A} + \boldsymbol{B}) = \boldsymbol{CA} + \boldsymbol{CB}$。</p>
<p><strong>矩阵乘法不满足交换律</strong>。一般情况下，矩阵$\boldsymbol{A}$和$\boldsymbol{B}$的乘积$\boldsymbol{AB}$存在，但$\boldsymbol{BA}$不一定存在，即便$\boldsymbol{BA}$存在，大多数时候$\boldsymbol{AB} \neq \boldsymbol{BA}$。</p>
<p>矩阵乘法的一个基本应用是在线性方程组上。线性方程组是方程组的一种，它符合以下的形式：</p>
<script type="math/tex; mode=display">
\begin{cases}
     a_{1,1}x_{1} + a_{1,2}x_{2} + \cdots + a_{1,n}x_{n}=  b_{1} \\
     a_{2,1}x_{1} + a_{2,2}x_{2} + \cdots + a_{2,n}x_{n}=  b_{2} \\
     \vdots \quad \quad \quad \vdots \\
     a_{m,1}x_{1} + a_{m,2}x_{2} + \cdots + a_{m,n}x_{n}=  b_{m}
 \end{cases}</script><p>运用矩阵的方式，可以将线性方程组写成一个向量方程：</p>
<script type="math/tex; mode=display">
\boldsymbol{Ax} = \boldsymbol{b}</script><p>其中，$\boldsymbol{A}$是由方程组里未知数的系数排成的$m \times n$矩阵，$\boldsymbol{x}$是含有$n$个元素的行向量，$\boldsymbol{b}$是含有$m$个元素的行向量。</p>
<p>矩阵是线性变换（保持向量加法和标量乘法的函数）的便利表达法。矩阵乘法的本质在联系到线性变换的时候最能体现，因为矩阵乘法和线性变换的合成有以下的联系，即每个$m \times n$的矩阵$\boldsymbol{A}$都代表了一个从$\boldsymbol{R}^{n}$射到$\boldsymbol{R}^{m}$的线性变换。如果无法理解上面这些内容，推荐大家看看B站上名为<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ib411t7YR/">《线性代数的本质》</a>的视频，相信这套视频会让你对线性代数有一个更好的认知。</p>
<p>下图是一个来自于维基百科的例子，图中展示了一些典型的二维实平面上的线性变换对平面向量（图形）造成的效果以及它们对应的二维矩阵，其中每个线性变换将蓝色图形映射成绿色图形；平面的原点$(0, 0)$用黑点表示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/linear_transformation.png" style="zoom:45%;"></p>
<h4 id="矩阵对象"><a href="#矩阵对象" class="headerlink" title="矩阵对象"></a>矩阵对象</h4><p>NumPy 中提供了专门用于线性代数（<em>linear algebra</em>）的模块和表示矩阵的类型<code>matrix</code>，当然我们通过二维数组也可以表示一个矩阵，官方并不推荐使用<code>matrix</code>类而是建议使用二维数组，而且有可能在将来的版本中会移除<code>matrix</code>类。无论如何，利用这些已经封装好的类和函数，我们可以轻松愉快的实现很多对矩阵的操作。</p>
<p>我们可以通过下面的代码来创建矩阵（<code>matrix</code>）对象。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m1 = np.matrix(<span class="string">&#x27;1 2 3; 4 5 6&#x27;</span>)</span><br><span class="line">m1</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：<code>matrix</code>构造器可以传入类数组对象也可以传入字符串来构造矩阵对象。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix([[1, 2, 3],</span><br><span class="line">        [4, 5, 6]])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m2 = np.asmatrix(np.array([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>]]))</span><br><span class="line">m2</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：<code>asmatrix</code>函数也可以用<code>mat</code>函数代替，这两个函数其实是同一个函数。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">matrix([[1, 1],</span><br><span class="line">        [2, 2],</span><br><span class="line">        [3, 3]])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m1 * m2</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix([[14, 14],</span><br><span class="line">        [32, 32]])</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：注意<code>matrix</code>对象和<code>ndarray</code>对象乘法运算的差别，<code>matrix</code>对象的<code>*</code>运算是矩阵乘法运算。如果两个二维数组要做矩阵乘法运算，应该使用<code>@</code>运算符或<code>matmul</code>函数，而不是<code>*</code>运算符。</p>
</blockquote>
<p>矩阵对象的属性如下表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>A</code></td>
<td>获取矩阵对象对应的<code>ndarray</code>对象</td>
</tr>
<tr>
<td><code>A1</code></td>
<td>获取矩阵对象对应的扁平化后的<code>ndarray</code>对象</td>
</tr>
<tr>
<td><code>I</code></td>
<td>可逆矩阵的逆矩阵</td>
</tr>
<tr>
<td><code>T</code></td>
<td>矩阵的转置</td>
</tr>
<tr>
<td><code>H</code></td>
<td>矩阵的共轭转置</td>
</tr>
<tr>
<td><code>shape</code></td>
<td>矩阵的形状</td>
</tr>
<tr>
<td><code>size</code></td>
<td>矩阵元素的个数</td>
</tr>
</tbody>
</table>
</div>
<p>矩阵对象的方法跟之前讲过的<code>ndarray</code>数组对象的方法基本差不多，此处不再进行赘述。</p>
<h4 id="线性代数模块"><a href="#线性代数模块" class="headerlink" title="线性代数模块"></a>线性代数模块</h4><p>NumPy 的<code>linalg</code>模块中有一组标准的矩阵分解运算以及诸如求逆和行列式之类的函数，它们跟 MATLAB 和 R 等语言所使用的是相同的行业标准线性代数库，下面的表格列出了<code>numpy</code>以及<code>linalg</code>模块中一些常用的线性代数相关函数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>diag</code></td>
<td>以一维数组的形式返回方阵的对角线元素或将一维数组转换为方阵（非对角元素元素为0）</td>
</tr>
<tr>
<td><code>matmul</code></td>
<td>矩阵乘法运算</td>
</tr>
<tr>
<td><code>trace</code></td>
<td>计算对角线元素的和</td>
</tr>
<tr>
<td><code>norm</code></td>
<td>求矩阵或向量的范数</td>
</tr>
<tr>
<td><code>det</code></td>
<td>计算行列式的值</td>
</tr>
<tr>
<td><code>matrix_rank</code></td>
<td>计算矩阵的秩</td>
</tr>
<tr>
<td><code>eig</code></td>
<td>计算矩阵的特征值（<em>eigenvalue</em>）和特征向量（<em>eigenvector</em>）</td>
</tr>
<tr>
<td><code>inv</code></td>
<td>计算非奇异矩阵（$n$阶方阵）的逆矩阵</td>
</tr>
<tr>
<td><code>pinv</code></td>
<td>计算矩阵的摩尔-彭若斯（<em>Moore-Penrose</em>）广义逆</td>
</tr>
<tr>
<td><code>qr</code></td>
<td>QR分解（把矩阵分解成一个正交矩阵与一个上三角矩阵的积）</td>
</tr>
<tr>
<td><code>svd</code></td>
<td>计算奇异值分解（<em>singular value decomposition</em>）</td>
</tr>
<tr>
<td><code>solve</code></td>
<td>解线性方程组$\boldsymbol{Ax}=\boldsymbol{b}$，其中$\boldsymbol{A}$是一个方阵</td>
</tr>
<tr>
<td><code>lstsq</code></td>
<td>计算$\boldsymbol{Ax}=\boldsymbol{b}$的最小二乘解</td>
</tr>
</tbody>
</table>
</div>
<p>下面我们简单尝试一下上面的函数，先试一试求逆矩阵。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m3 = np.array([[<span class="number">1.</span>, <span class="number">2.</span>], [<span class="number">3.</span>, <span class="number">4.</span>]])</span><br><span class="line">m4 = np.linalg.inv(m3)</span><br><span class="line">m4</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[-2. ,  1. ],</span><br><span class="line">       [ 1.5, -0.5]])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.around(m3 @ m4)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：<code>around</code>函数对数组元素进行四舍五入操作，默认小数点后面的位数为0。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[1., 0.],</span><br><span class="line">       [0., 1.]])</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：矩阵和它的逆矩阵做矩阵乘法会得到单位矩阵。</p>
</blockquote>
<p>计算行列式的值。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m5 = np.array([[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>], [<span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>]])</span><br><span class="line">np.linalg.det(m5)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<p>计算矩阵的秩。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.linalg.matrix_rank(m5)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<p>求解线性方程组。</p>
<script type="math/tex; mode=display">
\begin{cases}
x_1 + 2x_2 + x_3 = 8 \\
3x_1 + 7x_2 + 2x_3 = 23 \\
2x_1 + 2x_2 + x_3 = 9
\end{cases}</script><p>对于上面的线性方程组，我们可以用矩阵的形式来表示它，如下所示。</p>
<script type="math/tex; mode=display">
\boldsymbol{A} = \begin{bmatrix}
1 & 2 & 1\\
3 & 7 & 2\\
2 & 2 & 1
\end{bmatrix}, \quad
\boldsymbol{x} = \begin{bmatrix}
x_1 \\
x_2\\
x_3
\end{bmatrix}, \quad
\boldsymbol{b} = \begin{bmatrix}
8 \\
23\\
9
\end{bmatrix}</script><script type="math/tex; mode=display">
\boldsymbol{Ax} = \boldsymbol{b}</script><p>线性方程组有唯一解的条件：系数矩阵$\boldsymbol{A}$的秩等于增广矩阵$\boldsymbol{Ab}$的秩，而且跟未知数的个数相同。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">b = np.array([<span class="number">8</span>, <span class="number">23</span>, <span class="number">9</span>]).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(np.linalg.matrix_rank(A))</span><br><span class="line"><span class="built_in">print</span>(np.linalg.matrix_rank(np.hstack((A, b))))</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：使用数组对象的<code>reshape</code>方法调形时，如果其中一个参数为-1，那么该维度有多少个元素是通过数组元素个数（<code>size</code>属性）和其他维度的元素个数自动计算出来的。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.linalg.solve(A, b)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[1.],</span><br><span class="line">       [2.],</span><br><span class="line">       [3.]])</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：上面的结果表示，线性方程组的解为：$x_1 = 1, x_2 = 2, x_3 = 3$。</p>
</blockquote>
<p>下面是另一种求解线性方程组的方法，大家可以停下来思考下为什么。</p>
<script type="math/tex; mode=display">
\boldsymbol{x} = \boldsymbol{A}^{-1} \cdot \boldsymbol{b}</script><p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.linalg.inv(A) @ b</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[1.],</span><br><span class="line">       [2.],</span><br><span class="line">       [3.]])</span><br></pre></td></tr></table></figure>
<h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><p>除了数组，NumPy 中还封装了用于<strong>多项式</strong>（<em>polynomial</em>）运算的数据类型。多项式是变量的整数次幂与系数的乘积之和，形如：</p>
<script type="math/tex; mode=display">
f(x)=a_nx^n + a_{n-1}x^{n-1} + \cdots + a_1x^{1} + a_0x^{0}</script><p>在 NumPy 1.4版本之前，我们可以用<code>poly1d</code>类型来表示多项式，目前它仍然可用，但是官方提供了新的模块<code>numpy.polynomial</code>，它除了支持基本的幂级数多项式外，还可以支持切比雪夫多项式、拉盖尔多项式等。</p>
<h4 id="创建多项式对象"><a href="#创建多项式对象" class="headerlink" title="创建多项式对象"></a>创建多项式对象</h4><p>创建<code>poly1d</code>对象，例如：$\small{f(x)=3x^{2}+2x+1}$。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p1 = np.poly1d([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line">p2 = np.poly1d([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(p1)</span><br><span class="line"><span class="built_in">print</span>(p2)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   2</span><br><span class="line">3 x + 2 x + 1</span><br><span class="line">   2</span><br><span class="line">1 x + 2 x + 3</span><br></pre></td></tr></table></figure>
<h4 id="多项式的操作"><a href="#多项式的操作" class="headerlink" title="多项式的操作"></a>多项式的操作</h4><p><strong>获取多项式的系数</strong></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(p1.coefficients)</span><br><span class="line"><span class="built_in">print</span>(p2.coeffs)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[3 2 1]</span><br><span class="line">[1 2 3]</span><br></pre></td></tr></table></figure>
<p><strong>两个多项式的四则运算</strong></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(p1 + p2)</span><br><span class="line"><span class="built_in">print</span>(p1 * p2)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   2</span><br><span class="line">4 x + 4 x + 4</span><br><span class="line">   4     3      2</span><br><span class="line">3 x + 8 x + 14 x + 8 x + 3</span><br></pre></td></tr></table></figure>
<p><strong>带入$\small{x}$求多项式的值</strong></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(p1(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(p2(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">34</span><br><span class="line">18</span><br></pre></td></tr></table></figure>
<p><strong>多项式求导和不定积分</strong></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(p1.deriv())</span><br><span class="line"><span class="built_in">print</span>(p1.integ())</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6 x + 2</span><br><span class="line">   3     2</span><br><span class="line">1 x + 1 x + 1 x</span><br></pre></td></tr></table></figure>
<p><strong>求多项式的根</strong></p>
<p>例如有多项式$\small{f(x)=x^2+3x+2}$，多项式的根即一元二次方程$\small{x^2+3x+2=0}$的解。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p3 = np.poly1d([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(p3.roots)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-2. -1.]</span><br></pre></td></tr></table></figure>
<p>如果使用<code>numpy.polynomial</code>模块的<code>Polynomial</code>类来表示多项式对象，那么对应的操作如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.polynomial <span class="keyword">import</span> Polynomial</span><br><span class="line"></span><br><span class="line">p3 = Polynomial((<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(p3)           <span class="comment"># 输出多项式</span></span><br><span class="line"><span class="built_in">print</span>(p3(<span class="number">3</span>))        <span class="comment"># 令x=3，计算多项式的值</span></span><br><span class="line"><span class="built_in">print</span>(p3.roots())   <span class="comment"># 计算多项式的根</span></span><br><span class="line"><span class="built_in">print</span>(p3.degree())  <span class="comment"># 获得多项式的次数</span></span><br><span class="line"><span class="built_in">print</span>(p3.deriv())   <span class="comment"># 求导</span></span><br><span class="line"><span class="built_in">print</span>(p3.integ())   <span class="comment"># 求不定积分</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2.0 + 3.0·x + 1.0·x²</span><br><span class="line">20.0</span><br><span class="line">[-2. -1.]</span><br><span class="line">2</span><br><span class="line">3.0 + 2.0·x</span><br><span class="line">0.0 + 2.0·x + 1.5·x² + 0.33333333·x³</span><br></pre></td></tr></table></figure>
<h4 id="最小二乘解"><a href="#最小二乘解" class="headerlink" title="最小二乘解"></a>最小二乘解</h4><p><code>Polynomial</code>类还有一个名为<code>fit</code>的类方法，它可以给多项式求最小二乘解。所谓最小二乘解（least-squares solution），是用最小二乘法通过最小化误差的平方和来寻找数据的最佳匹配函数的系数。假设多项式为$\small{f(x)=ax+b}$，最小二乘解就是让下面的残差平方和$\small{RSS}$达到最小的$\small{a}$和$\small{b}$。</p>
<script type="math/tex; mode=display">
RSS = \sum_{i=0}^{k}(f(x_i) - y_i)^{2}</script><p>例如，我们想利用收集到的月收入和网购支出的历史数据来建立一个预测模型，以达到通过某人的月收入预测他网购支出金额的目标，下面是我们收集到的收入和网购支出的数据，保存在两个数组中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([</span><br><span class="line">    <span class="number">25000</span>, <span class="number">15850</span>, <span class="number">15500</span>, <span class="number">20500</span>, <span class="number">22000</span>, <span class="number">20010</span>, <span class="number">26050</span>, <span class="number">12500</span>, <span class="number">18500</span>, <span class="number">27300</span>,</span><br><span class="line">    <span class="number">15000</span>,  <span class="number">8300</span>, <span class="number">23320</span>,  <span class="number">5250</span>,  <span class="number">5800</span>,  <span class="number">9100</span>,  <span class="number">4800</span>, <span class="number">16000</span>, <span class="number">28500</span>, <span class="number">32000</span>,</span><br><span class="line">    <span class="number">31300</span>, <span class="number">10800</span>,  <span class="number">6750</span>,  <span class="number">6020</span>, <span class="number">13300</span>, <span class="number">30020</span>,  <span class="number">3200</span>, <span class="number">17300</span>,  <span class="number">8835</span>,  <span class="number">3500</span></span><br><span class="line">])</span><br><span class="line">y = np.array([</span><br><span class="line">    <span class="number">2599</span>, <span class="number">1400</span>, <span class="number">1120</span>, <span class="number">2560</span>, <span class="number">1900</span>, <span class="number">1200</span>, <span class="number">2320</span>,  <span class="number">800</span>, <span class="number">1650</span>, <span class="number">2200</span>,</span><br><span class="line">     <span class="number">980</span>,  <span class="number">580</span>, <span class="number">1885</span>,  <span class="number">600</span>,  <span class="number">400</span>,  <span class="number">800</span>,  <span class="number">420</span>, <span class="number">1380</span>, <span class="number">1980</span>, <span class="number">3999</span>,</span><br><span class="line">    <span class="number">3800</span>,  <span class="number">725</span>,  <span class="number">520</span>,  <span class="number">420</span>, <span class="number">1200</span>, <span class="number">4020</span>,  <span class="number">350</span>, <span class="number">1500</span>,  <span class="number">560</span>,  <span class="number">500</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>我们可以先绘制散点图来了解两组数据是否具有正相关或负相关关系。正相关意味着数组<code>x</code>中较大的值对应到数组<code>y</code>中也是较大的值，而负相关则意味着数组<code>x</code>中较大的值对应到数组<code>y</code>中较小的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure(dpi=<span class="number">120</span>)</span><br><span class="line">plt.scatter(x, y, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/in_out_scatter_plot.png" style="zoom:50%;"></p>
<p>如果需要定量的研究两组数据的相关性，我们可以计算协方差或相关系数，对应的 NumPy 函数分别是<code>cov</code>和<code>corrcoef</code>。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.corrcoef(x, y)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[1.        , 0.92275889],</span><br><span class="line">       [0.92275889, 1.        ]])</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：相关系数是一个<code>-1</code>到<code>1</code>之间的值，越靠近<code>1</code> 说明正相关性越强，越靠近<code>-1</code>说明负相关性越强，靠近<code>0</code>则说明两组数据没有明显的相关性。上面月收入和网购支出之间的相关系数是<code>0.92275889</code>，说明二者是强正相关关系。</p>
</blockquote>
<p>通过上面的操作，我们确定了收入和网购支出之前存在强正相关关系，于是我们用这些数据来创建一个回归模型，找出一条能够很好的拟合这些数据点的直线。这里，我们就可以用到上面提到的<code>fit</code>方法，具体的代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.polynomial <span class="keyword">import</span> Polynomial</span><br><span class="line"></span><br><span class="line">Polynomial.fit(x, y, deg=<span class="number">1</span>).convert().coef</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：<code>deg=1</code>说明回归模型最高次项就是1次项，回归模型形如$\small{y=ax+b}$；如果要生一个类似于$\small{y=ax^2+bx+c}$的模型，就需要设置<code>deg=2</code>，以此类推。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([-2.94883437e+02,  1.10333716e-01])</span><br></pre></td></tr></table></figure>
<p>根据上面输出的结果，我们的回归方程应该是$\small{y=0.110333716x-294.883437}$。我们将这个回归方程绘制到刚才的散点图上，红色的点是我们的预测值，蓝色的点是历史数据，也就是真实值。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.scatter(x, y, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.scatter(x, <span class="number">0.110333716</span> * x - <span class="number">294.883437</span>, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">plt.plot(x, <span class="number">0.110333716</span> * x - <span class="number">294.883437</span>, color=<span class="string">&#x27;darkcyan&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/in_out_regression_result.png" style="zoom:50%;"></p>
<p>如果不使用<code>Polynomial</code>类型的<code>fit</code>方法，我们也可以通过 NumPy 提供的<code>polyfit</code>函数来完成同样的操作，有兴趣的读者可以自行研究。</p>
<h2 id="深入浅出pandas-1"><a href="#深入浅出pandas-1" class="headerlink" title="深入浅出pandas-1"></a>深入浅出pandas-1</h2><p>Pandas 是 Wes McKinney 在2008年开发的一个强大的<strong>分析结构化数据</strong>的工具集。Pandas 以 NumPy 为基础（实现数据存储和运算），提供了专门用于数据分析的类型、方法和函数，对数据分析和数据挖掘提供了很好的支持；同时 pandas 还可以跟数据可视化工具 matplotlib 很好的整合在一起，非常轻松愉快的实现数据可视化呈现。</p>
<p>Pandas 核心的数据类型是<code>Series</code>（数据系列）、<code>DataFrame</code>（数据窗/数据框），分别用于处理一维和二维的数据，除此之外，还有一个名为<code>Index</code>的类型及其子类型，它们为<code>Series</code>和<code>DataFrame</code>提供了索引功能。日常工作中<code>DataFrame</code>使用得最为广泛，因为二维的数据结构刚好可以对应有行有列的表格。<code>Series</code>和<code>DataFrame</code>都提供了大量的处理数据的方法，数据分析师以此为基础，可以实现对数据的筛选、合并、拼接、清洗、预处理、聚合、透视和可视化等各种操作。</p>
<h3 id="创建Series对象"><a href="#创建Series对象" class="headerlink" title="创建Series对象"></a>创建Series对象</h3><p>Pandas 库中的<code>Series</code>对象可以用来表示一维数据结构，但是多了索引和一些额外的功能。<code>Series</code>类型的内部结构包含了两个数组，其中一个用来保存数据，另一个用来保存数据的索引。我们可以通过列表或数组创建<code>Series</code>对象，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">ser1 = pd.Series(data=[<span class="number">120</span>, <span class="number">380</span>, <span class="number">250</span>, <span class="number">360</span>], index=[<span class="string">&#x27;一季度&#x27;</span>, <span class="string">&#x27;二季度&#x27;</span>, <span class="string">&#x27;三季度&#x27;</span>, <span class="string">&#x27;四季度&#x27;</span>])</span><br><span class="line">ser1</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：<code>Series</code>构造器中的<code>data</code>参数表示数据，<code>index</code>参数表示数据的索引，相当于数据对应的标签。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一季度    120</span><br><span class="line">二季度    380</span><br><span class="line">三季度    250</span><br><span class="line">四季度    360</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>通过字典创建Series对象。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ser2 = pd.Series(&#123;<span class="string">&#x27;一季度&#x27;</span>: <span class="number">320</span>, <span class="string">&#x27;二季度&#x27;</span>: <span class="number">180</span>, <span class="string">&#x27;三季度&#x27;</span>: <span class="number">300</span>, <span class="string">&#x27;四季度&#x27;</span>: <span class="number">405</span>&#125;)</span><br><span class="line">ser2</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：通过字典创建<code>Series</code>对象时，字典的键就是数据的标签（索引），键对应的值就是数据。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一季度    320</span><br><span class="line">二季度    180</span><br><span class="line">三季度    300</span><br><span class="line">四季度    405</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h3 id="Series对象的运算"><a href="#Series对象的运算" class="headerlink" title="Series对象的运算"></a>Series对象的运算</h3><h4 id="标量运算"><a href="#标量运算" class="headerlink" title="标量运算"></a>标量运算</h4><p>我们尝试给刚才的<code>ser1</code>每个季度加上<code>10</code>，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ser1 += <span class="number">10</span></span><br><span class="line">ser1</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一季度    130</span><br><span class="line">二季度    390</span><br><span class="line">三季度    260</span><br><span class="line">四季度    370</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h4 id="矢量运算"><a href="#矢量运算" class="headerlink" title="矢量运算"></a>矢量运算</h4><p>我们尝试把<code>ser1</code>和<code>ser2</code>对应季度的数据加起来，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser1 + ser2</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一季度    450</span><br><span class="line">二季度    570</span><br><span class="line">三季度    560</span><br><span class="line">四季度    775</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h4 id="索引运算"><a href="#索引运算" class="headerlink" title="索引运算"></a>索引运算</h4><h5 id="普通索引-1"><a href="#普通索引-1" class="headerlink" title="普通索引"></a>普通索引</h5><p>跟数组一样，<code>Series</code>对象也可以进行索引和切片操作，不同的是<code>Series</code>对象因为内部维护了一个保存索引的数组，所以除了可以使用整数索引检索数据外，还可以通过自己设置的索引（标签）获取对应的数据。</p>
<p>使用整数索引。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser1[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">260</span><br></pre></td></tr></table></figure>
<p>使用自定义索引。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser1[<span class="string">&#x27;三季度&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">260</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ser1[<span class="string">&#x27;一季度&#x27;</span>] = <span class="number">380</span></span><br><span class="line">ser1</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一季度    380</span><br><span class="line">二季度    390</span><br><span class="line">三季度    260</span><br><span class="line">四季度    370</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h5 id="切片索引-1"><a href="#切片索引-1" class="headerlink" title="切片索引"></a>切片索引</h5><p><code>Series</code>对象的切片操作跟列表、数组类似，通过给出起始和结束索引，从原来的<code>Series</code>对象中取出或修改部分数据，这里也可以使用整数索引和自定义的索引，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser2[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">二季度    180</span><br><span class="line">三季度    300</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser2[<span class="string">&#x27;二季度&#x27;</span>:<span class="string">&#x27;四季度&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">二季度    180</span><br><span class="line">三季度    300</span><br><span class="line">四季度    405</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示</strong>：在使用自定义索引进行切片时，结束索引对应的元素也是可以取到的。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ser2[<span class="number">1</span>:<span class="number">3</span>] = <span class="number">400</span>, <span class="number">500</span></span><br><span class="line">ser2</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一季度    320</span><br><span class="line">二季度    400</span><br><span class="line">三季度    500</span><br><span class="line">四季度    405</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h5 id="花式索引-1"><a href="#花式索引-1" class="headerlink" title="花式索引"></a>花式索引</h5><p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser2[[<span class="string">&#x27;二季度&#x27;</span>, <span class="string">&#x27;四季度&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">二季度    400</span><br><span class="line">四季度    405</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ser2[[<span class="string">&#x27;二季度&#x27;</span>, <span class="string">&#x27;四季度&#x27;</span>]] = <span class="number">600</span>, <span class="number">520</span></span><br><span class="line">ser2</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一季度    320</span><br><span class="line">二季度    600</span><br><span class="line">三季度    500</span><br><span class="line">四季度    520</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h5 id="布尔索引-1"><a href="#布尔索引-1" class="headerlink" title="布尔索引"></a>布尔索引</h5><p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser2[ser2 &gt;= <span class="number">500</span>]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">二季度    600</span><br><span class="line">三季度    500</span><br><span class="line">四季度    520</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h3 id="Series对象的属性和方法"><a href="#Series对象的属性和方法" class="headerlink" title="Series对象的属性和方法"></a>Series对象的属性和方法</h3><p><code>Series</code>对象的属性和方法非常多，我们就捡着重要的跟大家讲吧。先看看下面的表格，它展示了<code>Series</code>对象常用的属性。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dtype</code> / <code>dtypes</code></td>
<td>返回<code>Series</code>对象的数据类型</td>
</tr>
<tr>
<td><code>hasnans</code></td>
<td>判断<code>Series</code>对象中有没有空值</td>
</tr>
<tr>
<td><code>at</code> / <code>iat</code></td>
<td>通过索引访问<code>Series</code>对象中的单个值</td>
</tr>
<tr>
<td><code>loc</code> / <code>iloc</code></td>
<td>通过索引访问<code>Series</code>对象中的单个值或一组值</td>
</tr>
<tr>
<td><code>index</code></td>
<td>返回<code>Series</code>对象的索引（<code>Index</code>对象）</td>
</tr>
<tr>
<td><code>is_monotonic</code></td>
<td>判断<code>Series</code>对象中的数据是否单调</td>
</tr>
<tr>
<td><code>is_monotonic_increasing</code></td>
<td>判断<code>Series</code>对象中的数据是否单调递增</td>
</tr>
<tr>
<td><code>is_monotonic_decreasing</code></td>
<td>判断<code>Series</code>对象中的数据是否单调递减</td>
</tr>
<tr>
<td><code>is_unique</code></td>
<td>判断<code>Series</code>对象中的数据是否独一无二</td>
</tr>
<tr>
<td><code>size</code></td>
<td>返回<code>Series</code>对象中元素的个数</td>
</tr>
<tr>
<td><code>values</code></td>
<td>以<code>ndarray</code>的方式返回<code>Series</code>对象中的值（<code>ndarray</code>对象）</td>
</tr>
</tbody>
</table>
</div>
<p>我们可以通过下面的代码来了解<code>Series</code>对象的属性。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(ser2.dtype)                    <span class="comment"># 数据类型</span></span><br><span class="line"><span class="built_in">print</span>(ser2.hasnans)                  <span class="comment"># 有没有空值</span></span><br><span class="line"><span class="built_in">print</span>(ser2.index)                    <span class="comment"># 索引</span></span><br><span class="line"><span class="built_in">print</span>(ser2.values)                   <span class="comment"># 值</span></span><br><span class="line"><span class="built_in">print</span>(ser2.is_monotonic_increasing)  <span class="comment"># 是否单调递增</span></span><br><span class="line"><span class="built_in">print</span>(ser2.is_unique)                <span class="comment"># 是否每个值都独一无二</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int64</span><br><span class="line">False</span><br><span class="line">Index([&#x27;一季度&#x27;, &#x27;二季度&#x27;, &#x27;三季度&#x27;, &#x27;四季度&#x27;], dtype=&#x27;object&#x27;)</span><br><span class="line">[320 600 500 520]</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p><code>Series</code>对象的方法很多，下面我们通过一些代码片段为大家介绍常用的方法。</p>
<h4 id="统计相关"><a href="#统计相关" class="headerlink" title="统计相关"></a>统计相关</h4><p><code>Series</code>对象支持各种获取描述性统计信息的方法。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(ser2.count())   <span class="comment"># 计数</span></span><br><span class="line"><span class="built_in">print</span>(ser2.<span class="built_in">sum</span>())     <span class="comment"># 求和</span></span><br><span class="line"><span class="built_in">print</span>(ser2.mean())    <span class="comment"># 求平均</span></span><br><span class="line"><span class="built_in">print</span>(ser2.median())  <span class="comment"># 找中位数</span></span><br><span class="line"><span class="built_in">print</span>(ser2.<span class="built_in">max</span>())     <span class="comment"># 找最大</span></span><br><span class="line"><span class="built_in">print</span>(ser2.<span class="built_in">min</span>())     <span class="comment"># 找最小</span></span><br><span class="line"><span class="built_in">print</span>(ser2.std())     <span class="comment"># 求标准差</span></span><br><span class="line"><span class="built_in">print</span>(ser2.var())     <span class="comment"># 求方差</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1940</span><br><span class="line">485.0</span><br><span class="line">510.0</span><br><span class="line">600</span><br><span class="line">320</span><br><span class="line">118.18065267490557</span><br><span class="line">13966.666666666666</span><br></pre></td></tr></table></figure>
<p><code>Series</code>对象还有一个名为<code>describe()</code>的方法，可以获得上述所有的描述性统计信息，如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser2.describe()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">count      4.000000</span><br><span class="line">mean     485.000000</span><br><span class="line">std      118.180653</span><br><span class="line">min      320.000000</span><br><span class="line">25%      455.000000</span><br><span class="line">50%      510.000000</span><br><span class="line">75%      540.000000</span><br><span class="line">max      600.000000</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示</strong>：因为<code>describe()</code>返回的也是一个<code>Series</code>对象，所以也可以用<code>ser2.describe()[&#39;mean&#39;]</code>来获取平均值，用<code>ser2.describe()[[&#39;max&#39;, &#39;min&#39;]]</code>来获取最大值和最小值。</p>
</blockquote>
<p>如果<code>Series</code>对象有重复的值，我们可以使用<code>unique()</code>方法获得由独一无二的值构成的数组；可以使用<code>nunique()</code>方法统计不重复值的数量；如果想要统计每个值重复的次数，可以使用<code>value_counts()</code>方法，这个方法会返回一个<code>Series</code>对象，它的索引就是原来的<code>Series</code>对象中的值，而每个值出现的次数就是返回的<code>Series</code>对象中的数据，在默认情况下会按照出现次数做降序排列，如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ser3 = pd.Series(data=[<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pitaya&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pitaya&#x27;</span>, <span class="string">&#x27;durian&#x27;</span>])</span><br><span class="line">ser3.value_counts()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apple     3</span><br><span class="line">pitaya    2</span><br><span class="line">durian    1</span><br><span class="line">banana    1</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser3.nunique()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p>对于<code>ser3</code>，我们还可以用<code>mode()</code>方法来找出数据的众数，由于众数可能不唯一，所以<code>mode()</code>方法的返回值仍然是一个<code>Series</code>对象。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser3.mode()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0    apple</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
<h4 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h4><p><code>Series</code>对象的<code>isna()</code>和<code>isnull()</code>方法可以用于空值的判断，<code>notna()</code>和<code>notnull()</code>方法可以用于非空值的判断，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ser4 = pd.Series(data=[<span class="number">10</span>, <span class="number">20</span>, np.nan, <span class="number">30</span>, np.nan])</span><br><span class="line">ser4.isna()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：<code>np.nan</code>是一个IEEE 754标准的浮点小数，专门用来表示“不是一个数”，在上面的代码中我们用它来代表空值；当然，也可以用 Python 中的<code>None</code>来表示空值，在 pandas 中<code>None</code>也会被处理为<code>np.nan</code>。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0    False</span><br><span class="line">1    False</span><br><span class="line">2     True</span><br><span class="line">3    False</span><br><span class="line">4     True</span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser4.notna()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0     True</span><br><span class="line">1     True</span><br><span class="line">2    False</span><br><span class="line">3     True</span><br><span class="line">4    False</span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure>
<p><code>Series</code>对象的<code>dropna()</code>和<code>fillna()</code>方法分别用来删除空值和填充空值，具体的用法如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser4.dropna()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0    10.0</span><br><span class="line">1    20.0</span><br><span class="line">3    30.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser4.fillna(value=<span class="number">40</span>)  <span class="comment"># 将空值填充为40</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0    10.0</span><br><span class="line">1    20.0</span><br><span class="line">2    40.0</span><br><span class="line">3    30.0</span><br><span class="line">4    40.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser4.fillna(method=<span class="string">&#x27;ffill&#x27;</span>)  <span class="comment"># 用空值前面的非空值填充</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0    10.0</span><br><span class="line">1    20.0</span><br><span class="line">2    20.0</span><br><span class="line">3    30.0</span><br><span class="line">4    30.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>需要提醒大家注意的是，<code>dropna()</code>和<code>fillna()</code>方法都有一个名为<code>inplace</code>的参数，它的默认值是<code>False</code>，表示删除空值或填充空值不会修改原来的<code>Series</code>对象，而是返回一个新的<code>Series</code>对象。如果将<code>inplace</code>参数的值修改为<code>True</code>，那么删除或填充空值会就地操作，直接修改原来的<code>Series</code>对象，此时方法的返回值是<code>None</code>。后面我们会接触到的很多方法，包括<code>DataFrame</code>对象的很多方法都会有这个参数，它们的意义跟这里是一样的。</p>
<p><code>Series</code>对象的<code>mask()</code>和<code>where()</code>方法可以将满足或不满足条件的值进行替换，如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ser5 = pd.Series(<span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line">ser5.where(ser5 &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0    NaN</span><br><span class="line">1    1.0</span><br><span class="line">2    2.0</span><br><span class="line">3    3.0</span><br><span class="line">4    4.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser5.where(ser5 &gt; <span class="number">1</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0    10</span><br><span class="line">1    10</span><br><span class="line">2     2</span><br><span class="line">3     3</span><br><span class="line">4     4</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser5.mask(ser5 &gt; <span class="number">1</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0     0</span><br><span class="line">1     1</span><br><span class="line">2    10</span><br><span class="line">3    10</span><br><span class="line">4    10</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p><code>Series</code>对象的<code>duplicated()</code>方法可以帮助我们找出重复的数据，而<code>drop_duplicates()</code>方法可以帮我们删除重复数据。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser3.duplicated()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0    False</span><br><span class="line">1    False</span><br><span class="line">2     True</span><br><span class="line">3    False</span><br><span class="line">4     True</span><br><span class="line">5     True</span><br><span class="line">6    False</span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser3.drop_duplicates()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0     apple</span><br><span class="line">1    banana</span><br><span class="line">3    pitaya</span><br><span class="line">6    durian</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
<p><code>Series</code>对象的<code>apply()</code>和<code>map()</code>方法非常重要，它们可以通过字典或者指定的函数来处理数据，把数据映射或转换成我们想要的样子。这两个方法在数据准备阶段非常重要，我们先来试一试这个名为<code>map</code>的方法。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ser6 = pd.Series([<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, np.nan, <span class="string">&#x27;rabbit&#x27;</span>])</span><br><span class="line">ser6</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0       cat</span><br><span class="line">1       dog</span><br><span class="line">2       NaN</span><br><span class="line">3    rabbit</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser6.<span class="built_in">map</span>(&#123;<span class="string">&#x27;cat&#x27;</span>: <span class="string">&#x27;kitten&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>: <span class="string">&#x27;puppy&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：通过字典给出的映射规则对数据进行处理。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0    kitten</span><br><span class="line">1     puppy</span><br><span class="line">2       NaN</span><br><span class="line">3       NaN</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser6.<span class="built_in">map</span>(<span class="string">&#x27;I am a &#123;&#125;&#x27;</span>.<span class="built_in">format</span>, na_action=<span class="string">&#x27;ignore&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：将指定字符串的<code>format</code>方法作用到数据系列的数据上，忽略掉所有的空值。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0       I am a cat</span><br><span class="line">1       I am a dog</span><br><span class="line">2              NaN</span><br><span class="line">3    I am a rabbit</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
<p>我们创建一个新的<code>Series</code>对象，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ser7 = pd.Series([<span class="number">20</span>, <span class="number">21</span>, <span class="number">12</span>],  index=[<span class="string">&#x27;London&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Helsinki&#x27;</span>])</span><br><span class="line">ser7</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">London      20</span><br><span class="line">New York    21</span><br><span class="line">Helsinki    12</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser7.apply(np.square)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：将求平方的函数作用到数据系列的数据上，也可以将参数<code>np.square</code>替换为<code>lambda x: x ** 2</code>。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">London      400</span><br><span class="line">New York    441</span><br><span class="line">Helsinki    144</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser7.apply(<span class="keyword">lambda</span> x, value: x - value, args=(<span class="number">5</span>, ))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：上面<code>apply</code>方法中的<code>lambda</code>函数有两个参数，第一个参数是数据系列中的数据，而第二个参数需要我们传入，所以我们给<code>apply</code>方法增加了<code>args</code>参数，用于给<code>lambda</code>函数的第二个参数传值。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">London      15</span><br><span class="line">New York    16</span><br><span class="line">Helsinki     7</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h4 id="取头部值和排序"><a href="#取头部值和排序" class="headerlink" title="取头部值和排序"></a>取头部值和排序</h4><p><code>Series</code>对象的<code>sort_index()</code>和<code>sort_values()</code>方法可以用于对索引和数据的排序，排序方法有一个名为<code>ascending</code>的布尔类型参数，该参数用于控制排序的结果是升序还是降序；而名为<code>kind</code>的参数则用来控制排序使用的算法，默认使用了<code>quicksort</code>，也可以选择<code>mergesort</code>或<code>heapsort</code>；如果存在空值，那么可以用<code>na_position</code>参数空值放在最前还是最后，默认是<code>last</code>，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ser8 = pd.Series(</span><br><span class="line">    data=[<span class="number">35</span>, <span class="number">96</span>, <span class="number">12</span>, <span class="number">57</span>, <span class="number">25</span>, <span class="number">89</span>], </span><br><span class="line">    index=[<span class="string">&#x27;grape&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pitaya&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;peach&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>]</span><br><span class="line">)</span><br><span class="line">ser8.sort_values()  <span class="comment"># 按值从小到大排序</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pitaya    12</span><br><span class="line">peach     25</span><br><span class="line">grape     35</span><br><span class="line">apple     57</span><br><span class="line">orange    89</span><br><span class="line">banana    96</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser8.sort_index(ascending=<span class="literal">False</span>)  <span class="comment"># 按索引从大到小排序</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pitaya    12</span><br><span class="line">peach     25</span><br><span class="line">orange    89</span><br><span class="line">grape     35</span><br><span class="line">banana    96</span><br><span class="line">apple     57</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>如果要从<code>Series</code>对象中找出元素中最大或最小的“Top-N”，我们不需要对所有的值进行排序的，可以使用<code>nlargest()</code>和<code>nsmallest()</code>方法来完成，如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser8.nlargest(<span class="number">3</span>)  <span class="comment"># 值最大的3个</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">banana    96</span><br><span class="line">orange    89</span><br><span class="line">apple     57</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser8.nsmallest(<span class="number">2</span>)  <span class="comment"># 值最小的2个</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pitaya    12</span><br><span class="line">peach     25</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h4 id="绘制图表"><a href="#绘制图表" class="headerlink" title="绘制图表"></a>绘制图表</h4><p><code>Series</code>对象有一个名为<code>plot</code>的方法可以用来生成图表，如果选择生成折线图、饼图、柱状图等，默认会使用<code>Series</code>对象的索引作为横坐标，使用<code>Series</code>对象的数据作为纵坐标。下面我们创建一个<code>Series</code>对象并基于它绘制柱状图，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">ser9 = pd.Series(&#123;<span class="string">&#x27;Q1&#x27;</span>: <span class="number">400</span>, <span class="string">&#x27;Q2&#x27;</span>: <span class="number">520</span>, <span class="string">&#x27;Q3&#x27;</span>: <span class="number">180</span>, <span class="string">&#x27;Q4&#x27;</span>: <span class="number">380</span>&#125;)</span><br><span class="line"><span class="comment"># 通过plot方法的kind指定图表类型为柱状图</span></span><br><span class="line">ser9.plot(kind=<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"><span class="comment"># 定制纵轴的取值范围</span></span><br><span class="line">plt.ylim(<span class="number">0</span>, <span class="number">600</span>)</span><br><span class="line"><span class="comment"># 定制横轴刻度（旋转到0度）</span></span><br><span class="line">plt.xticks(rotation=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 为柱子增加数据标签</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ser9.size):</span><br><span class="line">    plt.text(i, ser9[i] + <span class="number">5</span>, ser9[i], ha=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/ser_bar_graph.png" style="zoom:35%;"></p>
<p>我们也可以将其绘制为饼图，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plot方法的kind参数指定了图表类型为饼图</span></span><br><span class="line"><span class="comment"># autopct会自动计算并显示百分比</span></span><br><span class="line"><span class="comment"># pctdistance用来控制百分比到圆心的距离</span></span><br><span class="line">ser9.plot(kind=<span class="string">&#x27;pie&#x27;</span>, autopct=<span class="string">&#x27;%.1f%%&#x27;</span>, pctdistance=<span class="number">0.65</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/ser_pie_graph.png" style="zoom:35%;"></p>
<h2 id="深入浅出pandas-2"><a href="#深入浅出pandas-2" class="headerlink" title="深入浅出pandas-2"></a>深入浅出pandas-2</h2><p>如果使用 pandas 做数据分析，那么<code>DataFrame</code>一定是被使用得最多的类型，它可以用来保存和处理异质的二维数据。这里所谓的“异质”是指<code>DataFrame</code>中每个列的数据类型不需要相同，这也是它区别于 NumPy 二维数组的地方。<code>DataFrame</code>提供了极为丰富的属性和方法，帮助我们实现对数据的重塑、清洗、预处理、透视、呈现等一系列操作。</p>
<h3 id="创建DataFrame对象"><a href="#创建DataFrame对象" class="headerlink" title="创建DataFrame对象"></a>创建DataFrame对象</h3><h4 id="通过二维数组创建DataFrame对象"><a href="#通过二维数组创建DataFrame对象" class="headerlink" title="通过二维数组创建DataFrame对象"></a>通过二维数组创建DataFrame对象</h4><p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scores = np.random.randint(<span class="number">60</span>, <span class="number">101</span>, (<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">courses = [<span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>]</span><br><span class="line">stu_ids = np.arange(<span class="number">1001</span>, <span class="number">1006</span>)</span><br><span class="line">df1 = pd.DataFrame(data=scores, columns=courses, index=stu_ids)</span><br><span class="line">df1</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">		语文	数学	英语</span><br><span class="line">1001    69    80	79</span><br><span class="line">1002    71	  60	100</span><br><span class="line">1003    94    81	93</span><br><span class="line">1004    88	  88	67</span><br><span class="line">1005    82	  66    60</span><br></pre></td></tr></table></figure>
<h4 id="通过字典创建DataFrame对象"><a href="#通过字典创建DataFrame对象" class="headerlink" title="通过字典创建DataFrame对象"></a>通过字典创建DataFrame对象</h4><p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scores = &#123;</span><br><span class="line">    <span class="string">&#x27;语文&#x27;</span>: [<span class="number">62</span>, <span class="number">72</span>, <span class="number">93</span>, <span class="number">88</span>, <span class="number">93</span>],</span><br><span class="line">    <span class="string">&#x27;数学&#x27;</span>: [<span class="number">95</span>, <span class="number">65</span>, <span class="number">86</span>, <span class="number">66</span>, <span class="number">87</span>],</span><br><span class="line">    <span class="string">&#x27;英语&#x27;</span>: [<span class="number">66</span>, <span class="number">75</span>, <span class="number">82</span>, <span class="number">69</span>, <span class="number">82</span>],</span><br><span class="line">&#125;</span><br><span class="line">stu_ids = np.arange(<span class="number">1001</span>, <span class="number">1006</span>)</span><br><span class="line">df2 = pd.DataFrame(data=scores, index=stu_ids)</span><br><span class="line">df2</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        语文  数学  英语</span><br><span class="line">1001    62    95    66</span><br><span class="line">1002    72    65    75</span><br><span class="line">1003    93    86    82</span><br><span class="line">1004    88    66    69</span><br><span class="line">1005    93    87    82</span><br></pre></td></tr></table></figure>
<h4 id="读取CSV文件创建DataFrame对象"><a href="#读取CSV文件创建DataFrame对象" class="headerlink" title="读取CSV文件创建DataFrame对象"></a>读取CSV文件创建DataFrame对象</h4><p>可以通过<code>pandas</code> 模块的<code>read_csv</code>函数来读取 CSV 文件，<code>read_csv</code>函数的参数非常多，下面介绍几个比较重要的参数。</p>
<ul>
<li><code>sep</code> / <code>delimiter</code>：分隔符，默认是<code>,</code>。</li>
<li><code>header</code>：表头（列索引）的位置，默认值是<code>infer</code>，用第一行的内容作为表头（列索引）。</li>
<li><code>index_col</code>：用作行索引（标签）的列。</li>
<li><code>usecols</code>：需要加载的列，可以使用序号或者列名。</li>
<li><code>true_values</code> / <code>false_values</code>：哪些值被视为布尔值<code>True</code> / <code>False</code>。</li>
<li><code>skiprows</code>：通过行号、索引或函数指定需要跳过的行。</li>
<li><code>skipfooter</code>：要跳过的末尾行数。</li>
<li><code>nrows</code>：需要读取的行数。</li>
<li><code>na_values</code>：哪些值被视为空值。</li>
<li><code>iterator</code>：设置为<code>True</code>，函数返回迭代器对象。</li>
<li><code>chunksize</code>：配合上面的参数，设置每次迭代获取的数据体量。</li>
</ul>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df3 = pd.read_csv(<span class="string">&#x27;data/2018年北京积分落户数据.csv&#x27;</span>, index_col=<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">df3</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示</strong>：上面代码中的CSV文件是用相对路径进行获取的，也就是说当前工作路径下有名为<code>data</code>的文件夹，而“2018年北京积分落户数据.csv”就在这个文件夹下。如果使用Windows系统，在写路径分隔符时也建议使用<code>/</code>而不是<code>\</code>，如果想使用<code>\</code>，建议在字符串前面添加一个<code>r</code>，使用原始字符串来避开转义字符，例如<code>r&#39;c:\new\data\2018年北京积分落户数据.csv&#39;</code>。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">      name   birthday      company          score</span><br><span class="line">id                                             </span><br><span class="line">1     杨xx   1972-12       北京利德华福xxxx  122.59</span><br><span class="line">2     纪xx   1974-12       北京航天数据xxxx  121.25</span><br><span class="line">3     王x    1974-05       品牌联盟(北京)xx  118.96</span><br><span class="line">4     杨x    1975-07       中科专利商标xxxx  118.21</span><br><span class="line">5     张xx   1974-11       北京阿里巴巴xxxx  117.79</span><br><span class="line">...   ...      ...                  ...     ...</span><br><span class="line">6015  孙xx   1978-08       华为海洋网络xxxx   90.75</span><br><span class="line">6016  刘xx   1976-11       福斯（上海）xxxx   90.75</span><br><span class="line">6017  周x    1977-10       赢创德固赛xxxxxx   90.75</span><br><span class="line">6018  赵x    1979-07       澳科利耳医疗xxxx   90.75</span><br><span class="line">6019  贺x    1981-06       北京宝洁技术xxxx   90.75</span><br><span class="line"></span><br><span class="line">[6019 rows x 4 columns]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>： 上面输出的内容隐去了姓名（name）和公司名称（company）字段中的部分信息。如果需要上面例子中的 CSV 文件，可以通过百度云盘获取，链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g</a>，提取码：e7b4。</p>
</blockquote>
<h4 id="读取Excel工作表创建DataFrame对象"><a href="#读取Excel工作表创建DataFrame对象" class="headerlink" title="读取Excel工作表创建DataFrame对象"></a>读取Excel工作表创建DataFrame对象</h4><p>可以通过<code>pandas</code> 模块的<code>read_excel</code>函数来读取 Excel 文件，该函数与上面的<code>read_csv</code>非常类似，多了一个<code>sheet_name</code>参数来指定数据表的名称，但是不同于 CSV 文件，没有<code>sep</code>或<code>delimiter</code>这样的参数。假设有名为“2022年股票数据.xlsx”的 Excel 文件，里面有用股票代码命名的五个表单，分别是阿里巴巴（BABA）、百度（BIDU）、京东（JD）、亚马逊（AMZN）、甲骨文（ORCL）这五个公司2022年的股票数据，如果想加载亚马逊的股票数据，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df4 = pd.read_excel(<span class="string">&#x27;data/2022年股票数据.xlsx&#x27;</span>, sheet_name=<span class="string">&#x27;AMZN&#x27;</span>, index_col=<span class="string">&#x27;Date&#x27;</span>)</span><br><span class="line">df4</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：上面例子中的 CSV 文件可以通过百度云盘获取，链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g</a>，提取码：e7b4。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">               Open     High       Low    Close    Volume</span><br><span class="line">Date                                                     </span><br><span class="line">2022-12-30   83.120   84.050   82.4700   84.000  62401194</span><br><span class="line">2022-12-29   82.870   84.550   82.5500   84.180  54995895</span><br><span class="line">2022-12-28   82.800   83.480   81.6900   81.820  58228575</span><br><span class="line">2022-12-27   84.970   85.350   83.0000   83.040  57284035</span><br><span class="line">2022-12-23   83.250   85.780   82.9344   85.250  57433655</span><br><span class="line">...             ...      ...       ...      ...       ...</span><br><span class="line">2022-01-07  163.839  165.243  162.0310  162.554  46605900</span><br><span class="line">2022-01-06  163.450  164.800  161.9370  163.254  51957780</span><br><span class="line">2022-01-05  166.883  167.126  164.3570  164.357  64302720</span><br><span class="line">2022-01-04  170.438  171.400  166.3490  167.522  70725160</span><br><span class="line">2022-01-03  167.550  170.704  166.1600  170.404  63869140</span><br><span class="line"></span><br><span class="line">[251 rows x 5 columns]</span><br></pre></td></tr></table></figure>
<h4 id="读取关系数据库二维表创建DataFrame对象"><a href="#读取关系数据库二维表创建DataFrame对象" class="headerlink" title="读取关系数据库二维表创建DataFrame对象"></a>读取关系数据库二维表创建DataFrame对象</h4><p><code>pandas</code>模块的<code>read_sql</code>函数可以通过 SQL 语句从数据库中读取数据创建<code>DataFrame</code>对象，该函数的第二个参数代表了需要连接的数据库。对于 MySQL 数据库，我们可以通过<code>pymysql</code>或<code>mysqlclient</code>来创建数据库连接（需要提前安装好三方库），得到一个<code>Connection</code> 对象，而这个对象就是<code>read_sql</code>函数需要的第二个参数，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个MySQL数据库的连接对象</span></span><br><span class="line">conn = pymysql.connect(</span><br><span class="line">    host=<span class="string">&#x27;101.42.16.8&#x27;</span>, port=<span class="number">3306</span>,</span><br><span class="line">    user=<span class="string">&#x27;guest&#x27;</span>, password=<span class="string">&#x27;Guest.618&#x27;</span>,</span><br><span class="line">    database=<span class="string">&#x27;hrs&#x27;</span>, charset=<span class="string">&#x27;utf8mb4&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 通过SQL从数据库二维表读取数据创建DataFrame</span></span><br><span class="line">df5 = pd.read_sql(<span class="string">&#x27;select * from tb_emp&#x27;</span>, conn, index_col=<span class="string">&#x27;eno&#x27;</span>)</span><br><span class="line">df5</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示</strong>：执行上面的代码需要先安装<code>pymysql</code>库，如果尚未安装，可以先在单元格中先执行魔法指令<code>%pip install pymysql</code>，然后再运行上面的代码。上面的代码连接的是我部署在腾讯云上的 MySQL 数据库，公网 IP 地址：<code>101.42.16.8</code>，用户名：<code>guest</code>，密码：<code>Guest.618</code>，数据库：<code>hrs</code>，字符集：<code>utf8mb4</code>，大家可以使用这个数据库，但是不要进行恶意的访问。<code>hrs</code>数据库一共有三张表，分别是：<code>tb_dept</code>（部门表）、<code>tb_emp</code>（员工表）、<code>tb_emp2</code>（员工表2）。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">       ename   job     mgr     sal    comm    dno</span><br><span class="line">eno                                        </span><br><span class="line">1359   胡一刀   销售员  3344.0  1800   200.0   30</span><br><span class="line">2056    乔峰   分析师   7800.0  5000  1500.0   20</span><br><span class="line">3088   李莫愁   设计师  2056.0  3500   800.0   20</span><br><span class="line">3211   张无忌   程序员  2056.0  3200     NaN   20</span><br><span class="line">3233   丘处机   程序员  2056.0  3400     NaN   20</span><br><span class="line">3244   欧阳锋   程序员  3088.0  3200     NaN   20</span><br><span class="line">3251   张翠山   程序员  2056.0  4000     NaN   20</span><br><span class="line">3344    黄蓉  销售主管  7800.0  3000   800.0   30</span><br><span class="line">3577    杨过    会计    5566.0  2200     NaN   10</span><br><span class="line">3588   朱九真    会计   5566.0  2500     NaN   10</span><br><span class="line">4466   苗人凤   销售员  3344.0  2500     NaN   30</span><br><span class="line">5234    郭靖    出纳    5566.0  2000     NaN   10</span><br><span class="line">5566   宋远桥   会计师  7800.0  4000  1000.0   10</span><br><span class="line">7800   张三丰    总裁     NaN   9000  1200.0   20</span><br></pre></td></tr></table></figure>
<p>执行上面的代码会出现一个警告，因为 pandas 库希望我们使用<code>SQLAlchemy</code>三方库接入数据库，具体内容是：“UserWarning: pandas only supports SQLAlchemy connectable (engine/connection) or database string URI or sqlite3 DBAPI2 connection. Other DBAPI2 objects are not tested. Please consider using SQLAlchemy.”。如果不想看到这个警告，我们可以试一试下面的解决方案。</p>
<p>首先，安装三方库<code>SQLAlchemy</code>，在 Jupyter 中可以使用<code>%pip</code>魔法指令。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%pip install sqlalchemy</span><br></pre></td></tr></table></figure>
<p>通过<code>SQLAlchemy</code>的<code>create_engine</code>函数创建<code>Engine</code>对象作为<code>read_sql</code>函数的第二个参数，此时<code>read_sql</code>函数的第一个参数可以是 SQL 语句，也可以是二维表的表名。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过指定的URL（统一资源定位符）访问数据库</span></span><br><span class="line">engine = create_engine(<span class="string">&#x27;mysql+pymysql://guest:Guest.618@101.42.16.8:3306/hrs&#x27;</span>)</span><br><span class="line"><span class="comment"># 直接通过表名加载整张表的数据</span></span><br><span class="line">df5 = pd.read_sql(<span class="string">&#x27;tb_emp&#x27;</span>, engine, index_col=<span class="string">&#x27;eno&#x27;</span>)</span><br><span class="line">df5</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：如果通过表名加载二维表数据，也可以将上面的函数换成<code>read_sql_table</code>。</p>
</blockquote>
<p>我们再来加载部门表的数据创建<code>DataFrame</code>对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df6 = pd.read_sql(<span class="string">&#x27;select dno, dname, dloc from tb_dept&#x27;</span>, engine, index_col=<span class="string">&#x27;dno&#x27;</span>)</span><br><span class="line">df6</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：如果通过 SQL 查询获取数据，也可以将上面的函数换成<code>read_sql_query</code>。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      dname   dloc</span><br><span class="line">dno           </span><br><span class="line">10    会计部   北京</span><br><span class="line">20    研发部   成都</span><br><span class="line">30    销售部   重庆</span><br><span class="line">40    运维部   深圳</span><br></pre></td></tr></table></figure>
<p>在完成数据加载后，如果希望释放数据库连接，可以使用下面的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engine.connect().close()</span><br></pre></td></tr></table></figure>
<h3 id="基本属性和方法"><a href="#基本属性和方法" class="headerlink" title="基本属性和方法"></a>基本属性和方法</h3><p>在开始讲解<code>DataFrame</code>的属性和方法前，我们先从之前提到的<code>hrs</code>数据库中读取三张表的数据，创建出三个<code>DataFrame</code>对象，完整的代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">&#x27;mysql+pymysql://guest:Guest.618@101.42.16.8:3306/hrs&#x27;</span>)</span><br><span class="line">dept_df = pd.read_sql_table(<span class="string">&#x27;tb_dept&#x27;</span>, engine, index_col=<span class="string">&#x27;dno&#x27;</span>)</span><br><span class="line">emp_df = pd.read_sql_table(<span class="string">&#x27;tb_emp&#x27;</span>, engine, index_col=<span class="string">&#x27;eno&#x27;</span>)</span><br><span class="line">emp2_df = pd.read_sql_table(<span class="string">&#x27;tb_emp2&#x27;</span>, engine, index_col=<span class="string">&#x27;eno&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>得到的三个<code>DataFrame</code>对象如下所示。</p>
<p>部门表（<code>dept_df</code>），其中<code>dno</code>是部门的编号，<code>dname</code>和<code>dloc</code>分别是部门的名称和所在地。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    dname  dloc</span><br><span class="line">dno</span><br><span class="line">10	会计部	北京</span><br><span class="line">20	研发部	成都</span><br><span class="line">30	销售部	重庆</span><br><span class="line">40	运维部	深圳</span><br></pre></td></tr></table></figure>
<p>员工表（<code>emp_df</code>），其中<code>eno</code>是员工编号，<code>ename</code>、<code>job</code>、<code>mgr</code>、<code>sal</code>、<code>comm</code>和<code>dno</code>分别代表员工的姓名、职位、主管编号、月薪、补贴和部门编号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        ename    job        mgr      sal     comm    dno</span><br><span class="line">eno</span><br><span class="line">1359	胡一刀    销售员	   3344.0	1800	200.0	30</span><br><span class="line">2056	乔峰	    分析师	    7800.0	 5000	 1500.0	 20</span><br><span class="line">3088	李莫愁	   设计师	   2056.0	3500	800.0	20</span><br><span class="line">3211	张无忌	   程序员	   2056.0	3200	NaN     20</span><br><span class="line">3233	丘处机	   程序员	   2056.0	3400	NaN	    20</span><br><span class="line">3244	欧阳锋	   程序员	   3088.0	3200	NaN     20</span><br><span class="line">3251	张翠山	   程序员	   2056.0	4000	NaN	    20</span><br><span class="line">3344	黄蓉	    销售主管   7800.0	3000	800.0	30</span><br><span class="line">3577	杨过	    会计	     5566.0	  2200	  NaN	  10</span><br><span class="line">3588	朱九真	   会计	    5566.0	 2500	 NaN	 10</span><br><span class="line">4466	苗人凤	   销售员	   3344.0	2500	NaN	    30</span><br><span class="line">5234	郭靖	    出纳	     5566.0	  2000	  NaN	  10</span><br><span class="line">5566	宋远桥	   会计师	   7800.0	4000	1000.0	10</span><br><span class="line">7800	张三丰	   总裁	    NaN      9000	 1200.0	 20</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：在数据库中<code>mgr</code>和<code>comm</code>两个列的数据类型是<code>int</code>，但是因为有缺失值（空值），读取到<code>DataFrame</code>之后，列的数据类型变成了<code>float</code>，因为我们通常会用<code>float</code>类型的<code>NaN</code>来表示空值。</p>
</blockquote>
<p>员工表（<code>emp2_df</code>），跟上面的员工表结构相同，但是保存了不同的员工数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       ename    job      mgr      sal    comm    dno</span><br><span class="line">eno                                      </span><br><span class="line">9500   张三丰   总裁      NaN      50000  8000    20</span><br><span class="line">9600   王大锤   程序员    9800.0   8000   600     20</span><br><span class="line">9700   张三丰   总裁      NaN      60000  6000    20</span><br><span class="line">9800   骆昊     架构师    7800.0   30000  5000    20</span><br><span class="line">9900   陈小刀   分析师    9800.0   10000  1200    20</span><br></pre></td></tr></table></figure>
<p><code>DataFrame</code>对象的属性如下表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>at</code> / <code>iat</code></td>
<td>通过标签获取<code>DataFrame</code>中的单个值。</td>
</tr>
<tr>
<td><code>columns</code></td>
<td><code>DataFrame</code>对象列的索引</td>
</tr>
<tr>
<td><code>dtypes</code></td>
<td><code>DataFrame</code>对象每一列的数据类型</td>
</tr>
<tr>
<td><code>empty</code></td>
<td><code>DataFrame</code>对象是否为空</td>
</tr>
<tr>
<td><code>loc</code> / <code>iloc</code></td>
<td>通过标签获取<code>DataFrame</code>中的一组值。</td>
</tr>
<tr>
<td><code>ndim</code></td>
<td><code>DataFrame</code>对象的维度</td>
</tr>
<tr>
<td><code>shape</code></td>
<td><code>DataFrame</code>对象的形状（行数和列数）</td>
</tr>
<tr>
<td><code>size</code></td>
<td><code>DataFrame</code>对象中元素的个数</td>
</tr>
<tr>
<td><code>values</code></td>
<td><code>DataFrame</code>对象的数据对应的二维数组</td>
</tr>
</tbody>
</table>
</div>
<p>关于<code>DataFrame</code>的方法，首先需要了解的是<code>info()</code>方法，它可以帮助我们了解<code>DataFrame</code>的相关信息，如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df.info()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;</span><br><span class="line">Int64Index: 14 entries, 1359 to 7800</span><br><span class="line">Data columns (total 6 columns):</span><br><span class="line"> #   Column  Non-Null Count  Dtype  </span><br><span class="line">---  ------  --------------  -----  </span><br><span class="line"> 0   ename   14 non-null     object </span><br><span class="line"> 1   job     14 non-null     object </span><br><span class="line"> 2   mgr     13 non-null     float64</span><br><span class="line"> 3   sal     14 non-null     int64  </span><br><span class="line"> 4   comm    6 non-null      float64</span><br><span class="line"> 5   dno     14 non-null     int64  </span><br><span class="line">dtypes: float64(2), int64(2), object(2)</span><br><span class="line">memory usage: 1.3+ KB</span><br></pre></td></tr></table></figure>
<p>如果需要查看<code>DataFrame</code>的头部或尾部的数据，可以使用<code>head()</code>或<code>tail()</code>方法，这两个方法的默认参数是<code>5</code>，表示获取<code>DataFrame</code>最前面5行或最后面5行的数据，如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df.head()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        ename    job    mgr    sal    comm  dno</span><br><span class="line">eno						</span><br><span class="line">1359	胡一刀   销售员	3344   1800  200   30</span><br><span class="line">2056	乔峰	   分析师	 7800   5000  1500	20</span><br><span class="line">3088	李莫愁	  设计师	2056   3500  800   20</span><br><span class="line">3211	张无忌	  程序员	2056   3200  NaN   20</span><br><span class="line">3233	丘处机	  程序员	2056   3400	 NaN   20</span><br></pre></td></tr></table></figure>
<h3 id="操作数据"><a href="#操作数据" class="headerlink" title="操作数据"></a>操作数据</h3><h4 id="索引和切片"><a href="#索引和切片" class="headerlink" title="索引和切片"></a>索引和切片</h4><p>如果要获取<code>DataFrame</code>的某一列，例如取出上面<code>emp_df</code>的<code>ename</code>列，可以使用下面的两种方式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df.ename</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df[<span class="string">&#x27;ename&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>执行上面的代码可以发现，我们获得的是一个<code>Series</code>对象。事实上，<code>DataFrame</code>对象就是将多个<code>Series</code>对象组合到一起的结果。</p>
<p>如果要获取<code>DataFrame</code>的某一行，可以使用整数索引或我们设置的索引，例如取出员工编号为<code>2056</code>的员工数据，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df.iloc[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df.loc[<span class="number">2056</span>]</span><br></pre></td></tr></table></figure>
<p>通过执行上面的代码我们发现，单独取<code>DataFrame</code> 的某一行或某一列得到的都是<code>Series</code>对象。我们当然也可以通过花式索引来获取多个行或多个列的数据，花式索引的结果仍然是一个<code>DataFrame</code>对象。</p>
<p>获取多个列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df[[<span class="string">&#x27;ename&#x27;</span>, <span class="string">&#x27;job&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<p>获取多个行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df.loc[[<span class="number">2056</span>, <span class="number">7800</span>, <span class="number">3344</span>]]</span><br></pre></td></tr></table></figure>
<p>如果要获取或修改<code>DataFrame</code> 对象某个单元格的数据，需要同时指定行和列的索引，例如要获取员工编号为<code>2056</code>的员工的职位信息，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df[<span class="string">&#x27;job&#x27;</span>][<span class="number">2056</span>]</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df.loc[<span class="number">2056</span>][<span class="string">&#x27;job&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df.loc[<span class="number">2056</span>, <span class="string">&#x27;job&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>我们推荐大家使用第三种做法，因为它只做了一次索引运算。如果要将该员工的职位修改为“架构师”，可以使用下面的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df.loc[<span class="number">2056</span>, <span class="string">&#x27;job&#x27;</span>] = <span class="string">&#x27;架构师&#x27;</span></span><br></pre></td></tr></table></figure>
<p>当然，我们也可以通过切片操作来获取多行多列，相信大家一定已经想到了这一点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df.loc[<span class="number">2056</span>:<span class="number">3344</span>]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        ename    job        mgr      sal     comm    dno</span><br><span class="line">eno</span><br><span class="line">2056	乔峰	    分析师	    7800.0	 5000	 1500.0	 20</span><br><span class="line">3088	李莫愁	   设计师	   2056.0	3500	800.0	20</span><br><span class="line">3211	张无忌	   程序员	   2056.0	3200	NaN     20</span><br><span class="line">3233	丘处机	   程序员	   2056.0	3400	NaN	    20</span><br><span class="line">3244	欧阳锋	   程序员	   3088.0	3200	NaN     20</span><br><span class="line">3251	张翠山	   程序员	   2056.0	4000	NaN	    20</span><br><span class="line">3344	黄蓉	    销售主管   7800.0	3000	800.0	30</span><br></pre></td></tr></table></figure>
<h4 id="数据筛选"><a href="#数据筛选" class="headerlink" title="数据筛选"></a>数据筛选</h4><p>上面我们提到了花式索引，相信大家已经联想到了布尔索引。跟<code>ndarray</code>和<code>Series</code>一样，我们可以通过布尔索引对<code>DataFrame</code>对象进行数据筛选，例如我们要从<code>emp_df</code>中筛选出月薪超过<code>3500</code>的员工，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df[emp_df.sal &gt; <span class="number">3500</span>]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        ename    job        mgr      sal     comm    dno</span><br><span class="line">eno</span><br><span class="line">2056	乔峰	    分析师	    7800.0	 5000	 1500.0	 20</span><br><span class="line">3251	张翠山	   程序员	   2056.0	4000	NaN	    20</span><br><span class="line">5566	宋远桥	   会计师	   7800.0	4000	1000.0	10</span><br><span class="line">7800	张三丰	   总裁	    NaN      9000	 1200.0	 20</span><br></pre></td></tr></table></figure>
<p>当然，我们也可以组合多个条件来进行数据筛选，例如从<code>emp_df</code>中筛选出月薪超过<code>3500</code>且部门编号为<code>20</code>的员工，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df[(emp_df.sal &gt; <span class="number">3500</span>) &amp; (emp_df.dno == <span class="number">20</span>)]</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        ename    job        mgr      sal     comm    dno</span><br><span class="line">eno</span><br><span class="line">2056	乔峰	    分析师	    7800.0	 5000	 1500.0	 20</span><br><span class="line">3251	张翠山	   程序员	   2056.0	4000	NaN	    20</span><br><span class="line">7800	张三丰	   总裁	    NaN      9000	 1200.0	 20</span><br></pre></td></tr></table></figure>
<p>除了使用布尔索引，<code>DataFrame</code>对象的<code>query</code>方法也可以实现数据筛选，<code>query</code>方法的参数是一个字符串，它代表了筛选数据使用的表达式，而且更符合 Python 程序员的使用习惯。下面我们使用<code>query</code>方法将上面的效果重新实现一遍，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df.query(<span class="string">&#x27;sal &gt; 3500 and dno == 20&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="深入浅出pandas-3"><a href="#深入浅出pandas-3" class="headerlink" title="深入浅出pandas-3"></a>深入浅出pandas-3</h2><p>在完成数据加载之后，我们可能需要对事实表和维度表进行连接，这是对数据进行多维度拆解的基础；我们可能从不同的数据源加载了结构相同的数据，我们需要将这些数据拼接起来；我们把这些操作统称为数据重塑。当然，由于企业的信息化水平以及数据中台建设水平的差异，我们拿到的数据未必是质量很好的，可能还需要对数据中的缺失值、重复值、异常值进行适当的处理。即便我们获取的数据在质量上是没有问题的，但也可能需要对数据进行一系列的预处理，才能满足我们做数据分析的需求。接下来，我们就为大家讲解和梳理这方面的知识。</p>
<h3 id="数据重塑"><a href="#数据重塑" class="headerlink" title="数据重塑"></a>数据重塑</h3><p>有的时候，我们做数据分析需要的原始数据可能并不是来自一个地方，就像上一章的例子中，我们从关系型数据库中读取了三张表，得到了三个<code>DataFrame</code>对象，但实际工作可能需要我们把他们的数据整合到一起。例如：<code>emp_df</code>和<code>emp2_df</code>其实都是员工的数据，而且数据结构完全一致，我们可以使用<code>pandas</code>提供的<code>concat</code>函数实现两个或多个<code>DataFrame</code>的数据拼接，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_emp_df = pd.concat([emp_df, emp2_df])</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">        ename    job        mgr      sal     comm    dno</span><br><span class="line">eno</span><br><span class="line">1359    胡一刀    销售员	   3344.0	1800	200.0	30</span><br><span class="line">2056    乔峰	    分析师	    7800.0	 5000	 1500.0	 20</span><br><span class="line">3088    李莫愁	   设计师	   2056.0	3500	800.0	20</span><br><span class="line">3211    张无忌	   程序员	   2056.0	3200	NaN     20</span><br><span class="line">3233    丘处机	   程序员	   2056.0	3400	NaN	    20</span><br><span class="line">3244    欧阳锋	   程序员	   3088.0	3200	NaN     20</span><br><span class="line">3251    张翠山	   程序员	   2056.0	4000	NaN	    20</span><br><span class="line">3344    黄蓉	    销售主管   7800.0	3000	800.0	30</span><br><span class="line">3577    杨过	    会计	     5566.0	  2200	  NaN	  10</span><br><span class="line">3588    朱九真	   会计	    5566.0	 2500	 NaN	 10</span><br><span class="line">4466    苗人凤	   销售员	   3344.0	2500	NaN	    30</span><br><span class="line">5234    郭靖	    出纳	     5566.0	  2000	  NaN	  10</span><br><span class="line">5566    宋远桥	   会计师	   7800.0	4000	1000.0	10</span><br><span class="line">7800    张三丰	   总裁	    NaN      9000	 1200.0	 20</span><br><span class="line">9500	张三丰	   总裁	    NaN	     50000	 8000.0	 20</span><br><span class="line">9600	王大锤    程序员	   9800.0	8000	600.0	20</span><br><span class="line">9700	张三丰	   总裁	    NaN	     60000	 6000.0	 20</span><br><span class="line">9800	骆昊	    架构师	    7800.0	 30000	 5000.0	 20</span><br><span class="line">9900	陈小刀	   分析师	   9800.0	10000	1200.0	20</span><br></pre></td></tr></table></figure>
<p>上面的代码将两个代表员工数据的<code>DataFrame</code>拼接到了一起，接下来我们使用<code>merge</code>函数将员工表和部门表的数据合并到一张表中，代码如下所示。</p>
<p>先使用<code>reset_index</code>方法重新设置<code>all_emp_df</code>的索引，这样<code>eno</code> 不再是索引而是一个普通列，<code>reset_index</code>方法的<code>inplace</code>参数设置为<code>True</code>表示，重置索引的操作直接在<code>all_emp_df</code>上执行，而不是返回修改后的新对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_emp_df.reset_index(inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>通过<code>merge</code>函数合并数据，当然，也可以调用<code>DataFrame</code>对象的<code>merge</code>方法来达到同样的效果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(all_emp_df, dept_df, how=<span class="string">&#x27;inner&#x27;</span>, on=<span class="string">&#x27;dno&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    eno	    ename	job	     mgr	 sal	 comm	 dno	dname	 dloc</span><br><span class="line">0	1359	胡一刀	 销售员	3344.0	1800	200.0	30	   销售部	 重庆</span><br><span class="line">1	3344	黄蓉	  销售主管	7800.0	3000	800.0	30	   销售部	 重庆</span><br><span class="line">2	4466	苗人凤	 销售员	3344.0	2500	NaN	    30	   销售部	 重庆</span><br><span class="line">3	2056	乔峰	  分析师	 7800.0	 5000	 1500.0	 20	    研发部	  成都</span><br><span class="line">4	3088	李莫愁	 设计师	2056.0	3500	800.0	20	   研发部	 成都</span><br><span class="line">5	3211	张无忌  程序员	2056.0	3200	NaN	    20	   研发部	 成都</span><br><span class="line">6	3233	丘处机	 程序员	2056.0	3400	NaN	    20	   研发部	 成都</span><br><span class="line">7	3244	欧阳锋	 程序员	3088.0	3200	NaN	    20	   研发部	 成都</span><br><span class="line">8	3251	张翠山	 程序员	2056.0	4000	NaN	    20	   研发部	 成都</span><br><span class="line">9	7800	张三丰	 总裁	     NaN	 9000	 1200.0	 20	    研发部	  成都</span><br><span class="line">10	9500	张三丰	 总裁	     NaN	 50000	 8000.0	 20	    研发部	  成都</span><br><span class="line">11	9600	王大锤	 程序员	9800.0	8000	600.0	20	   研发部	 成都</span><br><span class="line">12	9700	张三丰	 总裁	     NaN	 60000	 6000.0	 20	    研发部	  成都</span><br><span class="line">13	9800	骆昊	  架构师	 7800.0	 30000	 5000.0	 20	    研发部	  成都</span><br><span class="line">14	9900	陈小刀	 分析师	9800.0	10000	1200.0	20	   研发部	 成都</span><br><span class="line">15	3577	杨过	  会计	  5566.0  2200	  NaN	  10	会计部	  北京</span><br><span class="line">16	3588	朱九真	 会计	     5566.0	 2500	 NaN	 10	   会计部	 北京</span><br><span class="line">17	5234	郭靖	  出纳	  5566.0  2000	  NaN	  10	会计部	  北京</span><br><span class="line">18	5566	宋远桥	 会计师	7800.0	4000	1000.0	10	  会计部	北京</span><br></pre></td></tr></table></figure>
<p><code>merge</code>函数的一个参数代表合并的左表、第二个参数代表合并的右表，有SQL编程经验的同学对这两个词是不是感觉到非常亲切。正如大家猜想的那样，<code>DataFrame</code>对象的合并跟数据库中的表连接非常类似，所以上面代码中的<code>how</code>代表了合并两张表的方式，有<code>left</code>、<code>right</code>、<code>inner</code>、<code>outer</code>四个选项；而<code>on</code>则代表了基于哪个列实现表的合并，相当于 SQL 表连接中的连表条件，如果左右两表对应的列列名不同，可以用<code>left_on</code>和<code>right_on</code>参数取代<code>on</code>参数分别进行指定。</p>
<p>如果对上面的代码稍作修改，将<code>how</code>参数修改为<code>&#39;right&#39;</code>，大家可以思考一下代码执行的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(all_emp_df, dept_df, how=<span class="string">&#x27;right&#x27;</span>, on=<span class="string">&#x27;dno&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果比之前的输出多出了如下所示的一行，这是因为<code>how=&#39;right&#39;</code>代表右外连接，也就意味着右表<code>dept_df</code>中的数据会被完整的查出来，但是在<code>all_emp_df</code>中又没有编号为<code>40</code> 部门的员工，所以对应的位置都被填入了空值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19	NaN    NaN    NaN    NaN    NaN     NaN    40    运维部    深圳</span><br></pre></td></tr></table></figure>
<h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><p>通常，我们从 Excel、CSV 或数据库中获取到的数据并不是非常完美的，里面可能因为系统或人为的原因混入了重复值或异常值，也可能在某些字段上存在缺失值；再者，<code>DataFrame</code>中的数据也可能存在格式不统一、量纲不统一等各种问题。因此，在开始数据分析之前，对数据进行清洗就显得特别重要。</p>
<h4 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h4><p>可以使用<code>DataFrame</code>对象的<code>isnull</code>或<code>isna</code>方法来找出数据表中的缺失值，如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df.isnull()</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df.isna()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        ename   job	    mgr     sal     comm    dno</span><br><span class="line">eno						</span><br><span class="line">1359	False	False	False	False	False	False</span><br><span class="line">2056	False	False	False	False	False	False</span><br><span class="line">3088	False	False	False	False	False	False</span><br><span class="line">3211	False	False	False	False	True	False</span><br><span class="line">3233	False	False	False	False	True	False</span><br><span class="line">3244	False	False	False	False	True	False</span><br><span class="line">3251	False	False	False	False	True	False</span><br><span class="line">3344	False	False	False	False	False	False</span><br><span class="line">3577	False	False	False	False	True	False</span><br><span class="line">3588	False	False	False	False	True	False</span><br><span class="line">4466	False	False	False	False	True	False</span><br><span class="line">5234	False	False	False	False	True	False</span><br><span class="line">5566	False	False	False	False	False	False</span><br><span class="line">7800	False	False	True	False	False	False</span><br></pre></td></tr></table></figure>
<p>相对应的，<code>notnull</code>和<code>notna</code>方法可以将非空的值标记为<code>True</code>。如果想删除这些缺失值，可以使用<code>DataFrame</code>对象的<code>dropna</code>方法，该方法的<code>axis</code>参数可以指定沿着0轴还是1轴删除，也就是说当遇到空值时，是删除整行还是删除整列，默认是沿0轴进行删除的，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df.dropna()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        ename   job      mgr	 sal    comm     dno</span><br><span class="line">eno						</span><br><span class="line">1359	胡一刀  销售员	3344.0	1800   200.0	30</span><br><span class="line">2056	乔峰    架构师	 7800.0	 5000	1500.0	 20</span><br><span class="line">3088	李莫愁  设计师	2056.0	3500   800.0	20</span><br><span class="line">3344	黄蓉    销售主管	7800.0	3000   800.0	30</span><br><span class="line">5566	宋远桥  会计师	7800.0	4000   1000.0	10</span><br></pre></td></tr></table></figure>
<p>如果要沿着1轴进行删除，可以使用下面的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df.dropna(axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        ename    job      sal    dno</span><br><span class="line">eno				</span><br><span class="line">1359	胡一刀   销售员    1800	30</span><br><span class="line">2056	乔峰     架构师	  5000	 20</span><br><span class="line">3088	李莫愁   设计师    3500	20</span><br><span class="line">3211	张无忌   程序员    3200	20</span><br><span class="line">3233	丘处机   程序员    3400	20</span><br><span class="line">3244	欧阳锋   程序员    3200	20</span><br><span class="line">3251	张翠山   程序员    4000	20</span><br><span class="line">3344	黄蓉     销售主管  3000	30</span><br><span class="line">3577	杨过     会计	   2200	  10</span><br><span class="line">3588	朱九真   会计	  2500	 10</span><br><span class="line">4466	苗人凤   销售员	 2500   30</span><br><span class="line">5234	郭靖     出纳      2000   10</span><br><span class="line">5566	宋远桥   会计师    4000   10</span><br><span class="line">7800	张三丰   总裁      9000   20</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：<code>DataFrame</code>对象的很多方法都有一个名为<code>inplace</code>的参数，该参数的默认值为<code>False</code>，表示我们的操作不会修改原来的<code>DataFrame</code>对象，而是将处理后的结果通过一个新的<code>DataFrame</code>对象返回。如果将该参数的值设置为<code>True</code>，那么我们的操作就会在原来的<code>DataFrame</code>上面直接修改，方法的返回值为<code>None</code>。简单的说，上面的操作并没有修改<code>emp_df</code>，而是返回了一个新的<code>DataFrame</code>对象。</p>
</blockquote>
<p>在某些特定的场景下，我们可以对空值进行填充，对应的方法是<code>fillna</code>，填充空值时可以使用指定的值（通过<code>value</code>参数进行指定），也可以用表格中前一个单元格（通过设置参数<code>method=ffill</code>）或后一个单元格（通过设置参数<code>method=bfill</code>）的值进行填充，当代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df.fillna(value=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：填充的值如何选择也是一个值得探讨的话题，实际工作中，可能会使用某种统计量（如：均值、众数等）进行填充，或者使用某种插值法（如：随机插值法、拉格朗日插值法等）进行填充，甚至有可能通过回归模型、贝叶斯模型等对缺失数据进行填充。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        ename    job        mgr      sal     comm    dno</span><br><span class="line">eno</span><br><span class="line">1359	胡一刀    销售员	   3344.0	1800	200.0	30</span><br><span class="line">2056	乔峰	    分析师	    7800.0	 5000	 1500.0	 20</span><br><span class="line">3088	李莫愁	   设计师	   2056.0	3500	800.0	20</span><br><span class="line">3211	张无忌	   程序员	   2056.0	3200	0.0     20</span><br><span class="line">3233	丘处机	   程序员	   2056.0	3400	0.0	    20</span><br><span class="line">3244	欧阳锋	   程序员	   3088.0	3200	0.0     20</span><br><span class="line">3251	张翠山	   程序员	   2056.0	4000	0.0	    20</span><br><span class="line">3344	黄蓉	    销售主管   7800.0	3000	800.0	30</span><br><span class="line">3577	杨过	    会计	     5566.0	  2200	  0.0	  10</span><br><span class="line">3588	朱九真	   会计	    5566.0	 2500	 0.0	 10</span><br><span class="line">4466	苗人凤	   销售员	   3344.0	2500	0.0	    30</span><br><span class="line">5234	郭靖	    出纳	     5566.0	  2000	  0.0	  10</span><br><span class="line">5566	宋远桥	   会计师	   7800.0	4000	1000.0	10</span><br><span class="line">7800	张三丰	   总裁	    0.0      9000	 1200.0	 20</span><br></pre></td></tr></table></figure>
<h4 id="重复值"><a href="#重复值" class="headerlink" title="重复值"></a>重复值</h4><p>接下来，我们先给之前的部门表添加两行数据，让部门表中名为“研发部”和“销售部”的部门各有两个。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dept_df.loc[<span class="number">50</span>] = &#123;<span class="string">&#x27;dname&#x27;</span>: <span class="string">&#x27;研发部&#x27;</span>, <span class="string">&#x27;dloc&#x27;</span>: <span class="string">&#x27;上海&#x27;</span>&#125;</span><br><span class="line">dept_df.loc[<span class="number">60</span>] = &#123;<span class="string">&#x27;dname&#x27;</span>: <span class="string">&#x27;销售部&#x27;</span>, <span class="string">&#x27;dloc&#x27;</span>: <span class="string">&#x27;长沙&#x27;</span>&#125;</span><br><span class="line">dept_df</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    dname  dloc</span><br><span class="line">dno		</span><br><span class="line">10	会计部	北京</span><br><span class="line">20	研发部	成都</span><br><span class="line">30	销售部	重庆</span><br><span class="line">40	运维部	天津</span><br><span class="line">50	研发部	上海</span><br><span class="line">60	销售部	长沙</span><br></pre></td></tr></table></figure>
<p>现在，我们的数据表中有重复数据了，我们可以通过<code>DataFrame</code>对象的<code>duplicated</code>方法判断是否存在重复值，该方法在不指定参数时默认判断行索引是否重复，我们也可以指定根据部门名称<code>dname</code>判断部门是否重复，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dept_df.duplicated(<span class="string">&#x27;dname&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dno</span><br><span class="line">10    False</span><br><span class="line">20    False</span><br><span class="line">30    False</span><br><span class="line">40    False</span><br><span class="line">50     True</span><br><span class="line">60     True</span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure>
<p>从上面的输出可以看到，<code>50</code>和<code>60</code>两个部门从部门名称上来看是重复的，如果要删除重复值，可以使用<code>drop_duplicates</code>方法，该方法的<code>keep</code>参数可以控制在遇到重复值时，保留第一项还是保留最后一项，或者多个重复项一个都不用保留，全部删除掉。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dept_df.drop_duplicates(<span class="string">&#x27;dname&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	dname	dloc</span><br><span class="line">dno		</span><br><span class="line">10	会计部	北京</span><br><span class="line">20	研发部	成都</span><br><span class="line">30	销售部	重庆</span><br><span class="line">40	运维部	天津</span><br></pre></td></tr></table></figure>
<p>将<code>keep</code>参数的值修改为<code>last</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dept_df.drop_duplicates(<span class="string">&#x27;dname&#x27;</span>, keep=<span class="string">&#x27;last&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	dname	dloc</span><br><span class="line">dno		</span><br><span class="line">10	会计部	北京</span><br><span class="line">40	运维部	天津</span><br><span class="line">50	研发部	上海</span><br><span class="line">60	销售部	长沙</span><br></pre></td></tr></table></figure>
<p>使用同样的方式，我们也可以清除<code>all_emp_df</code>中的重复数据，例如我们认定“ename”和“job”两个字段完全相同的就是重复数据，我们可以用下面的代码去除重复数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_emp_df.drop_duplicates([<span class="string">&#x27;ename&#x27;</span>, <span class="string">&#x27;job&#x27;</span>], inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：上面的<code>drop_duplicates</code>方法添加了参数<code>inplace=True</code>，该方法不会返回新的<code>DataFrame</code>对象，而是在原来的<code>DataFrame</code>对象上直接删除，大家可以查看<code>all_emp_df</code>看看是不是已经移除了重复的员工数据。</p>
</blockquote>
<h4 id="异常值"><a href="#异常值" class="headerlink" title="异常值"></a>异常值</h4><p>异常值在统计学上的全称是疑似异常值，也称作离群点（outlier），异常值的分析也称作离群点分析。异常值是指样本中出现的“极端值”，数据值看起来异常大或异常小，其分布明显偏离其余的观测值。实际工作中，有些异常值可能是由系统或人为原因造成的，但有些异常值却不是，它们能够重复且稳定的出现，属于正常的极端值，例如很多游戏产品中头部玩家的数据往往都是离群的极端值。所以，我们既不能忽视异常值的存在，也不能简单地把异常值从数据分析中剔除。重视异常值的出现，分析其产生的原因，常常成为发现问题进而改进决策的契机。</p>
<p>异常值的检测有Z-score 方法、IQR 方法、DBScan 聚类、孤立森林等，这里我们对前两种方法做一个简单的介绍。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://localhost/mypic/20211004192858.png" style="zoom:50%;"></p>
<p>如果数据服从正态分布，依据3σ法则，异常值被定义与平均值的偏差超过三倍标准差的值。在正态分布下，距离平均值3σ之外的值出现的概率为$ P(|x-\mu|&gt;3\sigma)&lt;0.003 $，属于小概率事件。如果数据不服从正态分布，那么可以用远离均值的多少倍的标准差来描述，这里的倍数就是Z-score。Z-score以标准差为单位去度量某一原始分数偏离平均值的距离，公式如下所示。</p>
<script type="math/tex; mode=display">
z = \frac {X - \mu} {\sigma} \\
|z| > 3</script><p>Z-score需要根据经验和实际情况来决定，通常把远离标准差<code>3</code>倍距离以上的数据点视为离群点，下面的代给出了如何通过Z-score方法检测异常值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">detect_outliers_zscore</span>(<span class="params">data, threshold=<span class="number">3</span></span>):</span><br><span class="line">    avg_value = np.mean(data)</span><br><span class="line">    std_value = np.std(data)</span><br><span class="line">    z_score = np.<span class="built_in">abs</span>((data - avg_value) / std_value)</span><br><span class="line">    <span class="keyword">return</span> data[z_score &gt; threshold]</span><br></pre></td></tr></table></figure>
<p>IQR 方法中的IQR（Inter-Quartile Range）代表四分位距离，即上四分位数（Q3）和下四分位数（Q1）的差值。通常情况下，可以认为小于 $ Q1 - 1.5 \times IQR $ 或大于 $ Q3 + 1.5 \times IQR $ 的就是异常值，而这种检测异常值的方法也是箱线图（后面会讲到）默认使用的方法。下面的代码给出了如何通过 IQR 方法检测异常值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">detect_outliers_iqr</span>(<span class="params">data, whis=<span class="number">1.5</span></span>):</span><br><span class="line">    q1, q3 = np.quantile(data, [<span class="number">0.25</span>, <span class="number">0.75</span>])</span><br><span class="line">    iqr = q3 - q1</span><br><span class="line">    lower, upper = q1 - whis * iqr, q3 + whis * iqr</span><br><span class="line">    <span class="keyword">return</span> data[(data &lt; lower) | (data &gt; upper)]</span><br></pre></td></tr></table></figure>
<p>如果要删除异常值，可以使用<code>DataFrame</code>对象的<code>drop</code>方法，该方法可以根据行索引或列索引删除指定的行或列。例如我们认为月薪低于<code>2000</code>或高于<code>8000</code>的是员工表中的异常值，可以用下面的代码删除对应的记录。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_df.drop(emp_df[(emp_df.sal &gt; <span class="number">8000</span>) | (emp_df.sal &lt; <span class="number">2000</span>)].index)</span><br></pre></td></tr></table></figure>
<p>如果要替换掉异常值，可以通过给单元格赋值的方式来实现，也可以使用<code>replace</code>方法将指定的值替换掉。例如我们要将月薪为<code>1800</code>和<code>9000</code>的替换为月薪的平均值，补贴为<code>800</code>的替换为<code>1000</code>，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">avg_sal = np.mean(emp_df.sal).astype(<span class="built_in">int</span>)</span><br><span class="line">emp_df.replace(&#123;<span class="string">&#x27;sal&#x27;</span>: [<span class="number">1800</span>, <span class="number">9000</span>], <span class="string">&#x27;comm&#x27;</span>: <span class="number">800</span>&#125;, &#123;<span class="string">&#x27;sal&#x27;</span>: avg_sal, <span class="string">&#x27;comm&#x27;</span>: <span class="number">1000</span>&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>对数据进行预处理也是一个很大的话题，它包含了对数据的拆解、变换、归约、离散化等操作。我们先来看看数据的拆解。如果数据表中的数据是一个时间日期，我们通常都需要从年、季度、月、日、星期、小时、分钟等维度对其进行拆解，如果时间日期是用字符串表示的，可以先通过<code>pandas</code>的<code>to_datetime</code>函数将其处理成时间日期。</p>
<p>在下面的例子中，我们先读取 Excel 文件，获取到一组销售数据，其中第一列就是销售日期，我们将其拆解为“月份”、“季度”和“星期”，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sales_df = pd.read_excel(</span><br><span class="line">    <span class="string">&#x27;data/2020年销售数据.xlsx&#x27;</span>,</span><br><span class="line">    usecols=[<span class="string">&#x27;销售日期&#x27;</span>, <span class="string">&#x27;销售区域&#x27;</span>, <span class="string">&#x27;销售渠道&#x27;</span>, <span class="string">&#x27;品牌&#x27;</span>, <span class="string">&#x27;销售额&#x27;</span>]</span><br><span class="line">)</span><br><span class="line">sales_df.info()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：上面代码中使用了相对路径来获取 Excel 文件，也就是说 Excel 文件在当前工作路径下名为<code>data</code>的文件夹中。如果需要上面例子中的 Excel 文件，可以通过下面的百度云盘地址进行获取。链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g</a>，提取码：e7b4。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;</span><br><span class="line">RangeIndex: 1945 entries, 0 to 1944</span><br><span class="line">Data columns (total 5 columns):</span><br><span class="line"> #   Column  Non-Null Count  Dtype         </span><br><span class="line">---  ------  --------------  -----         </span><br><span class="line"> 0   销售日期    1945 non-null   datetime64[ns]</span><br><span class="line"> 1   销售区域    1945 non-null   object        </span><br><span class="line"> 2   销售渠道    1945 non-null   object        </span><br><span class="line"> 3   品牌        1945 non-null   object        </span><br><span class="line"> 4   销售额      1945 non-null   int64         </span><br><span class="line">dtypes: datetime64[ns](1), int64(1), object(3)</span><br><span class="line">memory usage: 76.1+ KB</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sales_df[<span class="string">&#x27;月份&#x27;</span>] = sales_df[<span class="string">&#x27;销售日期&#x27;</span>].dt.month</span><br><span class="line">sales_df[<span class="string">&#x27;季度&#x27;</span>] = sales_df[<span class="string">&#x27;销售日期&#x27;</span>].dt.quarter</span><br><span class="line">sales_df[<span class="string">&#x27;星期&#x27;</span>] = sales_df[<span class="string">&#x27;销售日期&#x27;</span>].dt.weekday</span><br><span class="line">sales_df</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	    销售日期	 销售区域	销售渠道	品牌	  销售额	月份	季度	星期</span><br><span class="line">0	    2020-01-01	上海	     拼多多	 八匹马   8217	    1	 1	   2</span><br><span class="line">1	    2020-01-01	上海	     抖音	      八匹马	6351	 1	  1	    2</span><br><span class="line">2	    2020-01-01	上海	     天猫	      八匹马	14365	 1	  1	    2</span><br><span class="line">3	    2020-01-01	上海	     天猫       八匹马	2366	 1	  1     2</span><br><span class="line">4	    2020-01-01	上海	     天猫 	  皮皮虾	15189	 1	  1     2</span><br><span class="line">...     ...         ...        ...       ...      ...     ...  ...   ...</span><br><span class="line">1940    2020-12-30	北京	     京东	      花花姑娘 6994     12	 4	   2</span><br><span class="line">1941    2020-12-30	福建	     实体	      八匹马	7663	 12	  4	    2</span><br><span class="line">1942    2020-12-31	福建	     实体	      花花姑娘 14795    12	 4	   3</span><br><span class="line">1943    2020-12-31	福建	     抖音	      八匹马	3481	 12	  4	    3</span><br><span class="line">1944    2020-12-31	福建	     天猫	      八匹马	2673	 12	  4	    3</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，通过日期时间类型的<code>Series</code>对象的<code>dt</code> 属性，获得一个访问日期时间的对象，通过该对象的<code>year</code>、<code>month</code>、<code>quarter</code>、<code>hour</code>等属性，就可以获取到年、月、季度、小时等时间信息，获取到的仍然是一个<code>Series</code>对象，它包含了一组时间信息，所以我们通常也将这个<code>dt</code>属性称为“日期时间向量”。</p>
<p>我们再来说一说字符串类型的数据的处理，我们先从指定的 Excel 文件中读取某招聘网站的招聘数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jobs_df = pd.read_csv(</span><br><span class="line">    <span class="string">&#x27;data/某招聘网站招聘数据.csv&#x27;</span>,</span><br><span class="line">    usecols=[<span class="string">&#x27;city&#x27;</span>, <span class="string">&#x27;companyFullName&#x27;</span>, <span class="string">&#x27;positionName&#x27;</span>, <span class="string">&#x27;salary&#x27;</span>]</span><br><span class="line">)</span><br><span class="line">jobs_df.info()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：上面代码中使用了相对路径来获取 CSV 文件，也就是说 CSV 文件在当前工作路径下名为<code>data</code>的文件夹中。如果需要上面例子中的 CSV 文件，可以通过下面的百度云盘地址进行获取。链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g</a>，提取码：e7b4。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;</span><br><span class="line">RangeIndex: 3140 entries, 0 to 3139</span><br><span class="line">Data columns (total 4 columns):</span><br><span class="line"> #   Column           Non-Null Count  Dtype </span><br><span class="line">---  ------           --------------  ----- </span><br><span class="line"> 0   city             3140 non-null   object</span><br><span class="line"> 1   companyFullName  3140 non-null   object</span><br><span class="line"> 2   positionName     3140 non-null   object</span><br><span class="line"> 3   salary           3140 non-null   object</span><br><span class="line">dtypes: object(4)</span><br><span class="line">memory usage: 98.2+ KB</span><br></pre></td></tr></table></figure>
<p>查看前<code>5</code>条数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobs_df.head()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    city    companyFullName              positionName    salary</span><br><span class="line">0   北京	  达疆网络科技（上海）有限公司    数据分析岗       15k-30k</span><br><span class="line">1   北京	  北京音娱时光科技有限公司        数据分析        10k-18k</span><br><span class="line">2   北京	  北京千喜鹤餐饮管理有限公司	     数据分析        20k-30k</span><br><span class="line">3   北京	  吉林省海生电子商务有限公司	     数据分析        33k-50k</span><br><span class="line">4   北京	  韦博网讯科技（北京）有限公司	数据分析        10k-15k</span><br></pre></td></tr></table></figure>
<p>上面的数据表一共有<code>3140</code>条数据，但并非所有的职位都是“数据分析”的岗位，如果要筛选出数据分析的岗位，可以通过检查<code>positionName</code>字段是否包含“数据分析”这个关键词，这里需要模糊匹配，应该如何实现呢？我们可以先获取<code>positionName</code>列，因为这个<code>Series</code>对象的<code>dtype</code>是字符串，所以可以通过<code>str</code>属性获取对应的字符串向量，然后就可以利用我们熟悉的字符串的方法来对其进行操作，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jobs_df = jobs_df[jobs_df.positionName.<span class="built_in">str</span>.contains(<span class="string">&#x27;数据分析&#x27;</span>)]</span><br><span class="line">jobs_df.shape</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1515, 4)</span><br></pre></td></tr></table></figure>
<p>可以看出，筛选后的数据还有<code>1515</code>条。接下来，我们还需要对<code>salary</code>字段进行处理，如果我们希望统计所有岗位的平均工资或每个城市的平均工资，首先需要将用范围表示的工资处理成其中间值，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobs_df.salary.<span class="built_in">str</span>.extract(<span class="string">r&#x27;(\d+)[kK]?-(\d+)[kK]?&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：上面的代码通过正则表达式捕获组从字符串中抽取出两组数字，分别对应工资的下限和上限，对正则表达式不熟悉的读者，可以阅读我的知乎专栏“从零开始学Python”中的<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/158929767">《正则表达式的应用》</a>一文。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        0     1</span><br><span class="line">0	    15    30</span><br><span class="line">1	    10	  18</span><br><span class="line">2       20    30</span><br><span class="line">3       33    50</span><br><span class="line">4       10    15</span><br><span class="line">...     ...   ...</span><br><span class="line">3065    8     10</span><br><span class="line">3069    6     10</span><br><span class="line">3070    2     4</span><br><span class="line">3071    6     12</span><br><span class="line">3088    8     12</span><br></pre></td></tr></table></figure>
<p>需要提醒大家的是，抽取出来的两列数据都是字符串类型的值，我们需要将其转换成<code>int</code>类型，才能计算平均值，对应的方法是<code>DataFrame</code>对象的<code>applymap</code>方法，该方法的参数是一个函数，而该函数会作用于<code>DataFrame</code>中的每个元素。完成这一步之后，我们就可以使用<code>apply</code>方法将上面的<code>DataFrame</code>处理成中间值，<code>apply</code>方法的参数也是一个函数，可以通过指定<code>axis</code>参数使其作用于<code>DataFrame</code> 对象的行或列，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">temp_df = jobs_df.salary.<span class="built_in">str</span>.extract(<span class="string">r&#x27;(\d+)[kK]?-(\d+)[kK]?&#x27;</span>).applymap(<span class="built_in">int</span>)</span><br><span class="line">temp_df.apply(np.mean, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p> 输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0       22.5</span><br><span class="line">1       14.0</span><br><span class="line">2       25.0</span><br><span class="line">3       41.5</span><br><span class="line">4       12.5</span><br><span class="line">        ... </span><br><span class="line">3065    9.0</span><br><span class="line">3069    8.0</span><br><span class="line">3070    3.0</span><br><span class="line">3071    9.0</span><br><span class="line">3088    10.0</span><br><span class="line">Length: 1515, dtype: float64</span><br></pre></td></tr></table></figure>
<p>接下来，我们可以用上面的结果替换掉原来的<code>salary</code>列或者增加一个新的列来表示职位对应的工资，完整的代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">temp_df = jobs_df.salary.<span class="built_in">str</span>.extract(<span class="string">r&#x27;(\d+)[kK]?-(\d+)[kK]?&#x27;</span>).applymap(<span class="built_in">int</span>)</span><br><span class="line">jobs_df[<span class="string">&#x27;salary&#x27;</span>] = temp_df.apply(np.mean, axis=<span class="number">1</span>)</span><br><span class="line">jobs_df.head()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    city    companyFullName              positionName    salary</span><br><span class="line">0   北京	  达疆网络科技（上海）有限公司    数据分析岗       22.5</span><br><span class="line">1   北京	  北京音娱时光科技有限公司        数据分析        14.0</span><br><span class="line">2   北京	  北京千喜鹤餐饮管理有限公司	     数据分析        25.0</span><br><span class="line">3   北京	  吉林省海生电子商务有限公司	     数据分析        41.5</span><br><span class="line">4   北京	  韦博网讯科技（北京）有限公司	数据分析        12.5</span><br></pre></td></tr></table></figure>
<p><code>applymap</code>和<code>apply</code>两个方法在数据预处理的时候经常用到，<code>Series</code>对象也有<code>apply</code>方法，也是用于数据的预处理，但是<code>DataFrame</code>对象还有一个名为<code>transform</code> 的方法，也是通过传入的函数对数据进行变换，类似<code>Series</code>对象的<code>map</code>方法。需要强调的是，<code>apply</code>方法具有归约效果的，简单的说就是能将较多的数据处理成较少的数据或一条数据；而<code>transform</code>方法没有归约效果，只能对数据进行变换，原来有多少条数据，处理后还是有多少条数据。</p>
<p>如果要对数据进行深度的分析和挖掘，字符串、日期时间这样的非数值类型都需要处理成数值，因为非数值类型没有办法计算相关性，也没有办法进行$\chi^2$检验等操作。对于字符串类型，通常可以其分为以下三类，再进行对应的处理。</p>
<ol>
<li>有序变量（Ordinal Variable）：字符串表示的数据有顺序关系，那么可以对字符串进行序号化处理。</li>
<li>分类变量（Categorical Variable）/ 名义变量（Nominal Variable）：字符串表示的数据没有大小关系和等级之分，那么就可以使用独热编码的方式处理成哑变量（虚拟变量）矩阵。</li>
<li>定距变量（Scale Variable）：字符串本质上对应到一个有大小高低之分的数据，而且可以进行加减运算，那么只需要将字符串处理成对应的数值即可。</li>
</ol>
<p>对于第1类和第3类，我们可以用上面提到的<code>apply</code>或<code>transform</code>方法来处理，也可以利用<code>scikit-learn</code>中的<code>OrdinalEncoder</code>处理第1类字符串，这个我们在后续的课程中会讲到。对于第2类字符串，可以使用<code>pandas</code>的<code>get_dummies()</code>函数来生成哑变量（虚拟变量）矩阵，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">persons_df = pd.DataFrame(</span><br><span class="line">    data=&#123;</span><br><span class="line">        <span class="string">&#x27;姓名&#x27;</span>: [<span class="string">&#x27;关羽&#x27;</span>, <span class="string">&#x27;张飞&#x27;</span>, <span class="string">&#x27;赵云&#x27;</span>, <span class="string">&#x27;马超&#x27;</span>, <span class="string">&#x27;黄忠&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;职业&#x27;</span>: [<span class="string">&#x27;医生&#x27;</span>, <span class="string">&#x27;医生&#x27;</span>, <span class="string">&#x27;程序员&#x27;</span>, <span class="string">&#x27;画家&#x27;</span>, <span class="string">&#x27;教师&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;学历&#x27;</span>: [<span class="string">&#x27;研究生&#x27;</span>, <span class="string">&#x27;大专&#x27;</span>, <span class="string">&#x27;研究生&#x27;</span>, <span class="string">&#x27;高中&#x27;</span>, <span class="string">&#x27;本科&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">persons_df</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	姓名	职业	学历</span><br><span class="line">0	关羽	医生	研究生</span><br><span class="line">1	张飞	医生	大专</span><br><span class="line">2	赵云	程序员	研究生</span><br><span class="line">3	马超	画家	高中</span><br><span class="line">4	黄忠	教师	本科</span><br></pre></td></tr></table></figure>
<p>将职业处理成哑变量矩阵。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.get_dummies(persons_df[<span class="string">&#x27;职业&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    医生 教师  画家  程序员</span><br><span class="line">0	1    0    0    0</span><br><span class="line">1	1    0    0    0</span><br><span class="line">2	0    0    0    1</span><br><span class="line">3	0    0    1    0</span><br><span class="line">4	0    1    0    0</span><br></pre></td></tr></table></figure>
<p>将学历处理成大小不同的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handle_education</span>(<span class="params">x</span>):</span><br><span class="line">    edu_dict = &#123;<span class="string">&#x27;高中&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;大专&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;本科&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;研究生&#x27;</span>: <span class="number">10</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> edu_dict.get(x, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">persons_df[<span class="string">&#x27;学历&#x27;</span>].apply(handle_education)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0    10</span><br><span class="line">1     3</span><br><span class="line">2    10</span><br><span class="line">3     1</span><br><span class="line">4     5</span><br><span class="line">Name: 学历, dtype: int64</span><br></pre></td></tr></table></figure>
<p>我们再来说说数据离散化。离散化也叫分箱，如果变量的取值是连续值，那么它的取值有无数种可能，在进行数据分组的时候就会非常的不方便，这个时候将连续变量离散化就显得非常重要。之所以把离散化叫做分箱，是因为我们可以预先设置一些箱子，每个箱子代表了数据取值的范围，这样就可以将连续的值分配到不同的箱子中，从而实现离散化。下面的例子读取了2018年北京积分落户数据，我们可以根据落户积分对数据进行分组，具体的做法如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">luohu_df = pd.read_csv(<span class="string">&#x27;data/2018年北京积分落户数据.csv&#x27;</span>, index_col=<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">luohu_df.score.describe()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">count    6019.000000</span><br><span class="line">mean       95.654552</span><br><span class="line">std         4.354445</span><br><span class="line">min        90.750000</span><br><span class="line">25%        92.330000</span><br><span class="line">50%        94.460000</span><br><span class="line">75%        97.750000</span><br><span class="line">max       122.590000</span><br><span class="line">Name: score, dtype: float64</span><br></pre></td></tr></table></figure>
<p>可以看出，落户积分的最大值是<code>122.59</code>，最小值是<code>90.75</code>，那么我们可以构造一个从<code>90</code>分到<code>125</code>分，每<code>5</code>分一组的<code>7</code>个箱子，<code>pandas</code>的<code>cut</code>函数可以帮助我们首先数据分箱，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bins = np.arange(<span class="number">90</span>, <span class="number">126</span>, <span class="number">5</span>)</span><br><span class="line">pd.cut(luohu_df.score, bins, right=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：<code>cut</code>函数的<code>right</code>参数默认值为<code>True</code>，表示箱子左开右闭；修改为<code>False</code>可以让箱子的右边界为开区间，左边界为闭区间，大家看看下面的输出就明白了。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">1       [120, 125)</span><br><span class="line">2       [120, 125)</span><br><span class="line">3       [115, 120)</span><br><span class="line">4       [115, 120)</span><br><span class="line">5       [115, 120)</span><br><span class="line">           ...    </span><br><span class="line">6015      [90, 95)</span><br><span class="line">6016      [90, 95)</span><br><span class="line">6017      [90, 95)</span><br><span class="line">6018      [90, 95)</span><br><span class="line">6019      [90, 95)</span><br><span class="line">Name: score, Length: 6019, dtype: category</span><br><span class="line">Categories (7, interval[int64, left]): [[90, 95) &lt; [95, 100) &lt; [100, 105) &lt; [105, 110) &lt; [110, 115) &lt; [115, 120) &lt; [120, 125)]</span><br></pre></td></tr></table></figure>
<p>我们可以根据分箱的结果对数据进行分组，然后使用聚合函数对每个组进行统计，这是数据分析中经常用到的操作，下一个章节会为大家介绍。除此之外，<code>pandas</code>还提供了一个名为<code>qcut</code>的函数，可以指定分位数对数据进行分箱，有兴趣的读者可以自行研究。</p>
<h2 id="深入浅出pandas-4"><a href="#深入浅出pandas-4" class="headerlink" title="深入浅出pandas-4"></a>深入浅出pandas-4</h2><h3 id="数据透视"><a href="#数据透视" class="headerlink" title="数据透视"></a>数据透视</h3><p>经过前面的学习，我们已经将数据准备就绪而且变成了我们想要的样子，接下来就是最为重要的数据透视阶段了。当我们拿到一大堆数据的时候，如何从数据中迅速的解读出有价值的信息，把繁杂的数据变成容易解读的统计图表并再此基础上产生业务洞察，这就是数据分析要解决的核心问题。</p>
<h4 id="获取描述性统计信息"><a href="#获取描述性统计信息" class="headerlink" title="获取描述性统计信息"></a>获取描述性统计信息</h4><p>首先，我们可以获取数据的描述性统计信息，通过描述性统计信息，我们可以了解数据的集中趋势和离散趋势。</p>
<p>例如，我们有如下所示的学生成绩表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scores = np.random.randint(<span class="number">50</span>, <span class="number">101</span>, (<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line">names = (<span class="string">&#x27;关羽&#x27;</span>, <span class="string">&#x27;张飞&#x27;</span>, <span class="string">&#x27;赵云&#x27;</span>, <span class="string">&#x27;马超&#x27;</span>, <span class="string">&#x27;黄忠&#x27;</span>)</span><br><span class="line">courses = (<span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>)</span><br><span class="line">df = pd.DataFrame(data=scores, columns=courses, index=names)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     语文   数学   英语</span><br><span class="line">关羽  96    72    73</span><br><span class="line">张飞  72    70	97</span><br><span class="line">赵云  74    51	79</span><br><span class="line">马超  100   54	54</span><br><span class="line">黄忠  89    100	88</span><br></pre></td></tr></table></figure>
<p>我们可以通过<code>DataFrame</code>对象的方法<code>mean</code>、<code>max</code>、<code>min</code>、<code>std</code>、<code>var</code>等方法分别获取每个学生或每门课程的平均分、最高分、最低分、标准差、方差等信息，也可以直接通过<code>describe</code>方法直接获取描述性统计信息，代码如下所示。</p>
<p>计算每门课程成绩的平均分。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.mean()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语文    86.2</span><br><span class="line">数学    69.4</span><br><span class="line">英语    78.2</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>计算每个学生成绩的平均分。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.mean(axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">关羽    80.333333</span><br><span class="line">张飞    79.666667</span><br><span class="line">赵云    68.000000</span><br><span class="line">马超    69.333333</span><br><span class="line">黄忠    92.333333</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>计算每门课程成绩的方差。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.var()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语文    161.2</span><br><span class="line">数学    379.8</span><br><span class="line">英语    265.7</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：通过方差可以看出，数学成绩波动最大，两极分化可能更严重。</p>
</blockquote>
<p>获取每门课程的描述性统计信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.describe()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        语文        数学         英语</span><br><span class="line">count   5.000000	5.000000	5.000000</span><br><span class="line">mean    86.200000	69.400000	78.200000</span><br><span class="line">std     12.696456	19.488458	16.300307</span><br><span class="line">min     72.000000	51.000000	54.000000</span><br><span class="line">25%     74.000000	54.000000	73.000000</span><br><span class="line">50%     89.000000	70.000000	79.000000</span><br><span class="line">75%     96.000000	72.000000	88.000000</span><br><span class="line">max     100.000000	100.000000	97.000000</span><br></pre></td></tr></table></figure>
<h4 id="排序和取头部值"><a href="#排序和取头部值" class="headerlink" title="排序和取头部值"></a>排序和取头部值</h4><p>如果需要对数据进行排序，可以使用<code>DataFrame</code>对象的<code>sort_values</code>方法，该方法的<code>by</code>参数可以指定根据哪个列或哪些列进行排序，而<code>ascending</code>参数可以指定升序或是降序。例如，下面的代码展示了如何将学生表按语文成绩排降序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.sort_values(by=<span class="string">&#x27;语文&#x27;</span>, ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      语文   数学   英语</span><br><span class="line">马超	100    54	  54</span><br><span class="line">关羽	96     72     73</span><br><span class="line">黄忠	89     100    88</span><br><span class="line">赵云	74     51     79</span><br><span class="line">张飞	72     70     97</span><br></pre></td></tr></table></figure>
<p>如果<code>DataFrame</code>数据量很大，排序将是一个非常耗费时间的操作。有的时候我们只需要获得排前N名或后N名的数据，这个时候其实没有必要对整个数据进行排序，而是直接利用堆结构找出Top-N的数据。<code>DataFrame</code>的<code>nlargest</code>和<code>nsmallest</code>方法就提供对Top-N操作的支持，代码如下所示。</p>
<p>找出语文成绩前3名的学生信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.nlargest(<span class="number">3</span>, <span class="string">&#x27;语文&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      语文   数学   英语</span><br><span class="line">马超	100    54	  54</span><br><span class="line">关羽	96     72     73</span><br><span class="line">黄忠	89     100    88</span><br></pre></td></tr></table></figure>
<p>找出数学成绩最低的3名学生的信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.nsmallest(<span class="number">3</span>, <span class="string">&#x27;数学&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      语文  数学  英语</span><br><span class="line">赵云  74    51	79</span><br><span class="line">马超  100   54	54</span><br><span class="line">张飞  72    70	97</span><br></pre></td></tr></table></figure>
<h4 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h4><p>我们先从之前使用过的 Excel 文件中读取2020年销售数据，然后再为大家演示如何进行分组聚合操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_excel(<span class="string">&#x27;data/2020年销售数据.xlsx&#x27;</span>)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    销售日期	 销售区域   销售渠道  销售订单     品牌    售价  销售数量</span><br><span class="line">0   2020-01-01  上海       拼多多    182894-455  八匹马  99    83</span><br><span class="line">1   2020-01-01  上海       抖音      205635-402  八匹马  219   29</span><br><span class="line">2   2020-01-01  上海       天猫      205654-021  八匹马  169   85</span><br><span class="line">3   2020-01-01  上海       天猫      205654-519  八匹马  169   14</span><br><span class="line">4   2020-01-01  上海       天猫      377781-010  皮皮虾  249   61</span><br></pre></td></tr></table></figure>
<p>如果我们要统计每个销售区域的销售总额，可以先通过“售价”和“销售数量”计算出销售额，为<code>DataFrame</code>添加一个列，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;销售额&#x27;</span>] = df[<span class="string">&#x27;售价&#x27;</span>] * df[<span class="string">&#x27;销售数量&#x27;</span>]</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    销售日期	 销售区域   销售渠道  销售订单     品牌    售价  销售数量  销售额</span><br><span class="line">0   2020-01-01  上海       拼多多    182894-455  八匹马  99    83        8217</span><br><span class="line">1   2020-01-01  上海       抖音      205635-402  八匹马  219   29        6351</span><br><span class="line">2   2020-01-01  上海       天猫      205654-021  八匹马  169   85        14365</span><br><span class="line">3   2020-01-01  上海       天猫      205654-519  八匹马  169   14        2366</span><br><span class="line">4   2020-01-01  上海       天猫      377781-010  皮皮虾  249   61        15189</span><br></pre></td></tr></table></figure>
<p>然后再根据“销售区域”列对数据进行分组，这里我们使用的是<code>DataFrame</code>对象的<code>groupby</code>方法。分组之后，我们取“销售额”这个列在分组内进行求和处理，代码和结果如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">&#x27;销售区域&#x27;</span>).销售额.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">销售区域</span><br><span class="line">上海    11610489</span><br><span class="line">北京    12477717</span><br><span class="line">安徽      895463</span><br><span class="line">广东     1617949</span><br><span class="line">江苏     2304380</span><br><span class="line">浙江      687862</span><br><span class="line">福建    10178227</span><br><span class="line">Name: 销售额, dtype: int64</span><br></pre></td></tr></table></figure>
<p>如果我们要统计每个月的销售总额，我们可以将“销售日期”作为groupby`方法的参数，当然这里需要先将“销售日期”处理成月，代码和结果如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(df[<span class="string">&#x27;销售日期&#x27;</span>].dt.month).销售额.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">销售日期</span><br><span class="line">1     5409855</span><br><span class="line">2     4608455</span><br><span class="line">3     4164972</span><br><span class="line">4     3996770</span><br><span class="line">5     3239005</span><br><span class="line">6     2817936</span><br><span class="line">7     3501304</span><br><span class="line">8     2948189</span><br><span class="line">9     2632960</span><br><span class="line">10    2375385</span><br><span class="line">11    2385283</span><br><span class="line">12    1691973</span><br><span class="line">Name: 销售额, dtype: int64</span><br></pre></td></tr></table></figure>
<p>接下来我们将难度升级，统计每个销售区域每个月的销售总额，这又该如何处理呢？事实上，<code>groupby</code>方法的第一个参数可以是一个列表，列表中可以指定多个分组的依据，大家看看下面的代码和输出结果就明白了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby([<span class="string">&#x27;销售区域&#x27;</span>, df[<span class="string">&#x27;销售日期&#x27;</span>].dt.month]).销售额.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">销售区域  销售日期</span><br><span class="line">上海    1       1679125</span><br><span class="line">        2       1689527</span><br><span class="line">        3       1061193</span><br><span class="line">        4       1082187</span><br><span class="line">        5        841199</span><br><span class="line">        6        785404</span><br><span class="line">        7        863906</span><br><span class="line">        8        734937</span><br><span class="line">        9       1107693</span><br><span class="line">        10       412108</span><br><span class="line">       11       825169</span><br><span class="line">       12       528041</span><br><span class="line">北京    1       1878234</span><br><span class="line">        2       1807787</span><br><span class="line">        3       1360666</span><br><span class="line">        4       1205989</span><br><span class="line">        5        807300</span><br><span class="line">        6       1216432</span><br><span class="line">        7       1219083</span><br><span class="line">        8        645727</span><br><span class="line">        9        390077</span><br><span class="line">        10       671608</span><br><span class="line">        11       678668</span><br><span class="line">        12       596146</span><br><span class="line">安徽    4        341308</span><br><span class="line">        5        554155</span><br><span class="line">广东    3        388180</span><br><span class="line">        8        469390</span><br><span class="line">        9        365191</span><br><span class="line">        11       395188</span><br><span class="line">江苏    4        537079</span><br><span class="line">        7        841032</span><br><span class="line">        10       710962</span><br><span class="line">        12       215307</span><br><span class="line">浙江    3        248354</span><br><span class="line">        8        439508</span><br><span class="line">福建    1       1852496</span><br><span class="line">        2       1111141</span><br><span class="line">        3       1106579</span><br><span class="line">        4        830207</span><br><span class="line">        5       1036351</span><br><span class="line">        6        816100</span><br><span class="line">        7        577283</span><br><span class="line">        8        658627</span><br><span class="line">        9        769999</span><br><span class="line">        10       580707</span><br><span class="line">        11       486258</span><br><span class="line">        12       352479</span><br><span class="line">Name: 销售额, dtype: int64</span><br></pre></td></tr></table></figure>
<p>如果希望统计出每个区域的销售总额以及每个区域单笔金额的最高和最低，我们可以在<code>DataFrame</code>或<code>Series</code>对象上使用<code>agg</code>方法并指定多个聚合函数，代码和结果如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">&#x27;销售区域&#x27;</span>).销售额.agg([<span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;min&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">           sum     max   min</span><br><span class="line">销售区域                        </span><br><span class="line">上海    11610489  116303   948</span><br><span class="line">北京    12477717  133411   690</span><br><span class="line">安徽      895463   68502  1683</span><br><span class="line">广东     1617949  120807   990</span><br><span class="line">江苏     2304380  114312  1089</span><br><span class="line">浙江      687862   90909  3927</span><br><span class="line">福建    10178227   87527   897</span><br></pre></td></tr></table></figure>
<p>如果希望自定义聚合后的列的名字，可以使用如下所示的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">&#x27;销售区域&#x27;</span>).销售额.agg(销售总额=<span class="string">&#x27;sum&#x27;</span>, 单笔最高=<span class="string">&#x27;max&#x27;</span>, 单笔最低=<span class="string">&#x27;min&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          销售总额    单笔最高  单笔最低</span><br><span class="line">销售区域                        </span><br><span class="line">上海      11610489     116303     948</span><br><span class="line">北京      12477717     133411     690</span><br><span class="line">安徽        895463      68502    1683</span><br><span class="line">广东       1617949     120807     990</span><br><span class="line">江苏       2304380     114312    1089</span><br><span class="line">浙江        687862      90909    3927</span><br><span class="line">福建      10178227      87527     897</span><br></pre></td></tr></table></figure>
<p>如果需要对多个列使用不同的聚合函数，例如“统计每个销售区域销售额的总和以及销售数量的最低值和最高值”，我们可以按照下面的方式来操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">&#x27;销售区域&#x27;</span>)[[<span class="string">&#x27;销售额&#x27;</span>, <span class="string">&#x27;销售数量&#x27;</span>]].agg(&#123;</span><br><span class="line">    <span class="string">&#x27;销售额&#x27;</span>: <span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;销售数量&#x27;</span>: [<span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;min&#x27;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">           销售额  销售数量    </span><br><span class="line">           sum    max min</span><br><span class="line">销售区域                   </span><br><span class="line">上海    11610489  100  10</span><br><span class="line">北京    12477717  100  10</span><br><span class="line">安徽      895463   98  16</span><br><span class="line">广东     1617949   98  10</span><br><span class="line">江苏     2304380  100  11</span><br><span class="line">浙江      687862   95  20</span><br><span class="line">福建    10178227  100  10</span><br></pre></td></tr></table></figure>
<h4 id="透视表和交叉表"><a href="#透视表和交叉表" class="headerlink" title="透视表和交叉表"></a>透视表和交叉表</h4><p>上面的例子中，“统计每个销售区域每个月的销售总额”会产生一个看起来很长的结果，在实际工作中我们通常把那些行很多列很少的表成为“窄表”，如果我们不想得到这样的一个“窄表”，可以使用<code>DataFrame</code>的<code>pivot_table</code>方法或者是<code>pivot_table</code>函数来生成透视表。透视表的本质就是对数据进行分组聚合操作，<strong>根据 A 列对 B 列进行统计</strong>，如果大家有使用 Excel 的经验，相信对透视表这个概念一定不会陌生。例如，我们要“统计每个销售区域的销售总额”，那么“销售区域”就是我们的 A 列，而“销售额”就是我们的 B 列，在<code>pivot_table</code>函数中分别对应<code>index</code>和<code>values</code>参数，这两个参数都可以是单个列或者多个列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.pivot_table(df, index=<span class="string">&#x27;销售区域&#x27;</span>, values=<span class="string">&#x27;销售额&#x27;</span>, aggfunc=<span class="string">&#x27;sum&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">           销售额</span><br><span class="line">销售区域          </span><br><span class="line">上海    11610489</span><br><span class="line">北京    12477717</span><br><span class="line">安徽      895463</span><br><span class="line">广东     1617949</span><br><span class="line">江苏     2304380</span><br><span class="line">浙江      687862</span><br><span class="line">福建    10178227</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：上面的结果操作跟之前用<code>groupby</code>的方式得到的结果有一些区别，<code>groupby</code>操作后，如果对单个列进行聚合，得到的结果是一个<code>Series</code>对象，而上面的结果是一个<code>DataFrame</code> 对象。</p>
</blockquote>
<p>如果要统计每个销售区域每个月的销售总额，也可以使用<code>pivot_table</code>函数，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;月份&#x27;</span>] = df[<span class="string">&#x27;销售日期&#x27;</span>].dt.month</span><br><span class="line">pd.pivot_table(df, index=[<span class="string">&#x27;销售区域&#x27;</span>, <span class="string">&#x27;月份&#x27;</span>], values=<span class="string">&#x27;销售额&#x27;</span>, aggfunc=<span class="string">&#x27;sum&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上面的操作结果是一个<code>DataFrame</code>，但也是一个长长的“窄表”，如果希望做成一个行比较少列比较多的“宽表”，可以将<code>index</code>参数中的列放到<code>columns</code>参数中，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.pivot_table(df, index=<span class="string">&#x27;销售区域&#x27;</span>, columns=<span class="string">&#x27;月份&#x27;</span>, values=<span class="string">&#x27;销售额&#x27;</span>, aggfunc=<span class="string">&#x27;sum&#x27;</span>, fill_value=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：<code>pivot_table</code>函数的<code>fill_value=0</code>会将空值处理为<code>0</code>。</p>
</blockquote>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/pivot_table_1.png" style="zoom:50%;"></p>
<p>使用<code>pivot_table</code>函数时，还可以通过添加<code>margins</code>和<code>margins_name</code>参数对分组聚合的结果做一个汇总，具体的操作和效果如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.pivot_table(df, index=<span class="string">&#x27;销售区域&#x27;</span>, columns=<span class="string">&#x27;月份&#x27;</span>, values=<span class="string">&#x27;销售额&#x27;</span>, aggfunc=<span class="string">&#x27;sum&#x27;</span>, fill_value=<span class="number">0</span>, margins=<span class="literal">True</span>, margins_name=<span class="string">&#x27;总计&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/pivot_table_2.png" style="zoom:50%;"></p>
<p>交叉表就是一种特殊的透视表，它不需要先构造一个<code>DataFrame</code>对象，而是直接通过数组或<code>Series</code>对象指定两个或多个因素进行运算得到统计结果。例如，我们要统计每个销售区域的销售总额，也可以按照如下所示的方式来完成，我们先准备三组数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sales_area, sales_month, sales_amount = df[<span class="string">&#x27;销售区域&#x27;</span>], df[<span class="string">&#x27;月份&#x27;</span>], df[<span class="string">&#x27;销售额&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>使用<code>crosstab</code>函数生成交叉表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.crosstab(index=sales_area, columns=sales_month, values=sales_amount, aggfunc=<span class="string">&#x27;sum&#x27;</span>).fillna(<span class="number">0</span>).astype(<span class="string">&#x27;i8&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：上面的代码使用了<code>DataFrame</code>对象的<code>fillna</code>方法将空值处理为0，再使用<code>astype</code>方法将数据类型处理成整数。</p>
</blockquote>
<h3 id="数据呈现"><a href="#数据呈现" class="headerlink" title="数据呈现"></a>数据呈现</h3><p>一图胜千言，我们对数据进行透视的结果，最终要通过图表的方式呈现出来，因为图表具有极强的表现力，能够让我们迅速的解读数据中隐藏的价值。和<code>Series</code>一样，<code>DataFrame</code>对象提供了<code>plot</code>方法来支持绘图，底层仍然是通过<code>matplotlib</code>库实现图表的渲染。关于<code>matplotlib</code>的内容，我们在下一个章节进行详细的探讨，这里我们只简单的讲解<code>plot</code>方法的用法。 </p>
<p>例如，我们想通过一张柱状图来比较“每个销售区域的销售总额”，可以直接在透视表上使用<code>plot</code>方法生成柱状图。我们先导入<code>matplotlib.pyplot</code>模块，通过修改绘图的参数使其支持中文显示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = <span class="string">&#x27;FZJKai-Z03S&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：上面的<code>FZJKai-Z03S</code>是我电脑上已经安装的一种支持中文的字体的名称，字体的名称可以通过查看用户主目录下<code>.matplotlib</code>文件夹下名为<code>fontlist-v330.json</code>的文件来获得，而这个文件在执行上面的命令后就会生成。</p>
</blockquote>
<p>使用魔法指令配置生成矢量图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%config InlineBackend.figure_format = <span class="string">&#x27;svg&#x27;</span></span><br></pre></td></tr></table></figure>
<p>绘制“每个销售区域销售总额”的柱状图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">temp = pd.pivot_table(df, index=<span class="string">&#x27;销售区域&#x27;</span>, values=<span class="string">&#x27;销售额&#x27;</span>, aggfunc=<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line">temp.plot(figsize=(<span class="number">8</span>, <span class="number">4</span>), kind=<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">plt.xticks(rotation=<span class="number">0</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：上面的第3行代码会将横轴刻度上的文字旋转到0度，第4行代码会显示图像。</p>
</blockquote>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/sales_bar_graph.png" style="zoom:45%;"></p>
<p>如果要绘制饼图，可以修改<code>plot</code>方法的<code>kind</code>参数为<code>pie</code>，然后使用定制饼图的参数对图表加以定制，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">temp.sort_values(by=<span class="string">&#x27;销售额&#x27;</span>, ascending=<span class="literal">False</span>).plot(</span><br><span class="line">    figsize=(<span class="number">6</span>, <span class="number">6</span>),</span><br><span class="line">    kind=<span class="string">&#x27;pie&#x27;</span>,</span><br><span class="line">    y=<span class="string">&#x27;销售额&#x27;</span>,</span><br><span class="line">    ylabel=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    autopct=<span class="string">&#x27;%.2f%%&#x27;</span>,</span><br><span class="line">    pctdistance=<span class="number">0.8</span>,</span><br><span class="line">    wedgeprops=<span class="built_in">dict</span>(linewidth=<span class="number">1</span>, width=<span class="number">0.35</span>),</span><br><span class="line">    legend=<span class="literal">False</span></span><br><span class="line">)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/sales_pie_graph.png" style="zoom:35%;"></p>
<h2 id="深入浅出pandas-5"><a href="#深入浅出pandas-5" class="headerlink" title="深入浅出pandas-5"></a>深入浅出pandas-5</h2><p>我们再来补充一些使用<code>DataFrame</code>做数据分析时会使用到的操作，这些操作不仅常见而且也非常重要。</p>
<h3 id="计算同比环比"><a href="#计算同比环比" class="headerlink" title="计算同比环比"></a>计算同比环比</h3><p>我们之前讲过一个统计月度销售额的例子，我们可以通过<code>groupby</code>方法做分组聚合，也可以通过<code>pivot_table</code>生成透视表，如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sales_df = pd.read_excel(<span class="string">&#x27;data/2020年销售数据.xlsx&#x27;</span>)</span><br><span class="line">sales_df[<span class="string">&#x27;月份&#x27;</span>] = sales_df.销售日期.dt.month</span><br><span class="line">sales_df[<span class="string">&#x27;销售额&#x27;</span>] = sales_df.售价 * sales_df.销售数量</span><br><span class="line">result_df = sales_df.pivot_table(index=<span class="string">&#x27;月份&#x27;</span>, values=<span class="string">&#x27;销售额&#x27;</span>, aggfunc=<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line">result_df.rename(columns=&#123;<span class="string">&#x27;销售额&#x27;</span>: <span class="string">&#x27;本月销售额&#x27;</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">result_df</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">      本月销售额</span><br><span class="line">月份         </span><br><span class="line">1       5409855</span><br><span class="line">2       4608455</span><br><span class="line">3       4164972</span><br><span class="line">4       3996770</span><br><span class="line">5       3239005</span><br><span class="line">6       2817936</span><br><span class="line">7       3501304</span><br><span class="line">8       2948189</span><br><span class="line">9       2632960</span><br><span class="line">10      2375385</span><br><span class="line">11      2385283</span><br><span class="line">12      1691973</span><br></pre></td></tr></table></figure>
<p>在得到月度销售额之后，如果我们需要计算月环比，这里有两种方案。第一种方案是我们可以使用<code>shift</code>方法对数据进行移动，将上一个月的数据与本月数据对齐，然后通过<code>(本月销售额 - 上月销售额) / 上月销售额</code>来计算月环比，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result_df[<span class="string">&#x27;上月销售额&#x27;</span>] = result_df.本月销售额.shift(<span class="number">1</span>)</span><br><span class="line">result_df</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">      本月销售额      上月销售额</span><br><span class="line">月份                    </span><br><span class="line">1       5409855            NaN</span><br><span class="line">2       4608455      5409855.0</span><br><span class="line">3       4164972      4608455.0</span><br><span class="line">4       3996770      4164972.0</span><br><span class="line">5       3239005      3996770.0</span><br><span class="line">6       2817936      3239005.0</span><br><span class="line">7       3501304      2817936.0</span><br><span class="line">8       2948189      3501304.0</span><br><span class="line">9       2632960      2948189.0</span><br><span class="line">10      2375385      2632960.0</span><br><span class="line">11      2385283      2375385.0</span><br><span class="line">12      1691973      2385283.0</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>shift</code>方法的参数为<code>1</code>表示将数据向下移动一个单元，当然我们可以使用参数<code>-1</code>将数据向上移动一个单元。相信大家能够想到，如果我们有更多年份的数据，我们可以将参数设置为<code>12</code>，这样就可以计算今年的每个月与去年的每个月之间的同比。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result_df[<span class="string">&#x27;环比&#x27;</span>] = (result_df.本月销售额 - result_df.上月销售额) / result_df.上月销售额</span><br><span class="line">result_df.style.<span class="built_in">format</span>(</span><br><span class="line">    formatter=&#123;<span class="string">&#x27;上月销售额&#x27;</span>: <span class="string">&#x27;&#123;:.0f&#125;&#x27;</span>, <span class="string">&#x27;环比&#x27;</span>: <span class="string">&#x27;&#123;:.2%&#125;&#x27;</span>&#125;,</span><br><span class="line">    na_rep=<span class="string">&#x27;--------&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">      本月销售额      上月销售额         环比</span><br><span class="line">月份                    </span><br><span class="line">1       5409855       --------     -------- </span><br><span class="line">2       4608455        5409855      -14.81%     </span><br><span class="line">3       4164972        4608455       -9.62%</span><br><span class="line">4       3996770        4164972       -4.04%</span><br><span class="line">5       3239005        3996770      -18.96%</span><br><span class="line">6       2817936        3239005      -13.00%</span><br><span class="line">7       3501304        2817936       24.25%</span><br><span class="line">8       2948189        3501304      -15.80%</span><br><span class="line">9       2632960        2948189      -10.69%</span><br><span class="line">10      2375385        2632960       -9.78%</span><br><span class="line">11      2385283        2375385        0.42%</span><br><span class="line">12      1691973        2385283      -29.07%</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：使用 JupyterLab 时，可以通过<code>DataFrame</code>对象的<code>style</code>属性在网页中对其进行渲染，上面的代码通过<code>Styler</code>对象的<code>format</code>方法将环比格式化为百分比进行显示，此外还指定了将空值替换为<code>--------</code>。</p>
</blockquote>
<p>更为简单的第二种方案是直接使用<code>pct_change</code>方法计算变化的百分比，我们先将之前的上月销售额和环比列删除掉。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result_df.drop(columns=[<span class="string">&#x27;上月销售额&#x27;</span>, <span class="string">&#x27;环比&#x27;</span>], inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>接下来，我们使用<code>DataFrame</code>对象的<code>pct_change</code>方法完成环比的计算。值得一提的是，<code>pct_change</code>方法有一个名为<code>periods</code>的参数，它的默认值是<code>1</code>，计算相邻两项数据变化的百分比，这不就是我们想要的环比吗？如果我们有很多年的数据，在计算时把这个参数的值修改为<code>12</code>，就可以得到相邻两年的月同比。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result_df[<span class="string">&#x27;环比&#x27;</span>] = result_df.pct_change()</span><br><span class="line">result_df</span><br></pre></td></tr></table></figure>
<h3 id="窗口计算"><a href="#窗口计算" class="headerlink" title="窗口计算"></a>窗口计算</h3><p><code>DataFrame</code>对象的<code>rolling</code>方法允许我们将数据置于窗口中，然后用函数对窗口中的数据进行运算和处理。例如，我们获取了某只股票近期的数据，想制作5日均线和10日均线，那么就需要先设置窗口再进行运算。我们先用如下所示的代码读取2022年百度的股票数据，数据文件可以通过下面的链接来获取。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">baidu_df = pd.read_excel(<span class="string">&#x27;data/2022年股票数据.xlsx&#x27;</span>, sheet_name=<span class="string">&#x27;BIDU&#x27;</span>)</span><br><span class="line">baidu_df.sort_index(inplace=<span class="literal">True</span>)</span><br><span class="line">baidu_df</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/baidu_stock.png" style="zoom:50%;"></p>
<p>上面的<code>DataFrame</code>有<code>Open</code>、<code>High</code>、<code>Low</code>、<code>Close</code>、<code>Volume</code>五个列，分别代表股票的开盘价、最高价、最低价、收盘价和成交量，接下来我们对百度的股票数据进行窗口计算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baidu_df.rolling(<span class="number">5</span>).mean()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/baidu_stock_ma5.png" style="zoom:50%;"></p>
<p>我们也可以在<code>Series</code>上使用<code>rolling</code>设置窗口并在窗口内完成运算，例如我们可以对上面的百度股票收盘价（<code>Close</code>列）计算5日均线和10日均线，并使用<code>merge</code>函数将其组装到一个<code>DataFrame</code>对象中并绘制出双均线图，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">close_ma5 = baidu_df.Close.rolling(<span class="number">5</span>).mean()</span><br><span class="line">close_ma10 = baidu_df.Close.rolling(<span class="number">10</span>).mean()</span><br><span class="line">result_df = pd.merge(close_ma5, close_ma10, left_index=<span class="literal">True</span>, right_index=<span class="literal">True</span>)</span><br><span class="line">result_df.rename(columns=&#123;<span class="string">&#x27;Close_x&#x27;</span>: <span class="string">&#x27;MA5&#x27;</span>, <span class="string">&#x27;Close_y&#x27;</span>: <span class="string">&#x27;MA10&#x27;</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">result_df.plot(kind=<span class="string">&#x27;line&#x27;</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/baidu_double_MA.png" style="zoom:50%;"></p>
<h3 id="相关性判定"><a href="#相关性判定" class="headerlink" title="相关性判定"></a>相关性判定</h3><p>在统计学中，我们通常使用协方差（covariance）来衡量两个随机变量的联合变化程度。如果变量 $X$ 的较大值主要与另一个变量 $Y$ 的较大值相对应，而两者较小值也相对应，那么两个变量倾向于表现出相似的行为，协方差为正。如果一个变量的较大值主要对应于另一个变量的较小值，则两个变量倾向于表现出相反的行为，协方差为负。简单的说，协方差的正负号显示着两个变量的相关性。方差是协方差的一种特殊情况，即变量与自身的协方差。</p>
<script type="math/tex; mode=display">
cov(X,Y) = E((X - \mu)(Y - \upsilon)) = E(X \cdot Y) - \mu\upsilon</script><p>如果 $X$ 和 $Y$ 是统计独立的，那么二者的协方差为0，这是因为在 $X$ 和 $Y$ 独立的情况下：</p>
<script type="math/tex; mode=display">
E(X \cdot Y) = E(X) \cdot E(Y) = \mu\upsilon</script><p>协方差的数值大小取决于变量的大小，通常是不容易解释的，但是正态形式的协方差可以显示两变量线性关系的强弱。在统计学中，皮尔逊积矩相关系数就是正态形式的协方差，它用于度量两个变量 $X$ 和 $Y$ 之间的相关程度（线性相关），其值介于<code>-1</code>到<code>1</code>之间。</p>
<script type="math/tex; mode=display">
\frac {cov(X, Y)} {\sigma_{X}\sigma_{Y}}</script><p>估算样本的协方差和标准差，可以得到样本皮尔逊系数，通常用希腊字母 $\rho$ 表示。</p>
<script type="math/tex; mode=display">
\rho = \frac {\sum_{i=1}^{n}(X_i - \bar{X})(Y_i - \bar{Y})} {\sqrt{\sum_{i=1}^{n}(X_i - \bar{X})^2} \sqrt{\sum_{i=1}^{n}(Y_i - \bar{Y})^2}}</script><p>我们用 $\rho$ 值判断指标的相关性时遵循以下两个步骤。</p>
<ol>
<li>判断指标间是正相关、负相关，还是不相关。<ul>
<li>当 $ \rho \gt 0 $，认为变量之间是正相关，也就是两者的趋势一致。</li>
<li>当 $ \rho \lt 0 $，认为变量之间是负相关，也就是两者的趋势相反。</li>
<li>当 $ \rho \approx 0 $，认为变量之间是不相关的，但并不代表两个指标是统计独立的。</li>
</ul>
</li>
<li>判断指标间的相关程度。<ul>
<li>当 $ \rho $ 的绝对值在 $ [0.6,1] $ 之间，认为变量之间是强相关的。</li>
<li>当 $ \rho $ 的绝对值在 $ [0.1,0.6) $ 之间，认为变量之间是弱相关的。</li>
<li>当 $ \rho $ 的绝对值在 $ [0,0.1) $ 之间，认为变量之间没有相关性。</li>
</ul>
</li>
</ol>
<p>皮尔逊相关系数适用于：</p>
<ol>
<li>两个变量之间是线性关系，都是连续数据。</li>
<li>两个变量的总体是正态分布，或接近正态的单峰分布。</li>
<li>两个变量的观测值是成对的，每对观测值之间相互独立。</li>
</ol>
<p>这里，我们顺便说一下，如果两组变量并不是来自于正态总体的连续值，我们该如何判断相关性呢？对于定序尺度（等级），我们可以使用斯皮尔曼秩相关系数，其计算公式如下所示：</p>
<script type="math/tex; mode=display">
r_{s}=1-{\frac {6\sum d_{i}^{2}}{n(n^{2}-1)}}</script><p>其中，$d<em>{i}=\operatorname {R} (X</em>{i})-\operatorname {R} (Y_{i})$，即每组观测中两个变量的等级差值，$n$为观测样本数。</p>
<p>对于定类尺度（类别），我们可以使用卡方检验的方式来判定其是否相关。其实很多时候，连续值也可以通过分箱的方式处理成离散的等级或类别，然后使用斯皮尔曼秩相关系数或卡方检验的方式来判定相关性。</p>
<p><code>DataFrame</code>对象的<code>cov</code>方法和<code>corr</code>方法分别用于计算协方差和相关系数，<code>corr</code>方法有一个名为<code>method</code>的参数，其默认值是<code>pearson</code>，表示计算皮尔逊相关系数；除此之外，还可以指定<code>kendall</code>或<code>spearman</code>来计算肯德尔系数或斯皮尔曼秩相关系数。</p>
<p>我们从名为<code>boston_house_price.csv</code>的文件中获取著名的波士顿房价数据集来创建一个<code>DataFrame</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boston_df = pd.read_csv(<span class="string">&#x27;data/boston_house_price.csv&#x27;</span>)</span><br><span class="line">boston_df</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/Users/Hao/Desktop/Python-Data-Analysis/res/boston_house_price.png" style="zoom:50%;"></p>
<blockquote>
<p><strong>说明</strong>：上面代码中使用了相对路径来访问 CSV 文件，也就是说 CSV 文件在当前工作路径下名为<code>data</code>的文件夹中。如果需要上面例子中的 CSV 文件，可以通过下面的百度云盘地址进行获取。链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g?pwd=e7b4">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g?pwd=e7b4</a>，提取码：e7b4。</p>
</blockquote>
<p>可以看出，该数据集中包含了诸多影响房价的特征，包括犯罪率、一氧化氮浓度、平均房间数、低收入人群占比等，其中<code>PRICE</code>代表房价，具体情况如下所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/boston_house_price_features.png" style="zoom:50%;"></p>
<p>接下来，我们将其中可以视为来自于正态总体的连续值，通过<code>corr</code>方法计算皮尔逊相关系数，看看哪些跟房价是正相关或负相关的关系，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boston_df[[<span class="string">&#x27;NOX&#x27;</span>, <span class="string">&#x27;RM&#x27;</span>, <span class="string">&#x27;PTRATIO&#x27;</span>, <span class="string">&#x27;LSTAT&#x27;</span>, <span class="string">&#x27;PRICE&#x27;</span>]].corr()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/boston_person_correlation.png" style="zoom:50%;"></p>
<p>可以看出，平均房间数（<code>RM</code>）跟房价有较强的正相关性，而低收入人群占比（<code>LSTAT</code>）跟房价之间存在明显的负相关性。</p>
<p>斯皮尔曼秩相关系数对数据条件的要求没有皮尔逊相关系数严格，只要两个变量的观测值是成对的等级数据，或者是由连续变量转化成等级的数据，不论两个变量的总体分布形态、样本容量的大小如何，都可以用斯皮尔曼等级相关系数来进行研究。我们可以通过下面的方式对部分特征进行预处理，然后计算斯皮尔曼秩相关系数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">boston_df[<span class="string">&#x27;CRIM&#x27;</span>] = boston_df.CRIM.apply(<span class="keyword">lambda</span> x: x // <span class="number">5</span> <span class="keyword">if</span> x &lt; <span class="number">25</span> <span class="keyword">else</span> <span class="number">5</span>).<span class="built_in">map</span>(<span class="built_in">int</span>)</span><br><span class="line">boston_df[<span class="string">&#x27;ZN&#x27;</span>] = pd.qcut(boston_df.ZN, q=[<span class="number">0</span>, <span class="number">0.75</span>, <span class="number">0.8</span>, <span class="number">0.85</span>, <span class="number">0.9</span>, <span class="number">0.95</span>, <span class="number">1</span>], labels=np.arange(<span class="number">6</span>))</span><br><span class="line">boston_df[<span class="string">&#x27;AGE&#x27;</span>] = (boston_df.AGE // <span class="number">20</span>).<span class="built_in">map</span>(<span class="built_in">int</span>)</span><br><span class="line">boston_df[<span class="string">&#x27;DIS&#x27;</span>] = (boston_df.DIS // <span class="number">2.05</span>).<span class="built_in">map</span>(<span class="built_in">int</span>)</span><br><span class="line">boston_df[<span class="string">&#x27;B&#x27;</span>] = (boston_df.B // <span class="number">66</span>).<span class="built_in">map</span>(<span class="built_in">int</span>)</span><br><span class="line">boston_df[<span class="string">&#x27;PRICE&#x27;</span>] = pd.qcut(boston_df.PRICE, q=[<span class="number">0</span>, <span class="number">0.15</span>, <span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.7</span>, <span class="number">0.85</span>, <span class="number">1</span>], labels=np.arange(<span class="number">6</span>))</span><br><span class="line">boston_df[[<span class="string">&#x27;CRIM&#x27;</span>, <span class="string">&#x27;ZN&#x27;</span>, <span class="string">&#x27;AGE&#x27;</span>, <span class="string">&#x27;DIS&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;PRICE&#x27;</span>]].corr(method=<span class="string">&#x27;spearman&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/boston_spearman_correlation.png" style="zoom:50%;"></p>
<p>可以看出，房价跟犯罪率（<code>CRIM</code>）和房龄（<code>AGE</code>）之间存在较为明显的负相关关系，跟住房用地尺寸（<code>ZN</code>）存在微弱的正相关关系。相关性可以帮助我们在实际工作中找到业务抓手，即找到那些能够影响或改变工作结果的相关因素。</p>
<h2 id="深入浅出pandas-6"><a href="#深入浅出pandas-6" class="headerlink" title="深入浅出pandas-6"></a>深入浅出pandas-6</h2><p>我们再来看看<code>Index</code>类型，它为<code>Series</code>和<code>DataFrame</code>对象提供了索引服务，有了索引我们就可以排序数据（<code>sort_index</code>方法）、对齐数据（在运算和合并数据时非常重要）并实现对数据的快速检索（索引运算）。由于<code>DataFrame</code>类型表示的是二维数据，所以它的行和列都有索引，分别是<code>index</code>和<code>columns</code>。<code>Index</code>类型的创建的比较简单，通常给出<code>data</code>、<code>dtype</code>和<code>name</code>三个参数即可，分别表示作为索引的数据、索引的数据类型和索引的名称。由于<code>Index</code>本身也是一维的数据，索引它的方法和属性跟<code>Series</code>非常类似，你可以尝试创建一个<code>Index</code>对象，然后尝试一下之前学过的属性和方法在<code>Index</code>类型上是否生效。接下来，我们主要看看<code>Index</code>的几种子类型。</p>
<h3 id="范围索引"><a href="#范围索引" class="headerlink" title="范围索引"></a>范围索引</h3><p>范围索引是由具有单调性的整数构成的索引，我们可以通过<code>RangeIndex</code>构造器来创建范围索引，也可以通过<code>RangeIndex</code>类的类方法<code>from_range</code>来创建范围索引，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sales_data = np.random.randint(<span class="number">400</span>, <span class="number">1000</span>, <span class="number">12</span>)</span><br><span class="line">index = pd.RangeIndex(<span class="number">1</span>, <span class="number">13</span>, name=<span class="string">&#x27;月份&#x27;</span>)</span><br><span class="line">ser = pd.Series(data=sales_data, index=index)</span><br><span class="line">ser</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">月份</span><br><span class="line">1     703</span><br><span class="line">2     705</span><br><span class="line">3     557</span><br><span class="line">4     943</span><br><span class="line">5     961</span><br><span class="line">6     615</span><br><span class="line">7     788</span><br><span class="line">8     985</span><br><span class="line">9     921</span><br><span class="line">10    951</span><br><span class="line">11    874</span><br><span class="line">12    609</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h3 id="分类索引"><a href="#分类索引" class="headerlink" title="分类索引"></a>分类索引</h3><p>分类索引是由定类尺度构成的索引。如果我们需要通过索引将数据分组，然后再进行聚合操作，分类索引就可以派上用场。分类索引还有一个名为<code>reorder_categories</code>的方法，可以给索引指定一个顺序，分组聚合的结果会按照这个指定的顺序进行呈现，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sales_data = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">6</span>]</span><br><span class="line">index = pd.CategoricalIndex(</span><br><span class="line">    data=[<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;桃子&#x27;</span>, <span class="string">&#x27;香蕉&#x27;</span>],</span><br><span class="line">    categories=[<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;桃子&#x27;</span>],</span><br><span class="line">    ordered=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line">ser = pd.Series(data=sales_data, index=index)</span><br><span class="line">ser</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">苹果    6</span><br><span class="line">香蕉    6</span><br><span class="line">苹果    7</span><br><span class="line">苹果    6</span><br><span class="line">桃子    8</span><br><span class="line">香蕉    6</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>基于索引分组数据，然后使用<code>sum</code>进行求和。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser.groupby(level=<span class="number">0</span>).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">苹果    19</span><br><span class="line">香蕉    12</span><br><span class="line">桃子     8</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>指定索引的顺序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ser.index = index.reorder_categories([<span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;桃子&#x27;</span>, <span class="string">&#x27;苹果&#x27;</span>])</span><br><span class="line">ser.groupby(level=<span class="number">0</span>).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">香蕉    12</span><br><span class="line">桃子     8</span><br><span class="line">苹果    19</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h3 id="多级索引"><a href="#多级索引" class="headerlink" title="多级索引"></a>多级索引</h3><p>Pandas 中的<code>MultiIndex</code>类型用来表示层次或多级索引。可以使用<code>MultiIndex</code>类的类方法<code>from_arrays</code>、<code>from_product</code>、<code>from_tuples</code>等来创建多级索引，我们给大家举几个例子。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuples = [(<span class="number">1</span>, <span class="string">&#x27;red&#x27;</span>), (<span class="number">1</span>, <span class="string">&#x27;blue&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;red&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;blue&#x27;</span>)]</span><br><span class="line">index = pd.MultiIndex.from_tuples(tuples, names=[<span class="string">&#x27;no&#x27;</span>, <span class="string">&#x27;color&#x27;</span>])</span><br><span class="line">index</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MultiIndex([(1,  &#x27;red&#x27;),</span><br><span class="line">            (1, &#x27;blue&#x27;),</span><br><span class="line">            (2,  &#x27;red&#x27;),</span><br><span class="line">            (2, &#x27;blue&#x27;)],</span><br><span class="line">           names=[&#x27;no&#x27;, &#x27;color&#x27;])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arrays = [[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]]</span><br><span class="line">index = pd.MultiIndex.from_arrays(arrays, names=[<span class="string">&#x27;no&#x27;</span>, <span class="string">&#x27;color&#x27;</span>])</span><br><span class="line">index</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MultiIndex([(1,  &#x27;red&#x27;),</span><br><span class="line">            (1, &#x27;blue&#x27;),</span><br><span class="line">            (2,  &#x27;red&#x27;),</span><br><span class="line">            (2, &#x27;blue&#x27;)],</span><br><span class="line">           names=[&#x27;no&#x27;, &#x27;color&#x27;])</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sales_data = np.random.randint(<span class="number">1</span>, <span class="number">100</span>, <span class="number">4</span>)</span><br><span class="line">ser = pd.Series(data=sales_data, index=index)</span><br><span class="line">ser</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">no  color</span><br><span class="line">1   red      43</span><br><span class="line">    blue     31</span><br><span class="line">2   red      55</span><br><span class="line">    blue     75</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser.groupby(<span class="string">&#x27;no&#x27;</span>).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">no</span><br><span class="line">1     74</span><br><span class="line">2    130</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser.groupby(level=<span class="number">1</span>).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color</span><br><span class="line">blue    106</span><br><span class="line">red      98</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stu_ids = np.arange(<span class="number">1001</span>, <span class="number">1006</span>)</span><br><span class="line">semisters = [<span class="string">&#x27;期中&#x27;</span>, <span class="string">&#x27;期末&#x27;</span>]</span><br><span class="line">index = pd.MultiIndex.from_product((stu_ids, semisters), names=[<span class="string">&#x27;学号&#x27;</span>, <span class="string">&#x27;学期&#x27;</span>])</span><br><span class="line">courses = [<span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>]</span><br><span class="line">scores = np.random.randint(<span class="number">60</span>, <span class="number">101</span>, (<span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line">df = pd.DataFrame(data=scores, columns=courses, index=index)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">             语文 数学 英语</span><br><span class="line">学号	学期			</span><br><span class="line">1001  期中	93	77	60</span><br><span class="line">      期末	93	98	84</span><br><span class="line">1002  期中	64	78	71</span><br><span class="line">      期末	70	71	97</span><br><span class="line">1003  期中	72	88	97</span><br><span class="line">      期末	99	100	63</span><br><span class="line">1004  期中	80	71	61</span><br><span class="line">      期末	91	62	72</span><br><span class="line">1005  期中	82	95	67</span><br><span class="line">      期末	84	78	86</span><br></pre></td></tr></table></figure>
<p>根据第一级索引分组数据，按照期中成绩占<code>25%</code>，期末成绩占<code>75%</code> 的方式计算每个学生每门课的成绩。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(level=<span class="number">0</span>).agg(<span class="keyword">lambda</span> x: x.values[<span class="number">0</span>] * <span class="number">0.25</span> + x.values[<span class="number">1</span>] * <span class="number">0.75</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        语文    数学    英语</span><br><span class="line">学号			</span><br><span class="line">1001	93.00	92.75	78.00</span><br><span class="line">1002	68.50	72.75	90.50</span><br><span class="line">1003	92.25	97.00	71.50</span><br><span class="line">1004	88.25	64.25	69.25</span><br><span class="line">1005	83.50	82.25	81.25</span><br></pre></td></tr></table></figure>
<h3 id="间隔索引"><a href="#间隔索引" class="headerlink" title="间隔索引"></a>间隔索引</h3><p>间隔索引顾名思义是使用固定的间隔范围充当索引，我们通常会使用<code>interval_range</code>函数来创建间隔索引，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index = pd.interval_range(start=<span class="number">0</span>, end=<span class="number">5</span>)</span><br><span class="line">index</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]], dtype=&#x27;interval[int64, right]&#x27;)</span><br></pre></td></tr></table></figure>
<p><code>IntervalIndex</code>有一个名为<code>contains</code>的方法，可以检查范围内是否包含了某个元素，如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.contains(<span class="number">1.5</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([False,  True, False, False, False])</span><br></pre></td></tr></table></figure>
<p><code>IntervalIndex</code>还有一个名为<code>overlaps</code>的方法，可以检查一个范围跟其他的范围是否有重叠，如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.overlaps(pd.Interval(<span class="number">1.5</span>, <span class="number">3.5</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([False,  True,  True,  True, False])</span><br></pre></td></tr></table></figure>
<p>如果希望间隔范围是左闭右开的状态，可以在创建间隔索引时通过<code>closed=&#39;left&#39;</code>来做到；如果希望两边都是关闭状态，可以将<code>close</code>参数的值赋值为<code>both</code>，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index = pd.interval_range(start=<span class="number">0</span>, end=<span class="number">5</span>, closed=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">index</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntervalIndex([[0, 1), [1, 2), [2, 3), [3, 4), [4, 5)], dtype=&#x27;interval[int64, left]&#x27;)</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index = pd.interval_range(start=pd.Timestamp(<span class="string">&#x27;2022-01-01&#x27;</span>), end=pd.Timestamp(<span class="string">&#x27;2022-01-04&#x27;</span>), closed=<span class="string">&#x27;both&#x27;</span>)</span><br><span class="line">index</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntervalIndex([[2022-01-01, 2022-01-02], [2022-01-02, 2022-01-03], [2022-01-03, 2022-01-04]], dtype=&#x27;interval[datetime64[ns], both]&#x27;)</span><br></pre></td></tr></table></figure>
<h3 id="日期时间索引"><a href="#日期时间索引" class="headerlink" title="日期时间索引"></a>日期时间索引</h3><p><code>DatetimeIndex</code>应该是众多索引中最复杂最重要的一种索引，我们通常会使用<code>date_range()</code>函数来创建日期时间索引，该函数有几个非常重要的参数<code>start</code>、<code>end</code>、<code>periods</code>、<code>freq</code>、<code>tz</code>，分别代表起始日期时间、结束日期时间、生成周期、采样频率和时区。我们先来看看如何创建<code>DatetimeIndex</code>对象，再来讨论它的相关运算和操作，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.date_range(<span class="string">&#x27;2021-1-1&#x27;</span>, <span class="string">&#x27;2021-6-30&#x27;</span>, periods=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DatetimeIndex([&#x27;2021-01-01&#x27;, &#x27;2021-01-21&#x27;, &#x27;2021-02-10&#x27;, &#x27;2021-03-02&#x27;,</span><br><span class="line">               &#x27;2021-03-22&#x27;, &#x27;2021-04-11&#x27;, &#x27;2021-05-01&#x27;, &#x27;2021-05-21&#x27;,</span><br><span class="line">               &#x27;2021-06-10&#x27;, &#x27;2021-06-30&#x27;],</span><br><span class="line">              dtype=&#x27;datetime64[ns]&#x27;, freq=None)</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.date_range(<span class="string">&#x27;2021-1-1&#x27;</span>, <span class="string">&#x27;2021-6-30&#x27;</span>, freq=<span class="string">&#x27;W&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：<code>freq=W</code>表示采样周期为一周，它会默认星期日是一周的开始；如果你希望星期一表示一周的开始，你可以将其修改为<code>freq=W-MON</code>；你也可以试着将该参数的值修改为<code>12H</code>，<code>M</code>，<code>Q</code>等，看看会发生什么，相信你不难猜到它们的含义。</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DatetimeIndex([&#x27;2021-01-03&#x27;, &#x27;2021-01-10&#x27;, &#x27;2021-01-17&#x27;, &#x27;2021-01-24&#x27;,</span><br><span class="line">               &#x27;2021-01-31&#x27;, &#x27;2021-02-07&#x27;, &#x27;2021-02-14&#x27;, &#x27;2021-02-21&#x27;,</span><br><span class="line">               &#x27;2021-02-28&#x27;, &#x27;2021-03-07&#x27;, &#x27;2021-03-14&#x27;, &#x27;2021-03-21&#x27;,</span><br><span class="line">               &#x27;2021-03-28&#x27;, &#x27;2021-04-04&#x27;, &#x27;2021-04-11&#x27;, &#x27;2021-04-18&#x27;,</span><br><span class="line">               &#x27;2021-04-25&#x27;, &#x27;2021-05-02&#x27;, &#x27;2021-05-09&#x27;, &#x27;2021-05-16&#x27;,</span><br><span class="line">               &#x27;2021-05-23&#x27;, &#x27;2021-05-30&#x27;, &#x27;2021-06-06&#x27;, &#x27;2021-06-13&#x27;,</span><br><span class="line">               &#x27;2021-06-20&#x27;, &#x27;2021-06-27&#x27;],</span><br><span class="line">              dtype=&#x27;datetime64[ns]&#x27;, freq=&#x27;W-SUN&#x27;)</span><br></pre></td></tr></table></figure>
<p><code>DatatimeIndex</code>可以跟<code>DateOffset</code>类型进行运算，这一点很好理解，以为我们可以设置一个时间差让时间向前或向后偏移，具体的操作如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index = pd.date_range(<span class="string">&#x27;2021-1-1&#x27;</span>, <span class="string">&#x27;2021-6-30&#x27;</span>, freq=<span class="string">&#x27;W&#x27;</span>)</span><br><span class="line">index - pd.DateOffset(days=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DatetimeIndex([&#x27;2021-01-01&#x27;, &#x27;2021-01-08&#x27;, &#x27;2021-01-15&#x27;, &#x27;2021-01-22&#x27;,</span><br><span class="line">               &#x27;2021-01-29&#x27;, &#x27;2021-02-05&#x27;, &#x27;2021-02-12&#x27;, &#x27;2021-02-19&#x27;,</span><br><span class="line">               &#x27;2021-02-26&#x27;, &#x27;2021-03-05&#x27;, &#x27;2021-03-12&#x27;, &#x27;2021-03-19&#x27;,</span><br><span class="line">               &#x27;2021-03-26&#x27;, &#x27;2021-04-02&#x27;, &#x27;2021-04-09&#x27;, &#x27;2021-04-16&#x27;,</span><br><span class="line">               &#x27;2021-04-23&#x27;, &#x27;2021-04-30&#x27;, &#x27;2021-05-07&#x27;, &#x27;2021-05-14&#x27;,</span><br><span class="line">               &#x27;2021-05-21&#x27;, &#x27;2021-05-28&#x27;, &#x27;2021-06-04&#x27;, &#x27;2021-06-11&#x27;,</span><br><span class="line">               &#x27;2021-06-18&#x27;, &#x27;2021-06-25&#x27;],</span><br><span class="line">              dtype=&#x27;datetime64[ns]&#x27;, freq=None)</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index + pd.DateOffset(hours=<span class="number">2</span>, minutes=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DatetimeIndex([&#x27;2021-01-03 02:10:00&#x27;, &#x27;2021-01-10 02:10:00&#x27;,</span><br><span class="line">               &#x27;2021-01-17 02:10:00&#x27;, &#x27;2021-01-24 02:10:00&#x27;,</span><br><span class="line">               &#x27;2021-01-31 02:10:00&#x27;, &#x27;2021-02-07 02:10:00&#x27;,</span><br><span class="line">               &#x27;2021-02-14 02:10:00&#x27;, &#x27;2021-02-21 02:10:00&#x27;,</span><br><span class="line">               &#x27;2021-02-28 02:10:00&#x27;, &#x27;2021-03-07 02:10:00&#x27;,</span><br><span class="line">               &#x27;2021-03-14 02:10:00&#x27;, &#x27;2021-03-21 02:10:00&#x27;,</span><br><span class="line">               &#x27;2021-03-28 02:10:00&#x27;, &#x27;2021-04-04 02:10:00&#x27;,</span><br><span class="line">               &#x27;2021-04-11 02:10:00&#x27;, &#x27;2021-04-18 02:10:00&#x27;,</span><br><span class="line">               &#x27;2021-04-25 02:10:00&#x27;, &#x27;2021-05-02 02:10:00&#x27;,</span><br><span class="line">               &#x27;2021-05-09 02:10:00&#x27;, &#x27;2021-05-16 02:10:00&#x27;,</span><br><span class="line">               &#x27;2021-05-23 02:10:00&#x27;, &#x27;2021-05-30 02:10:00&#x27;,</span><br><span class="line">               &#x27;2021-06-06 02:10:00&#x27;, &#x27;2021-06-13 02:10:00&#x27;,</span><br><span class="line">               &#x27;2021-06-20 02:10:00&#x27;, &#x27;2021-06-27 02:10:00&#x27;],</span><br><span class="line">              dtype=&#x27;datetime64[ns]&#x27;, freq=None)</span><br></pre></td></tr></table></figure>
<p>如果<code>Series</code>对象或<code>DataFrame</code>对象使用了<code>DatetimeIndex</code>类型的索引，此时我们可以通过<code>asfreq()</code>方法指定一个时间频率来实现对数据的抽样，我们仍然以之前讲过的百度股票数据为例，给大家做一个演示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">baidu_df = pd.read_excel(<span class="string">&#x27;data/2022年股票数据.xlsx&#x27;</span>, sheet_name=<span class="string">&#x27;BIDU&#x27;</span>, index_col=<span class="string">&#x27;Date&#x27;</span>)</span><br><span class="line">baidu_df.sort_index(inplace=<span class="literal">True</span>)</span><br><span class="line">baidu_df.asfreq(<span class="string">&#x27;5D&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/baidu_stock_asfreq.png" style="zoom:50%;"></p>
<p>大家可能注意到了，每5天抽取1天有可能会抽中非交易日，那么对应的列都变成了空值，为了解决这个问题，在使用<code>asfreq</code>方法时可以通过<code>method</code>参数来指定一种填充空值的方法，可以将相邻的交易日的数据填入进来。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baidu_df.asfreq(<span class="string">&#x27;5D&#x27;</span>, method=<span class="string">&#x27;ffill&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/baidu_stock_asfreq_ffill.png" style="zoom:50%;"></p>
<p>当使用<code>DatetimeIndex</code>索引时，我们也可以通过<code>resample()</code>方法基于时间对数据进行重采样，相当于根据时间周期对数据进行了分组操作，分组之后还可以进行聚合统计，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baidu_df.resample(<span class="string">&#x27;1M&#x27;</span>).mean()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/baidu_stock_resample.png" style="zoom:50%;"></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baidu_df.resample(<span class="string">&#x27;1M&#x27;</span>).agg([<span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;std&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/baidu_stock_resample_agg.png" style="zoom:100%;"></p>
<blockquote>
<p><strong>提示</strong>：不知大家是否注意到，上面输出的<code>DataFrame</code> 的列索引是一个<code>MultiIndex</code>对象。你可以访问上面的<code>DataFrame</code>对象的<code>columns</code>属性看看。</p>
</blockquote>
<p>如果要实现日期时间的时区转换，我们可以先用<code>tz_localize()</code>方法将日期时间本地化，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">baidu_df = baidu_df.tz_localize(<span class="string">&#x27;Asia/Chongqing&#x27;</span>)</span><br><span class="line">baidu_df</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/baidu_stock_tz_localize.png" style="zoom:50%;"></p>
<p>在对时间本地化以后，我们再使用<code>tz_convert()</code>方法就可以实现转换时区，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baidu_df.tz_convert(<span class="string">&#x27;America/New_York&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/baidu_stock_tz_convert.png" style="zoom:50%;"></p>
<p>如果你的数据使用了<code>DatetimeIndex</code>类型的索引，那么你就很有可能要对数据进行时间序列分析，关于时间序列分析的方法和模型并不是本章节要探讨的内容，我们在其他的专栏中为大家分享。</p>
<h2 id="数据可视化-1"><a href="#数据可视化-1" class="headerlink" title="数据可视化-1"></a>数据可视化-1</h2><p>在完成了对数据的透视之后，我们可以将数据透视的结果通过可视化的方式呈现出来，简单的说，就是将数据变成漂亮的统计图表，因为人类对颜色和形状会更加敏感，然后再进一步解读数据背后隐藏的商业价值。在之前的课程中，我们已经为大家展示过用使用<code>Series</code>或<code>DataFrame</code>对象的<code>plot</code>方法生成可视化图表的操作，本章我们为大家讲解这个绘图方法的基石，它就是大名鼎鼎的 matplotlib 库。</p>
<p>在讲解 matplotlib 之前，请大家先看看下面这张图，它给出了常用的图表类型及其应用场景。我们在选择统计图表时，如果不知道做出怎样的选择最合适，相信这张图就能帮到你。简单的说，看趋势折线图，比数据柱状图，定关系散点图，查占比饼状图，看分布直方图，找离群箱线图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/choose_your_chart.png" style="zoom:65%;"></p>
<h3 id="导入和配置"><a href="#导入和配置" class="headerlink" title="导入和配置"></a>导入和配置</h3><p>之前的课程中，我们为大家讲解过如何安装和导入 matplotlib 库，如果不确定是否已经安装了 matplotlib，可以使用下面的魔法指令尝试安装或升级你的 matplotlib。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%pip install -U matplotlib</span><br></pre></td></tr></table></figure>
<p>为了解决 matplotlib 图表中文显示的问题，我们需要修改<code>pyplot</code>模块的<code>rcParams</code>配置参数，具体的操作如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>].insert(<span class="number">0</span>, <span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：上面代码中的<code>SimHei</code>是字体名称，大家可以通过百度云盘下载并安装该字体，链接地址：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g?pwd=e7b4。你可以尝试安装其他的中文字体，安装之后如果不知道字体叫什么名字，可以到用户主目录下名为`.matplotlib`的文件夹中找到`fontlist-v330.json`文件，打开后可以看到字体文件的路径和字体的名称等信息。需要注意的是，使用中文字体后坐标轴上的负号将会无法显示，需要将`axes.unicode_minus`参数设置为`False`，这样才能让坐标轴上的负号正常显示。">https://pan.baidu.com/s/1rQujl5RQn9R7PadB2Z5g_g?pwd=e7b4。你可以尝试安装其他的中文字体，安装之后如果不知道字体叫什么名字，可以到用户主目录下名为`.matplotlib`的文件夹中找到`fontlist-v330.json`文件，打开后可以看到字体文件的路径和字体的名称等信息。需要注意的是，使用中文字体后坐标轴上的负号将会无法显示，需要将`axes.unicode_minus`参数设置为`False`，这样才能让坐标轴上的负号正常显示。</a></p>
</blockquote>
<p>通过下面的魔法指令，我们可以在绘图时生成<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9F%A2%E9%87%8F%E5%9B%BE%E5%BD%A2">矢量图</a>（SVG - Scalable Vector Graphics），矢量图的特点是不会因为放大、缩小或旋转等操作而失真，看起来会舒服很多。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%config InlineBackend.figure_format=<span class="string">&#x27;svg&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="创建画布"><a href="#创建画布" class="headerlink" title="创建画布"></a>创建画布</h3><p><code>pyplot</code>模块的<code>figure</code>函数可以用来创建画布，创建画布时，可以通过<code>figsize</code>参数指定画布的尺寸（默认值是<code>[6.4, 4.8]</code>）；可以通过<code>dpi</code>参数设置绘图的分辨率，因为<code>dpi</code>代表了每英寸的像素点数量。除此之外，还可以通过<code>facecolor</code>参数设置画布的背景色。<code>figure</code>函数的返回值是一个<code>Figure</code>对象，它代表了绘图使用的画布，我们可以基于画布来创建绘图使用的坐标系。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">4</span>), dpi=<span class="number">120</span>, facecolor=<span class="string">&#x27;darkgray&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="创建坐标系"><a href="#创建坐标系" class="headerlink" title="创建坐标系"></a>创建坐标系</h3><p>可以直接使用<code>pyplot</code>模块的<code>subplot</code>函数来创建坐标系，该函数会返回<code>Axes</code>对象。<code>subplot</code>的前三个参数分别用来指定整个画布分成几行几列以及当前坐标系的索引，这三个参数的默认值都是<code>1</code>。如果没有创建坐标系，我们绘图时会使用画布上默认的也是唯一的一个坐标系；如果需要在画布上创建多个坐标系，就可以使用该函数。当然，我们也可以通过上面创建的<code>Figure</code>对象的<code>add_subplot</code>方法或<code>add_axes</code>方法来创建坐标系，前者跟<code>subplot</code>函数的作用一致，后者会产生嵌套的坐标系。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h3><h4 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h4><p>在绘图时，如果没有先调用<code>figure</code>函数和<code>subplot</code>函数，我们将使用默认的画布和坐标系，如果要绘制折线图，可以使用<code>pyplot</code>模块的<code>plot</code>函数，并指定横轴和纵轴的数据。折线图最适合用来观察数据的趋势，尤其是当横坐标代表时间的情况下。我们可以使用<code>plot</code>函数的<code>color</code>参数来定制折线的颜色，可以使用<code>marker</code>参数来定制数据点的标记（例如：<code>*</code>表示五角星，<code>^</code>表示三角形，<code>o</code>表示小圆圈等），可以使用<code>linestyle</code>参数来定制折线的样式（例如：<code>-</code>表示实线，<code>--</code>表示虚线，<code>:</code>表示点线等），可以使用<code>linewidth</code>参数来定制折线的粗细。 下面的代码绘制了一条正弦曲线，其中<code>marker=&#39;*&#39;</code>会将数据点的标记设置为五角星形状，而<code>color=&#39;red&#39;</code>会将折线绘制为红色。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(-<span class="number">2</span> * np.pi, <span class="number">2</span> * np.pi, <span class="number">120</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建画布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">4</span>), dpi=<span class="number">120</span>)</span><br><span class="line"><span class="comment"># 绘制折线图</span></span><br><span class="line">plt.plot(x, y, linewidth=<span class="number">2</span>, marker=<span class="string">&#x27;*&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="comment"># 显示绘图</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/20220501173344.png" style="zoom:50%;"></p>
<p>如果要在一个坐标系上同时绘制正弦和余弦曲线，可以对上面的代码稍作修改。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(-<span class="number">2</span> * np.pi, <span class="number">2</span> * np.pi, <span class="number">120</span>)</span><br><span class="line">y1, y2 = np.sin(x), np.cos(x)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">4</span>), dpi=<span class="number">120</span>)</span><br><span class="line">plt.plot(x, y1, linewidth=<span class="number">2</span>, marker=<span class="string">&#x27;*&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">plt.plot(x, y2, linewidth=<span class="number">2</span>, marker=<span class="string">&#x27;^&#x27;</span>, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line"><span class="comment"># 定制图表上的标注（annotate函数的参数如果不理解可以先不管它）</span></span><br><span class="line">plt.annotate(<span class="string">&#x27;sin(x)&#x27;</span>, xytext=(<span class="number">0.5</span>, -<span class="number">0.75</span>), xy=(<span class="number">0</span>, -<span class="number">0.25</span>), fontsize=<span class="number">12</span>, arrowprops=&#123;</span><br><span class="line">    <span class="string">&#x27;arrowstyle&#x27;</span>: <span class="string">&#x27;-&gt;&#x27;</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;darkgreen&#x27;</span>, <span class="string">&#x27;connectionstyle&#x27;</span>: <span class="string">&#x27;angle3, angleA=90, angleB=0&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">plt.annotate(<span class="string">&#x27;cos(x)&#x27;</span>, xytext=(-<span class="number">3</span>, <span class="number">0.75</span>), xy=(-<span class="number">1.25</span>, <span class="number">0.5</span>), fontsize=<span class="number">12</span>, arrowprops=&#123;</span><br><span class="line">    <span class="string">&#x27;arrowstyle&#x27;</span>: <span class="string">&#x27;-&gt;&#x27;</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;darkgreen&#x27;</span>, <span class="string">&#x27;connectionstyle&#x27;</span>: <span class="string">&#x27;arc3, rad=0.35&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/20220502095949.png" style="zoom:50%;"></p>
<p>如果要使用两个坐标系分别绘制正弦和余弦，可以用上面提到的<code>subplot</code>函数来创建坐标系，然后再绘图。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">4</span>), dpi=<span class="number">120</span>)</span><br><span class="line"><span class="comment"># 创建坐标系（第1个图）</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(x, y1, linewidth=<span class="number">2</span>, marker=<span class="string">&#x27;*&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="comment"># 创建坐标系（第2个图）</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(x, y2, linewidth=<span class="number">2</span>, marker=<span class="string">&#x27;^&#x27;</span>, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/20220501173446.png" style="zoom:50%;"></p>
<p>当然也可以像下面这么做，大家可以运行代码看看跟上面的图有什么区别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">4</span>), dpi=<span class="number">120</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(x, y1, linewidth=<span class="number">2</span>, marker=<span class="string">&#x27;*&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(x, y2, linewidth=<span class="number">2</span>, marker=<span class="string">&#x27;^&#x27;</span>, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>然后，再试一试下面这个代码，看看运行效果如何。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">4</span>), dpi=<span class="number">120</span>)</span><br><span class="line">plt.plot(x, y1, linewidth=<span class="number">2</span>, marker=<span class="string">&#x27;*&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line"><span class="comment"># 用Figure对象的add_axes方法在现有坐标系中嵌套一个新的坐标系，该方法的参数是一个四元组，</span></span><br><span class="line"><span class="comment"># 代表了新坐标系在原坐标系中的位置，前两个值是左下角的位置，后两个值是坐标系的宽度和高度</span></span><br><span class="line">ax = fig.add_axes((<span class="number">0.595</span>, <span class="number">0.6</span>, <span class="number">0.3</span>,<span class="number">0.25</span>))</span><br><span class="line">ax.plot(x, y2, marker=<span class="string">&#x27;^&#x27;</span>, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">ax = fig.add_axes((<span class="number">0.155</span>, <span class="number">0.2</span>, <span class="number">0.3</span>,<span class="number">0.25</span>))</span><br><span class="line">ax.plot(x, y2, marker=<span class="string">&#x27;^&#x27;</span>, color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h4 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h4><p>散点图可以帮助我们了解两个变量的关系，如果需要了解三个变量的关系，可以将散点图升级为气泡图。下面的代码中，<code>x</code>和<code>y</code>两个数组分别表示每个月的收入和每个月网购的支出，如果我们想了解<code>x</code>和<code>y</code>是否存在相关关系，就可以绘制如下所示的散点图。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">5550</span>, <span class="number">7500</span>, <span class="number">10500</span>, <span class="number">15000</span>, <span class="number">20000</span>, <span class="number">25000</span>, <span class="number">30000</span>, <span class="number">40000</span>])</span><br><span class="line">y = np.array([<span class="number">800</span>, <span class="number">1800</span>, <span class="number">1250</span>, <span class="number">2000</span>, <span class="number">1800</span>, <span class="number">2100</span>, <span class="number">2500</span>, <span class="number">3500</span>])</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>), dpi=<span class="number">120</span>)</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/20220501173034.png" style="zoom:50%;"></p>
<h4 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h4><p>在对比数据的差异时，柱状图是非常棒的选择，我们可以使用<code>pyplot</code>模块的<code>bar</code>函数来生成柱状图，也可以使用<code>barh</code>函数来生成水平柱状图（也称为“条状图”）。我们先为柱状图准备一些数据，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">4</span>)</span><br><span class="line">y1 = np.random.randint(<span class="number">20</span>, <span class="number">50</span>, <span class="number">4</span>)</span><br><span class="line">y2 = np.random.randint(<span class="number">10</span>, <span class="number">60</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>绘制柱状图的代码。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>), dpi=<span class="number">120</span>)</span><br><span class="line"><span class="comment"># 通过横坐标的偏移，让两组数据对应的柱子分开，width参数控制柱子的粗细，label参数为柱子添加标签</span></span><br><span class="line">plt.bar(x - <span class="number">0.1</span>, y1, width=<span class="number">0.2</span>, label=<span class="string">&#x27;销售A组&#x27;</span>)</span><br><span class="line">plt.bar(x + <span class="number">0.1</span>, y2, width=<span class="number">0.2</span>, label=<span class="string">&#x27;销售B组&#x27;</span>)</span><br><span class="line"><span class="comment"># 定制横轴的刻度</span></span><br><span class="line">plt.xticks(x, labels=[<span class="string">&#x27;Q1&#x27;</span>, <span class="string">&#x27;Q2&#x27;</span>, <span class="string">&#x27;Q3&#x27;</span>, <span class="string">&#x27;Q4&#x27;</span>])</span><br><span class="line"><span class="comment"># 定制显示图例</span></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/20220501173557.png" style="zoom:50%;"></p>
<p>如果想绘制堆叠柱状图，可以对上面的代码稍作修改，如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">labels = [<span class="string">&#x27;Q1&#x27;</span>, <span class="string">&#x27;Q2&#x27;</span>, <span class="string">&#x27;Q3&#x27;</span>, <span class="string">&#x27;Q4&#x27;</span>]</span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>), dpi=<span class="number">120</span>)</span><br><span class="line">plt.bar(labels, y1, width=<span class="number">0.4</span>, label=<span class="string">&#x27;销售A组&#x27;</span>)</span><br><span class="line"><span class="comment"># 注意：堆叠柱状图的关键是将之前的柱子作为新柱子的底部，可以通过bottom参数指定底部数据，新柱子绘制在底部数据之上</span></span><br><span class="line">plt.bar(labels, y2, width=<span class="number">0.4</span>, bottom=y1, label=<span class="string">&#x27;销售B组&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower right&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/20220501173645.png" style="zoom:50%;"></p>
<h4 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a>饼状图</h4><p>饼状图通常简称为饼图，是一个将数据划分为几个扇形区域的统计图表，它主要用于描述数量、频率等之间的相对关系。在饼图中，每个扇形区域的大小就是其所表示的数量的比例，这些扇形区域合在一起刚好是一个完整的饼。在需要展示数据构成的场景下，饼状图、树状图和瀑布图是不错的选择，我们可以使用<code>pyplot</code>模块的<code>pie</code>函数来绘制饼图，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.randint(<span class="number">100</span>, <span class="number">500</span>, <span class="number">7</span>)</span><br><span class="line">labels = [<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;桃子&#x27;</span>, <span class="string">&#x27;荔枝&#x27;</span>, <span class="string">&#x27;石榴&#x27;</span>, <span class="string">&#x27;山竹&#x27;</span>, <span class="string">&#x27;榴莲&#x27;</span>]</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">5</span>, <span class="number">5</span>), dpi=<span class="number">120</span>)</span><br><span class="line">plt.pie(</span><br><span class="line">    data,</span><br><span class="line">    <span class="comment"># 自动显示百分比</span></span><br><span class="line">    autopct=<span class="string">&#x27;%.1f%%&#x27;</span>,</span><br><span class="line">    <span class="comment"># 饼图的半径</span></span><br><span class="line">    radius=<span class="number">1</span>,</span><br><span class="line">    <span class="comment"># 百分比到圆心的距离</span></span><br><span class="line">    pctdistance=<span class="number">0.8</span>,</span><br><span class="line">    <span class="comment"># 颜色（随机生成）</span></span><br><span class="line">    colors=np.random.rand(<span class="number">7</span>, <span class="number">3</span>),</span><br><span class="line">    <span class="comment"># 分离距离</span></span><br><span class="line">    <span class="comment"># explode=[0.05, 0, 0.1, 0, 0, 0, 0],</span></span><br><span class="line">    <span class="comment"># 阴影效果</span></span><br><span class="line">    <span class="comment"># shadow=True,</span></span><br><span class="line">    <span class="comment"># 字体属性</span></span><br><span class="line">    textprops=<span class="built_in">dict</span>(fontsize=<span class="number">8</span>, color=<span class="string">&#x27;black&#x27;</span>),</span><br><span class="line">    <span class="comment"># 楔子属性（生成环状饼图的关键）</span></span><br><span class="line">    wedgeprops=<span class="built_in">dict</span>(linewidth=<span class="number">1</span>, width=<span class="number">0.35</span>),</span><br><span class="line">    <span class="comment"># 标签</span></span><br><span class="line">    labels=labels</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 定制图表的标题</span></span><br><span class="line">plt.title(<span class="string">&#x27;水果销售额占比&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/20220502094128.png" style="zoom:50%;"></p>
<blockquote>
<p><strong>说明</strong>：大家可以试一试将上面代码中被注释的部分恢复，看看有什么样的效果。</p>
</blockquote>
<h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><p>在统计学中，直方图是一种展示数据分布情况的图形，是一种二维统计图表，它的两个坐标分别是统计样本和该样本对应的某个属性的度量。下面的数据是某学校100名男学生的身高，如果我们想知道数据的分布，就可以使用直方图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">heights = np.array([</span><br><span class="line">    <span class="number">170</span>, <span class="number">163</span>, <span class="number">174</span>, <span class="number">164</span>, <span class="number">159</span>, <span class="number">168</span>, <span class="number">165</span>, <span class="number">171</span>, <span class="number">171</span>, <span class="number">167</span>, </span><br><span class="line">    <span class="number">165</span>, <span class="number">161</span>, <span class="number">175</span>, <span class="number">170</span>, <span class="number">174</span>, <span class="number">170</span>, <span class="number">174</span>, <span class="number">170</span>, <span class="number">173</span>, <span class="number">173</span>, </span><br><span class="line">    <span class="number">167</span>, <span class="number">169</span>, <span class="number">173</span>, <span class="number">153</span>, <span class="number">165</span>, <span class="number">169</span>, <span class="number">158</span>, <span class="number">166</span>, <span class="number">164</span>, <span class="number">173</span>, </span><br><span class="line">    <span class="number">162</span>, <span class="number">171</span>, <span class="number">173</span>, <span class="number">171</span>, <span class="number">165</span>, <span class="number">152</span>, <span class="number">163</span>, <span class="number">170</span>, <span class="number">171</span>, <span class="number">163</span>, </span><br><span class="line">    <span class="number">165</span>, <span class="number">166</span>, <span class="number">155</span>, <span class="number">155</span>, <span class="number">171</span>, <span class="number">161</span>, <span class="number">167</span>, <span class="number">172</span>, <span class="number">164</span>, <span class="number">155</span>, </span><br><span class="line">    <span class="number">168</span>, <span class="number">171</span>, <span class="number">173</span>, <span class="number">169</span>, <span class="number">165</span>, <span class="number">162</span>, <span class="number">168</span>, <span class="number">177</span>, <span class="number">174</span>, <span class="number">178</span>, </span><br><span class="line">    <span class="number">161</span>, <span class="number">180</span>, <span class="number">155</span>, <span class="number">155</span>, <span class="number">166</span>, <span class="number">175</span>, <span class="number">159</span>, <span class="number">169</span>, <span class="number">165</span>, <span class="number">174</span>, </span><br><span class="line">    <span class="number">175</span>, <span class="number">160</span>, <span class="number">152</span>, <span class="number">168</span>, <span class="number">164</span>, <span class="number">175</span>, <span class="number">168</span>, <span class="number">183</span>, <span class="number">166</span>, <span class="number">166</span>, </span><br><span class="line">    <span class="number">182</span>, <span class="number">174</span>, <span class="number">167</span>, <span class="number">168</span>, <span class="number">176</span>, <span class="number">170</span>, <span class="number">169</span>, <span class="number">173</span>, <span class="number">177</span>, <span class="number">168</span>, </span><br><span class="line">    <span class="number">172</span>, <span class="number">159</span>, <span class="number">173</span>, <span class="number">185</span>, <span class="number">161</span>, <span class="number">170</span>, <span class="number">170</span>, <span class="number">184</span>, <span class="number">171</span>, <span class="number">172</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>可以使用<code>pyplot</code>模块的<code>hist</code>函数来绘制直方图，其中<code>bins</code>参数代表了我们使用的分箱方式（身高从150厘米到190厘米，每5厘米为一个分箱），代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>), dpi=<span class="number">120</span>)</span><br><span class="line"><span class="comment"># 绘制直方图</span></span><br><span class="line">plt.hist(heights, bins=np.arange(<span class="number">145</span>, <span class="number">196</span>, <span class="number">5</span>), color=<span class="string">&#x27;darkcyan&#x27;</span>)</span><br><span class="line"><span class="comment"># 定制横轴标签</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;身高&#x27;</span>)</span><br><span class="line"><span class="comment"># 定制纵轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;概率密度&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/hist_count.png" style="zoom:50%;"></p>
<p>绘制直方图时，如果将<code>hist</code>函数的<code>density</code>参数修改为<code>True</code>，同时将<code>cumulative</code>参数也修改为<code>True</code>，那么一方面纵轴会显示为概率密度，而图表会绘制概率的累计分布，如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>), dpi=<span class="number">120</span>)</span><br><span class="line"><span class="comment"># 绘制直方图</span></span><br><span class="line">plt.hist(heights, bins=np.arange(<span class="number">145</span>, <span class="number">196</span>, <span class="number">5</span>), color=<span class="string">&#x27;darkcyan&#x27;</span>, density=<span class="literal">True</span>, cumulative=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 定制横轴标签</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;身高&#x27;</span>)</span><br><span class="line"><span class="comment"># 定制纵轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;概率&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/hist_cumulative.png" style="zoom:50%;"></p>
<h4 id="箱线图"><a href="#箱线图" class="headerlink" title="箱线图"></a>箱线图</h4><p>箱线图又叫箱型图或盒须图，是一种用于展示一组数据分散情况的统计图表，如下所示。因图形如箱子，而且在上下四分位数之外有线条像胡须延伸出去而得名。在箱线图中，箱子的上边界是上四分位数（$Q_3$）的位置，箱子的下边界是下四分位数（$Q_1$）的位置，箱子中间的线条是中位数（$Q_2$）的位置，而箱子的长度就是四分位距离（IQR）。除此之外，箱子上方线条的边界是最大值，箱子下方线条的边界是最小值，这两条线之外的点就是离群值（outlier）。所谓离群值，是指数据小于$Q_1 - 1.5 \times IQR$或数据大于$Q_3 + 1.5 \times IQR$的值，公式中的<code>1.5</code>还可以替换为<code>3</code>来发现极端离群值（extreme outlier），而介于<code>1.5</code>到<code>3</code>之间的离群值通常称之为适度离群值（mild outlier）。</p>
<p>可以使用<code>pyplot</code>模块的<code>boxplot</code>函数来绘制箱线图，代码如下所示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组中有47个[0, 100)范围的随机数</span></span><br><span class="line">data = np.random.randint(<span class="number">0</span>, <span class="number">100</span>, <span class="number">47</span>)</span><br><span class="line"><span class="comment"># 向数组中添加三个可能是离群点的数据</span></span><br><span class="line">data = np.append(data, <span class="number">160</span>)</span><br><span class="line">data = np.append(data, <span class="number">200</span>)</span><br><span class="line">data = np.append(data, -<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">4</span>), dpi=<span class="number">120</span>)</span><br><span class="line"><span class="comment"># whis参数的默认值是1.5，将其设置为3可以检测极端离群值，showmeans=True表示在图中标记均值的位置</span></span><br><span class="line">plt.boxplot(data, whis=<span class="number">1.5</span>, showmeans=<span class="literal">True</span>, notch=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 定制纵轴的取值范围</span></span><br><span class="line">plt.ylim([-<span class="number">100</span>, <span class="number">250</span>])</span><br><span class="line"><span class="comment"># 定制横轴的刻度</span></span><br><span class="line">plt.xticks([<span class="number">1</span>], labels=[<span class="string">&#x27;data&#x27;</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/20220501172802.png" style="zoom:50%;" /></p>
<blockquote>
<p><strong>说明</strong>：由于数据是随机生成的，大家运行上面的代码生成的图表可能跟我这里并不相同，以实际运行结果为准。</p>
</blockquote>
<h3 id="显示或保存图像"><a href="#显示或保存图像" class="headerlink" title="显示或保存图像"></a>显示或保存图像</h3><p>可以使用<code>pyplot</code>模块的<code>show</code>函数来显示绘制的图表，我们在上面的代码中使用过这个函数。如果希望保存图表，可以使用<code>savefig</code>函数。需要注意的是，如果要同时显示和保存图表，应该先执行<code>savefig</code>函数，再执行<code>show</code>函数，因为在调用<code>show</code>函数时，图表已经被释放，位于<code>show</code>函数之后的<code>savefig</code>保存的只是一个空白的区域。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(<span class="string">&#x27;chart.png&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h3 id="其他图表"><a href="#其他图表" class="headerlink" title="其他图表"></a>其他图表</h3><p>使用 matplotlib，我们还可以绘制出其他的统计图表（如：雷达图、玫瑰图、热力图等），但实际工作中，使用频率最高的几类图表我们在上面已经为大家完整的展示出来了。此外，matplotlib 还有很多对统计图表进行定制的细节，例如定制坐标轴、定制图表上的文字和标签等。如果想了解如何用 matplotlib 绘制和定制更多的统计图表，可以直接查看 matplotlib 官方网站上的<a target="_blank" rel="noopener" href="https://matplotlib.org/stable/tutorials/index.html">文档</a>和<a target="_blank" rel="noopener" href="https://matplotlib.org/stable/gallery/index.html">示例</a>，在下一个章节我们会为大家做一个简要的介绍。</p>
<h2 id="数据可视化-2"><a href="#数据可视化-2" class="headerlink" title="数据可视化-2"></a>数据可视化-2</h2><p>本章我们尝试用 matplotlib 来绘制一些高阶统计图表。正如前面所说的，大家可以通过 matplotlib 官方网站上提供的<a target="_blank" rel="noopener" href="https://matplotlib.org/stable/tutorials/index.html">文档</a>和<a target="_blank" rel="noopener" href="https://matplotlib.org/stable/gallery/index.html">示例</a>来学习如何使用 matplotlib 并绘制出更加高级的统计图表；尤其是在定制一些比较复杂的图表时，我们建议大家直接找到官网提供的示例，然后只需要做出相应的修改，就可以绘制出自己想要的图表。这种“拷贝+修改”的做法应该会大大提高你的工作效率，因为大多数时候，你的代码跟官网上的代码就仅仅是数据有差别而已，没有必要去做重复乏味的事情。</p>
<h3 id="气泡图"><a href="#气泡图" class="headerlink" title="气泡图"></a>气泡图</h3><p>气泡图可以用来了解三个变量之间的关系，通过比较气泡位置和大小来分析数据维度之间的相关性。例如在我们之前绘制的月收入和网购支出的散点图中，我们已经发现了二者的正相关关系，如果我们引入第三个变量网购次数，那么我们就需要使用气泡图来进行展示。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">income = np.array([<span class="number">5550</span>, <span class="number">7500</span>, <span class="number">10500</span>, <span class="number">15000</span>, <span class="number">20000</span>, <span class="number">25000</span>, <span class="number">30000</span>, <span class="number">40000</span>])</span><br><span class="line">outcome = np.array([<span class="number">800</span>, <span class="number">1800</span>, <span class="number">1250</span>, <span class="number">2000</span>, <span class="number">1800</span>, <span class="number">2100</span>, <span class="number">2500</span>, <span class="number">3500</span>])</span><br><span class="line">nums = np.array([<span class="number">5</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">20</span>, <span class="number">8</span>, <span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过scatter函数的s参数和c参数分别控制面积和颜色</span></span><br><span class="line">plt.scatter(income, outcome, s=nums * <span class="number">30</span>, c=nums, cmap=<span class="string">&#x27;Reds&#x27;</span>)</span><br><span class="line"><span class="comment"># 显示颜色条</span></span><br><span class="line">plt.colorbar()</span><br><span class="line"><span class="comment"># 显示图表</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/bubble_chart.png" style="zoom:50%;"></p>
<h3 id="面积图"><a href="#面积图" class="headerlink" title="面积图"></a>面积图</h3><p>面积图又叫堆叠折线图，是在折线图的基础上，对折线以下的区域进行颜色填充（展示面积），用于在连续间隔或时间跨度上展示数值，一般用来显示趋势和对比数值，不同颜色的填充可以让多个面积块之间的对比和趋势更好的突显。下面的例子中，我们用面积图来展示从周一到周日花在睡觉、吃饭、工作和玩耍上的时间。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line">days = np.arange(<span class="number">7</span>)</span><br><span class="line">sleeping = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line">eating = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">working = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">playing = [<span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment"># 绘制堆叠折线图</span></span><br><span class="line">plt.stackplot(days, sleeping, eating, working, playing)</span><br><span class="line"><span class="comment"># 定制横轴刻度</span></span><br><span class="line">plt.xticks(days, labels=[<span class="string">f&#x27;星期<span class="subst">&#123;x&#125;</span>&#x27;</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;一二三四五六日&#x27;</span>])</span><br><span class="line"><span class="comment"># 定制图例</span></span><br><span class="line">plt.legend([<span class="string">&#x27;睡觉&#x27;</span>, <span class="string">&#x27;吃饭&#x27;</span>, <span class="string">&#x27;工作&#x27;</span>, <span class="string">&#x27;玩耍&#x27;</span>], fontsize=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 显示图表</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/stacked_line_chart.png" style="zoom:50%;"></p>
<h3 id="雷达图"><a href="#雷达图" class="headerlink" title="雷达图"></a>雷达图</h3><p>雷达图通常用来比较多个定量数据，用于查看哪些变量具有相似的值。 雷达图也可用于查看数据集中哪些变量的值比较低，哪些变量的值比较高，是显示性能或表现的理想选择。经常观看篮球、足球比赛的读者应该对雷达图非常熟悉，例如在 NBA 的转播中就经常使用雷达图来展示球员的各项数据。雷达图的本质折线图，只不过将折线图映射到了极坐标系。在绘制雷达图时，需要让折线闭合，简单的说就是首尾相连，下面是绘制雷达图的代码。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">labels = np.array([<span class="string">&#x27;速度&#x27;</span>, <span class="string">&#x27;力量&#x27;</span>, <span class="string">&#x27;经验&#x27;</span>, <span class="string">&#x27;防守&#x27;</span>, <span class="string">&#x27;发球&#x27;</span>, <span class="string">&#x27;技术&#x27;</span>])</span><br><span class="line"><span class="comment"># 马龙和水谷隼的数据</span></span><br><span class="line">malong_values = np.array([<span class="number">93</span>, <span class="number">95</span>, <span class="number">98</span>, <span class="number">92</span>, <span class="number">96</span>, <span class="number">97</span>])</span><br><span class="line">shuigu_values = np.array([<span class="number">30</span>, <span class="number">40</span>, <span class="number">65</span>, <span class="number">80</span>, <span class="number">45</span>, <span class="number">60</span>])</span><br><span class="line">angles = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, labels.size, endpoint=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 多加一条数据让图形闭合</span></span><br><span class="line">malong_values = np.append(malong_values, malong_values[<span class="number">0</span>])</span><br><span class="line">shuigu_values = np.append(shuigu_values, shuigu_values[<span class="number">0</span>])</span><br><span class="line">angles = np.append(angles, angles[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 创建画布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">4</span>, <span class="number">4</span>), dpi=<span class="number">120</span>)</span><br><span class="line"><span class="comment"># 创建坐标系</span></span><br><span class="line">ax = plt.subplot(projection=<span class="string">&#x27;polar&#x27;</span>)</span><br><span class="line"><span class="comment"># 绘图和填充</span></span><br><span class="line">plt.plot(angles, malong_values, color=<span class="string">&#x27;r&#x27;</span>, linewidth=<span class="number">2</span>, label=<span class="string">&#x27;马龙&#x27;</span>)</span><br><span class="line">plt.fill(angles, malong_values, color=<span class="string">&#x27;r&#x27;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">plt.plot(angles, shuigu_values, color=<span class="string">&#x27;g&#x27;</span>, linewidth=<span class="number">2</span>, label=<span class="string">&#x27;水谷隼&#x27;</span>)</span><br><span class="line">plt.fill(angles, shuigu_values, color=<span class="string">&#x27;g&#x27;</span>, alpha=<span class="number">0.2</span>)</span><br><span class="line"><span class="comment"># 显示图例</span></span><br><span class="line">ax.legend()</span><br><span class="line"><span class="comment"># 显示图表</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/radar_chart.png" style="zoom:50%;"></p>
<h3 id="玫瑰图"><a href="#玫瑰图" class="headerlink" title="玫瑰图"></a>玫瑰图</h3><p>玫瑰图是映射在极坐标下的柱状图，由弗罗伦斯·南丁格尔（Florence Nightingale）所发明，当年是南丁格尔用来呈现战地医院季节性死亡率的一种图表。由于半径和面积的关系是平方的关系，南丁格尔玫瑰图会将数据的比例大小夸大，尤其适合对比大小相近的数值，同时由于圆形有周期的特性，所以南丁格尔玫瑰图也适用于表示一个周期内的时间概念，比如星期、月份。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">group1 = np.random.randint(<span class="number">20</span>, <span class="number">50</span>, <span class="number">4</span>)</span><br><span class="line">group2 = np.random.randint(<span class="number">10</span>, <span class="number">60</span>, <span class="number">4</span>)</span><br><span class="line">x = np.array([<span class="string">f&#x27;A组-Q<span class="subst">&#123;i&#125;</span>&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)] + [<span class="string">f&#x27;B组-Q<span class="subst">&#123;i&#125;</span>&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)])</span><br><span class="line">y = np.array(group1.tolist() + group2.tolist())</span><br><span class="line"><span class="comment"># 玫瑰花瓣的角度和宽度</span></span><br><span class="line">theta = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, x.size, endpoint=<span class="literal">False</span>)</span><br><span class="line">width = <span class="number">2</span> * np.pi / x.size</span><br><span class="line"><span class="comment"># 生成8种随机颜色</span></span><br><span class="line">colors = np.random.rand(<span class="number">8</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 将柱状图投影到极坐标</span></span><br><span class="line">ax = plt.subplot(projection=<span class="string">&#x27;polar&#x27;</span>)</span><br><span class="line"><span class="comment"># 绘制柱状图</span></span><br><span class="line">plt.bar(theta, y, width=width, color=colors, bottom=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 设置网格</span></span><br><span class="line">ax.set_thetagrids(theta * <span class="number">180</span> / np.pi, x, fontsize=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 显示图表</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/rose_chart.png" style="zoom:50%;"></p>
<h3 id="3D图"><a href="#3D图" class="headerlink" title="3D图"></a>3D图</h3><p>matplotlib 还可以用于绘制3D图，具体的内容大家可以参考官方文档，下面我们用一段简单的代码为大家展示如何绘制3D图表。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">8</span>, <span class="number">4</span>), dpi=<span class="number">120</span>)</span><br><span class="line"><span class="comment"># 创建3D坐标系并添加到画布上</span></span><br><span class="line">ax = Axes3D(fig, auto_add_to_figure=<span class="literal">False</span>)</span><br><span class="line">fig.add_axes(ax)</span><br><span class="line">x = np.arange(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">0.1</span>)</span><br><span class="line">y = np.arange(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">0.1</span>)</span><br><span class="line">x, y = np.meshgrid(x, y)</span><br><span class="line">z = (<span class="number">1</span> - y ** <span class="number">5</span> + x ** <span class="number">5</span>) * np.exp(-x ** <span class="number">2</span> - y ** <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 绘制3D曲面</span></span><br><span class="line">ax.plot_surface(x, y, z)</span><br><span class="line"><span class="comment"># 显示图表</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/3d_surface_chart.png" style="zoom:60%;"></p>
<p>需要指出的是， JupyterLab 中渲染的3D图并不是真正的3D图，因为你没有办法调整观察者的视角，也没有办法旋转或者缩放。如果想要看到真正的3D效果，需要在将图表渲染到 Qt 窗口中，为此我们可以先安装名为 PyQt6 的三方库，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%pip install PyQt6</span><br></pre></td></tr></table></figure>
<p>然后，我们使用魔法指令让 JupyterLab 将图表渲染到 Qt 窗口中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib qt</span><br></pre></td></tr></table></figure>
<p>在完成上面的操作后，我们可以重新运行刚才绘制3D图的代码，看到如下所示的窗口。在这个窗口中，我们可以通过鼠标对3D进行旋转、缩放，我们有可以选中图表的一部分数据进行观测，是不是非常的酷。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/3d_surface_chart_qt.png" style="zoom:50%;"></p>
<h2 id="数据可视化-3"><a href="#数据可视化-3" class="headerlink" title="数据可视化-3"></a>数据可视化-3</h2><p>通过前面的学习，我们已经对数据可视化工具 matplotlib 有一个初步的认知。大家可能也会发现了，matplotlib 提供的函数虽然强大，但是参数太多，要想对图表进行深度的定制就需要修改一系列的参数，这一点对新手并不友好。另一方面，使用 matplotlib 定制的统计图是静态图表，可能在某些需要交互效果的场景下并不合适。为了解决这两个问题，我们为大家介绍两个新的可视化工具，一个是 seaborn，一个是 pyecharts。</p>
<h3 id="Seaborn"><a href="#Seaborn" class="headerlink" title="Seaborn"></a>Seaborn</h3><p>Seaborn 是建立在 matplotlib 之上的数据可视化工具，它相当于是对 matplotlib 进行了更高级的封装，而且 seaborn 也能跟 pandas 无缝整合，让我们可以用更少的代码构建出更好的统计图表，帮助我们探索和理解数据。Seaborn 包含但不局限于以下描述的功能：</p>
<ol>
<li>面向数据集的 API，可用于检查多个变量之间的关系。</li>
<li>支持使用分类变量来显示观察结果或汇总统计数据。</li>
<li>能够可视化单变量或双变量分布以及在数据子集之间进行比较的选项</li>
<li>各类因变量线性回归模型的自动估计与作图。</li>
<li>集成调色板和主题，轻松定制统计图表的视觉效果。</li>
</ol>
<p>可以使用 Python 的包管理工具 pip 来安装 seaborn。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install seaborn</span><br></pre></td></tr></table></figure>
<p>在 Jupyter 中，可以直接使用魔法指令进行安装，如下所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%pip install seaborn</span><br></pre></td></tr></table></figure>
<p>下面，我们用 seaborn 自带的数据集为例，为大家简单的展示 seaborn 的用法和强大之处，想要深入研究 seaborn 的读者可以自行阅读官方<a target="_blank" rel="noopener" href="https://seaborn.pydata.org/tutorial.html">文档</a>和并查看官方作品集中的<a target="_blank" rel="noopener" href="https://seaborn.pydata.org/examples/index.html">示例。</a>根据官方示例来编写自己的代码是一个不错的选择，简单的说就是保留官方代码，将数据换成自己的数据即可。下图展示了 seaborn 绘制图表的函数，可以看出，seaborn 的这些函数主要支持我们通过绘制图表来探索数据的关系、分布和分类。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/20220502115005.png" style="zoom:75%;"></p>
<p>使用 seaborn，首先需要导入该库并设置主题，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">sns.set_theme()</span><br></pre></td></tr></table></figure>
<p>如果需要在图表上显示中文，还需要用之前讲过的方法修改 matplotlib 的配置参数，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>].insert(<span class="number">0</span>, <span class="string">&#x27;SimHei&#x27;</span>)</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：上面的代码必须放在调用 set_theme 函数之后，否则调用 set_theme 函数时又会重新修改 matplotlib 配置参数中的字体设置。</p>
</blockquote>
<p>加载官方的 Tips 数据集（就餐小费数据）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tips_df = sns.load_dataset(<span class="string">&#x27;tips&#x27;</span>)</span><br><span class="line">tips_df.info()</span><br></pre></td></tr></table></figure>
<p>运行结果如下所示，其中 total_bill 表示账单总金额，tip 表示小费的金额，sex 是顾客的性别，smoker 表示顾客是否抽样，day 代表星期几，time 代表是午餐还是晚餐，size 是就餐人数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;</span><br><span class="line">RangeIndex: 244 entries, 0 to 243</span><br><span class="line">Data columns (total 7 columns):</span><br><span class="line"> #   Column      Non-Null Count  Dtype   </span><br><span class="line">---  ------      --------------  -----   </span><br><span class="line"> 0   total_bill  244 non-null    float64 </span><br><span class="line"> 1   tip         244 non-null    float64 </span><br><span class="line"> 2   sex         244 non-null    category</span><br><span class="line"> 3   smoker      244 non-null    category</span><br><span class="line"> 4   day         244 non-null    category</span><br><span class="line"> 5   time        244 non-null    category</span><br><span class="line"> 6   size        244 non-null    int64   </span><br><span class="line">dtypes: category(4), float64(2), int64(1)</span><br><span class="line">memory usage: 7.4 KB</span><br></pre></td></tr></table></figure>
<p>由于数据集是联网加载的，上述代码可能因为 SSL 的原因无法获取到数据，可以尝试先运行下面的代码，然后再加载数据集。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"></span><br><span class="line">ssl._create_default_https_context = ssl._create_unverified_context</span><br></pre></td></tr></table></figure>
<p>如果我们希望了解账单金额的分布，可以使用下面的代码来绘制分布图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.histplot(data=tips_df, x=<span class="string">&#x27;total_bill&#x27;</span>, kde=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/20220502115531.png" style="zoom:50%;"></p>
<p>如果想了解变量之间的两两关系，我们可以绘制点对图，代码和效果如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.pairplot(data=tips_df, hue=<span class="string">&#x27;sex&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/20220502120236.png" style="zoom:42%;"></p>
<p>如果对上面图表的颜色不满意，还可以通过 palette 参数选择 seaborn 自带的“调色板”来修改颜色，这种方式相比于自行指定颜色或使用随机颜色方便和靠谱了很多，下图为大家展示了部分 seaborn 自带的“调色板”。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://localhost//mypic/20220502120749.png" style="zoom:45%;"></p>
<p>我们可以将上面的代码稍作修改，看看运行结果有什么差别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.pairplot(data=tips_df, hue=<span class="string">&#x27;sex&#x27;</span>, palette=<span class="string">&#x27;Dark2&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>接下来，我们为 total_bill 和 tip 两组数据绘制联合分布图，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.jointplot(data=tips_df, x=<span class="string">&#x27;total_bill&#x27;</span>, y=<span class="string">&#x27;tip&#x27;</span>, hue=<span class="string">&#x27;sex&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/20220502121226.png" style="zoom:50%;"></p>
<p>上面清晰的展示了，total_bill 和 tip 之间存在正相关关系，这一点我们也可以通过 DataFrame 对象的 corr 方法进行验证。接下来，我们可以建立回归模型来拟合这些数据点，而 seaborn 的线性回归模型图已经帮我们实现了这项功能，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.lmplot(data=tips_df, x=<span class="string">&#x27;total_bill&#x27;</span>, y=<span class="string">&#x27;tip&#x27;</span>, hue=<span class="string">&#x27;sex&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/20220502121656.png" style="zoom:50%;"></p>
<p>如果我们希望了解账单金额的集中和离散趋势，可以绘制箱线图或小提琴图，代码如下所示，我们将数据按星期四、星期五、星期六和星期天分别进行展示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.boxplot(data=tips_df, x=<span class="string">&#x27;day&#x27;</span>, y=<span class="string">&#x27;total_bill&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/20220502122106.png" style="zoom:50%;"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.violinplot(data=tips_df, x=<span class="string">&#x27;day&#x27;</span>, y=<span class="string">&#x27;total_bill&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/20220502122144.png" style="zoom:50%;"></p>
<blockquote>
<p><strong>说明</strong>：相较于箱线图，小提琴图没有标注异常点而是显示了数据的整个范围，另一方面，小提琴图很好的展示了数据的分布（密度轨迹）。</p>
</blockquote>
<h3 id="Pyecharts"><a href="#Pyecharts" class="headerlink" title="Pyecharts"></a>Pyecharts</h3><p>Echarts 原来是百度开发的一个前端图表库，2018年1月16日，ECharts 进入 Apache Incubator 进行孵化，目前已经是 Apache 软件基金会的顶级项目。凭借着良好的交互性和精巧的图表设计，ECharts 得到了众多开发者的认可，而 pyecharts 就是基于 Python 语言对 ECharts 进行了包装，让 Python 开发者也可以使用 ECharts 绘制外观精美且交互性强的统计图表。</p>
<p>可以使用 Python 的包管理工具 pip 来安装 pyecharts。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyecharts</span><br></pre></td></tr></table></figure>
<p>在 JupyterLab 中，可以直接使用魔法指令进行安装，如下所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%pip install pyecharts</span><br></pre></td></tr></table></figure>
<p>如果想在 JupyterLab 中使用 pyecharts 绘图，我们还需要做一些准备工作，主要是修改 pyecharts 的配置，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.<span class="built_in">globals</span> <span class="keyword">import</span> CurrentConfig, NotebookType</span><br><span class="line"></span><br><span class="line">CurrentConfig.NOTEBOOK_TYPE = NotebookType.JUPYTER_LAB</span><br></pre></td></tr></table></figure>
<p>接下来，我们通过来自于 pyecharts 官方网站新手教程中的一个例子，来认识 pyecharts。当然，我们对官网的例子进行一些调整，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Bar</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建柱状图对象并设置初始参数（宽度、高度）</span></span><br><span class="line">bar_chart = Bar(init_opts=opts.InitOpts(width=<span class="string">&#x27;600px&#x27;</span>, height=<span class="string">&#x27;450px&#x27;</span>))</span><br><span class="line"><span class="comment"># 设置横轴数据</span></span><br><span class="line">bar_chart.add_xaxis([<span class="string">&quot;衬衫&quot;</span>, <span class="string">&quot;羊毛衫&quot;</span>, <span class="string">&quot;雪纺衫&quot;</span>, <span class="string">&quot;裤子&quot;</span>, <span class="string">&quot;高跟鞋&quot;</span>, <span class="string">&quot;袜子&quot;</span>])</span><br><span class="line"><span class="comment"># 设置纵轴数据（第一组）</span></span><br><span class="line">bar_chart.add_yaxis(<span class="string">&quot;商家A&quot;</span>, [<span class="number">25</span>, <span class="number">20</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">75</span>, <span class="number">90</span>])</span><br><span class="line"><span class="comment"># 设置纵轴数据（第二组）</span></span><br><span class="line">bar_chart.add_yaxis(<span class="string">&quot;商家B&quot;</span>, [<span class="number">15</span>, <span class="number">12</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">45</span>, <span class="number">60</span>])</span><br><span class="line"><span class="comment"># 设置纵轴数据（第三组）</span></span><br><span class="line">bar_chart.add_yaxis(<span class="string">&quot;商家C&quot;</span>, [<span class="number">12</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">52</span>, <span class="number">35</span>, <span class="number">26</span>])</span><br><span class="line"><span class="comment"># 添加全局配置参数</span></span><br><span class="line">bar_chart.set_global_opts(</span><br><span class="line">    <span class="comment"># 横轴相关的参数</span></span><br><span class="line">    xaxis_opts=opts.AxisOpts(</span><br><span class="line">        axislabel_opts=opts.LabelOpts(color=<span class="string">&#x27;navy&#x27;</span>)</span><br><span class="line">    ),</span><br><span class="line">    <span class="comment"># 纵轴相关的参数（标签、最小值、最大值、间隔）</span></span><br><span class="line">    yaxis_opts=opts.AxisOpts(</span><br><span class="line">        axislabel_opts=opts.LabelOpts(color=<span class="string">&#x27;navy&#x27;</span>),</span><br><span class="line">        min_=<span class="number">0</span>,</span><br><span class="line">        max_=<span class="number">100</span>,</span><br><span class="line">        interval=<span class="number">10</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="comment"># 标题相关的参数（内容、链接、位置、文本样式）</span></span><br><span class="line">    title_opts=opts.TitleOpts(</span><br><span class="line">        title=<span class="string">&#x27;2022年销售数据展示&#x27;</span>,</span><br><span class="line">        pos_left=<span class="string">&#x27;2%&#x27;</span>,</span><br><span class="line">        title_textstyle_opts=opts.TextStyleOpts(</span><br><span class="line">            color=<span class="string">&#x27;navy&#x27;</span>,</span><br><span class="line">            font_size=<span class="number">16</span>,</span><br><span class="line">            font_family=<span class="string">&#x27;苹方-简&#x27;</span>,</span><br><span class="line">            font_weight=<span class="string">&#x27;bold&#x27;</span></span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    <span class="comment"># 工具箱相关的参数</span></span><br><span class="line">    toolbox_opts=opts.ToolboxOpts(</span><br><span class="line">        orient=<span class="string">&#x27;vertical&#x27;</span>,</span><br><span class="line">        pos_left=<span class="string">&#x27;right&#x27;</span></span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 加载绘图需要的JavaScript文件</span></span><br><span class="line">bar_chart.load_javascript()</span><br></pre></td></tr></table></figure>
<p>在执行完上面的代码后，我们就可以通过调用<code>bar</code>对象的方法来完成对图表的渲染。如果直接使用<code>render</code>方法，那么绘制好的统计图表将保存到一个 HTML 文件中，打开该文件也能够看到绘制好的统计图表，而<code>render_notebook</code>方法则是将图表渲染到浏览器窗口中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar_chart.render_notebook()</span><br></pre></td></tr></table></figure>
<p>上面代码的运行效果如下图所示。值得一提的是，下图中的标题、图例、右侧的工具箱都是可以点击的，大家可以点击它们看看会有什么样的效果，ECharts 的魅力就在于它的交互效果，大家一定要试一试。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/pyecharts_bar_chart.png" style="zoom:55%;"></p>
<p>接下来，我们也是通过一个官方示例，看看如何绘制饼图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyecharts.options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Pie</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备饼图需要的数据</span></span><br><span class="line">x_data = [<span class="string">&quot;直接访问&quot;</span>, <span class="string">&quot;邮件营销&quot;</span>, <span class="string">&quot;联盟广告&quot;</span>, <span class="string">&quot;视频广告&quot;</span>, <span class="string">&quot;搜索引擎&quot;</span>]</span><br><span class="line">y_data = [<span class="number">335</span>, <span class="number">310</span>, <span class="number">234</span>, <span class="number">135</span>, <span class="number">1548</span>]</span><br><span class="line">data = [(x, y) <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(x_data, y_data)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建饼图对象并设置初始化参数</span></span><br><span class="line">pie_chart = Pie(init_opts=opts.InitOpts(width=<span class="string">&quot;800px&quot;</span>, height=<span class="string">&quot;400px&quot;</span>))</span><br><span class="line"><span class="comment"># 向饼图添加数据</span></span><br><span class="line">pie_chart.add(</span><br><span class="line">    <span class="string">&#x27;&#x27;</span>, </span><br><span class="line">    data_pair=data,</span><br><span class="line">    radius=[<span class="string">&quot;50%&quot;</span>, <span class="string">&quot;75%&quot;</span>],</span><br><span class="line">    label_opts=opts.LabelOpts(is_show=<span class="literal">False</span>),</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 设置全局配置项</span></span><br><span class="line">pie_chart.set_global_opts(</span><br><span class="line">    <span class="comment"># 配置图例相关的参数</span></span><br><span class="line">    legend_opts=opts.LegendOpts(</span><br><span class="line">        pos_left=<span class="string">&quot;legft&quot;</span>,</span><br><span class="line">        orient=<span class="string">&quot;vertical&quot;</span></span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 设置数据系列配置参数</span></span><br><span class="line">pie_chart.set_series_opts(</span><br><span class="line">    <span class="comment"># 设置不显示工具提示</span></span><br><span class="line">    tooltip_opts=opts.TooltipOpts(is_show=<span class="literal">False</span>),</span><br><span class="line">    <span class="comment"># 设置饼图标签的样式</span></span><br><span class="line">    label_opts=opts.LabelOpts(formatter=<span class="string">&quot;&#123;b&#125;(&#123;c&#125;): &#123;d&#125;%&quot;</span>)</span><br><span class="line">)</span><br><span class="line">pie_chart.load_javascript()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pie_chart.render_notebook()</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，效果如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/pyecharts_pie_chart.png" style="zoom:50%;"></p>
<p>需要提醒大家注意的是，pyecharts 并不能直接使用 NumPy 的 ndarray 和 Pandas 的 Series、DataFrame 为其提供数据，它需要的是 Python 原生的数据类型。可能大家也注意到了，上面的代码中，我们使用的都是列表、元组这样的数据类型。</p>
<p>最后，我们来看看如何绘制地图，绘制地图首先需要安装额外的依赖库来获取地图相关信息，命令如下所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install echarts-countries-pypkg echarts-china-provinces-pypkg echarts-china-cities-pypkg echarts-china-counties-pypkg</span><br></pre></td></tr></table></figure>
<p>在 Jupyter 中，可以直接使用魔法指令进行安装，如下所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%pip install echarts-countries-pypkg</span><br><span class="line">%pip install echarts-china-provinces-pypkg</span><br><span class="line">%pip install echarts-china-cities-pypkg</span><br><span class="line">%pip install echarts-china-counties-pypkg</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明</strong>：上面的四个库分别包含了世界各国、中国省级行政区域、中国市级行政区域、中国区/县级行政区域的数据。</p>
</blockquote>
<p>然后，我们将全国各省的数据放在一个列表中，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data = [</span><br><span class="line">    (<span class="string">&#x27;广东&#x27;</span>, <span class="number">594</span>), (<span class="string">&#x27;浙江&#x27;</span>, <span class="number">438</span>), (<span class="string">&#x27;四川&#x27;</span>, <span class="number">316</span>), (<span class="string">&#x27;北京&#x27;</span>, <span class="number">269</span>), (<span class="string">&#x27;山东&#x27;</span>, <span class="number">248</span>),</span><br><span class="line">    (<span class="string">&#x27;江苏&#x27;</span>, <span class="number">234</span>), (<span class="string">&#x27;湖南&#x27;</span>, <span class="number">196</span>), (<span class="string">&#x27;福建&#x27;</span>, <span class="number">166</span>), (<span class="string">&#x27;河南&#x27;</span>, <span class="number">153</span>), (<span class="string">&#x27;辽宁&#x27;</span>, <span class="number">152</span>),</span><br><span class="line">    (<span class="string">&#x27;上海&#x27;</span>, <span class="number">138</span>), (<span class="string">&#x27;河北&#x27;</span>, <span class="number">86</span>), (<span class="string">&#x27;安徽&#x27;</span>, <span class="number">79</span>), (<span class="string">&#x27;湖北&#x27;</span>, <span class="number">75</span>), (<span class="string">&#x27;黑龙江&#x27;</span>, <span class="number">70</span>), </span><br><span class="line">    (<span class="string">&#x27;陕西&#x27;</span>, <span class="number">63</span>), (<span class="string">&#x27;吉林&#x27;</span>, <span class="number">59</span>), (<span class="string">&#x27;江西&#x27;</span>, <span class="number">56</span>), (<span class="string">&#x27;重庆&#x27;</span>, <span class="number">46</span>), (<span class="string">&#x27;贵州&#x27;</span>, <span class="number">39</span>),</span><br><span class="line">    (<span class="string">&#x27;山西&#x27;</span>, <span class="number">37</span>), (<span class="string">&#x27;云南&#x27;</span>, <span class="number">33</span>), (<span class="string">&#x27;广西&#x27;</span>, <span class="number">24</span>), (<span class="string">&#x27;天津&#x27;</span>, <span class="number">22</span>), (<span class="string">&#x27;新疆&#x27;</span>, <span class="number">21</span>),</span><br><span class="line">    (<span class="string">&#x27;海南&#x27;</span>, <span class="number">18</span>), (<span class="string">&#x27;内蒙古&#x27;</span>, <span class="number">14</span>), (<span class="string">&#x27;台湾&#x27;</span>, <span class="number">11</span>), (<span class="string">&#x27;甘肃&#x27;</span>, <span class="number">7</span>), (<span class="string">&#x27;广西壮族自治区&#x27;</span>, <span class="number">4</span>),</span><br><span class="line">    (<span class="string">&#x27;香港&#x27;</span>, <span class="number">4</span>), (<span class="string">&#x27;青海&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;新疆维吾尔自治区&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;内蒙古自治区&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;宁夏&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>接下来，我们使用 pyecharts 在地图上标记各省抖音大V人数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyecharts.options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Map</span><br><span class="line"></span><br><span class="line">map_chart = Map(init_opts=opts.InitOpts(width=<span class="string">&#x27;1000px&#x27;</span>, height=<span class="string">&#x27;1000px&#x27;</span>))</span><br><span class="line">map_chart.add(<span class="string">&#x27;&#x27;</span>, data, <span class="string">&#x27;china&#x27;</span>, is_roam=<span class="literal">False</span>)</span><br><span class="line">map_chart.load_javascript()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map_chart.render_notebook()</span><br></pre></td></tr></table></figure>
<p>代码的运行效果如下图所示，将鼠标置于地图上时，会高亮对应的省并看到相关的信息。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="res/pyecharts_map_chart.png" style="zoom:55%;"></p>
<p>和 seaborn 一样，我们建议大家参考官方提供的示例来使用 pyecharts，我们可以在 pyecharts <a target="_blank" rel="noopener" href="https://pyecharts.org/#/zh-cn/">官方网站</a>的左侧导航栏中找到“图表类型”选项，下面每种类型的图表都有对应的官方示例，很多代码是可以直接使用的，我们需要做的就是将数据换成自己的数据。</p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>Python基础(day66-80)</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://jiaming-blog.top/post/4462ea98.html">https://jiaming-blog.top/post/4462ea98.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>马嘉明</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-01-23</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-01-23</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="https://picture.jiaming-blog.top/wallpaper/103.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">赞助</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/12/22/_20231222225705.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/12/22/_20231222225705.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/12/22/_20231222225713.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/12/22/_20231222225713.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/cd8a3dcf.html" title="Python基础(day81-90)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picture.jiaming-blog.top/wallpaper/97.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python基础(day81-90)</div></div></a></div><div class="next-post pull-right"><a href="/post/81abefc7.html" title="Python基础(day61-65)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picture.jiaming-blog.top/wallpaper/40.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Python基础(day61-65)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/54f05ff6.html" title="Python基础(day16-20)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picture.jiaming-blog.top/wallpaper/73.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-23</div><div class="title">Python基础(day16-20)</div></div></a></div><div><a href="/post/61869b7f.html" title="Python基础(day21-30)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picture.jiaming-blog.top/wallpaper/40.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-23</div><div class="title">Python基础(day21-30)</div></div></a></div><div><a href="/post/d7adbc9f.html" title="Python基础(day31-35)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picture.jiaming-blog.top/wallpaper/36.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-23</div><div class="title">Python基础(day31-35)</div></div></a></div><div><a href="/post/1db5824f.html" title="Python基础(day36-40)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picture.jiaming-blog.top/wallpaper/47.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-23</div><div class="title">Python基础(day36-40)</div></div></a></div><div><a href="/post/c868b53c.html" title="Python基础(day56-60)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picture.jiaming-blog.top/wallpaper/18.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-23</div><div class="title">Python基础(day56-60)</div></div></a></div><div><a href="/post/ce25f095.html" title="Python基础(day41-55)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picture.jiaming-blog.top/wallpaper/72.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-23</div><div class="title">Python基础(day41-55)</div></div></a></div><div><a href="/post/986c1b74.html" title="Python基础(day1-15)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picture.jiaming-blog.top/wallpaper/38.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-23</div><div class="title">Python基础(day1-15)</div></div></a></div><div><a href="/post/81abefc7.html" title="Python基础(day61-65)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picture.jiaming-blog.top/wallpaper/40.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-23</div><div class="title">Python基础(day61-65)</div></div></a></div><div><a href="/post/cd8a3dcf.html" title="Python基础(day81-90)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picture.jiaming-blog.top/wallpaper/97.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-23</div><div class="title">Python基础(day81-90)</div></div></a></div><div><a href="/post/6365a8be.html" title="Python基础(day91-100)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picture.jiaming-blog.top/wallpaper/62.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-23</div><div class="title">Python基础(day91-100)</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">数据分析概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%88%E7%9A%84%E8%81%8C%E8%B4%A3%E5%92%8C%E6%8A%80%E8%83%BD%E6%A0%88"><span class="toc-number">1.1.</span> <span class="toc-text">数据分析师的职责和技能栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">数据分析的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9B%B8%E5%85%B3%E5%BA%93"><span class="toc-number">1.3.</span> <span class="toc-text">数据分析相关库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%A5%9E%E5%99%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">三大神器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E5%BA%93"><span class="toc-number">1.3.2.</span> <span class="toc-text">其他相关库</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">2.</span> <span class="toc-text">环境准备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8-Anaconda"><span class="toc-number">2.1.</span> <span class="toc-text">安装和使用 Anaconda</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#conda%E5%91%BD%E4%BB%A4"><span class="toc-number">2.1.1.</span> <span class="toc-text">conda命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8JupyterLab"><span class="toc-number">2.2.</span> <span class="toc-text">安装和使用JupyterLab</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E5%8A%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">安装和启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="toc-number">2.2.2.</span> <span class="toc-text">使用技巧</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NumPy%E7%9A%84%E5%BA%94%E7%94%A8-1"><span class="toc-number">3.</span> <span class="toc-text">NumPy的应用-1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">3.1.</span> <span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.2.</span> <span class="toc-text">创建数组对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">3.3.</span> <span class="toc-text">数组对象的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%B4%A2%E5%BC%95%E8%BF%90%E7%AE%97"><span class="toc-number">3.4.</span> <span class="toc-text">数组的索引运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">3.4.1.</span> <span class="toc-text">普通索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%B4%A2%E5%BC%95"><span class="toc-number">3.4.2.</span> <span class="toc-text">切片索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%B1%E5%BC%8F%E7%B4%A2%E5%BC%95"><span class="toc-number">3.4.3.</span> <span class="toc-text">花式索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%B4%A2%E5%BC%95"><span class="toc-number">3.4.4.</span> <span class="toc-text">布尔索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87%E5%A4%84%E7%90%86%E5%9B%BE%E5%83%8F"><span class="toc-number">3.5.</span> <span class="toc-text">案例：通过数组切片处理图像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NumPy%E7%9A%84%E5%BA%94%E7%94%A8-2"><span class="toc-number">4.</span> <span class="toc-text">NumPy的应用-2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">数组对象的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%8F%8F%E8%BF%B0%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="toc-number">4.1.1.</span> <span class="toc-text">获取描述统计信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.2.</span> <span class="toc-text">其他相关方法概述</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NumPy%E7%9A%84%E5%BA%94%E7%94%A8-3"><span class="toc-number">5.</span> <span class="toc-text">NumPy的应用-3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">5.1.</span> <span class="toc-text">数组的运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%B7%9F%E6%A0%87%E9%87%8F%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">5.1.1.</span> <span class="toc-text">数组跟标量的运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%B7%9F%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">5.1.2.</span> <span class="toc-text">数组跟数组的运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.3.</span> <span class="toc-text">通用一元函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E4%BA%8C%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.4.</span> <span class="toc-text">通用二元函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">5.1.5.</span> <span class="toc-text">广播机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">其他常用函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NumPy%E7%9A%84%E5%BA%94%E7%94%A8-4"><span class="toc-number">6.</span> <span class="toc-text">NumPy的应用-4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F"><span class="toc-number">6.1.</span> <span class="toc-text">向量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E7%9A%84%E5%8A%A0%E6%B3%95"><span class="toc-number">6.1.1.</span> <span class="toc-text">向量的加法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E7%9A%84%E6%95%B0%E4%B9%98"><span class="toc-number">6.1.2.</span> <span class="toc-text">向量的数乘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E7%9A%84%E7%82%B9%E7%A7%AF"><span class="toc-number">6.1.3.</span> <span class="toc-text">向量的点积</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E7%9A%84%E5%8F%89%E7%A7%AF"><span class="toc-number">6.1.4.</span> <span class="toc-text">向量的叉积</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E5%88%97%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">行列式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">6.2.1.</span> <span class="toc-text">行列式的性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E5%88%97%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">6.2.2.</span> <span class="toc-text">行列式的计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5"><span class="toc-number">6.3.</span> <span class="toc-text">矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.3.1.</span> <span class="toc-text">矩阵对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%A8%A1%E5%9D%97"><span class="toc-number">6.3.2.</span> <span class="toc-text">线性代数模块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="toc-number">6.4.</span> <span class="toc-text">多项式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.4.1.</span> <span class="toc-text">创建多项式对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">6.4.2.</span> <span class="toc-text">多项式的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E8%A7%A3"><span class="toc-number">6.4.3.</span> <span class="toc-text">最小二乘解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BApandas-1"><span class="toc-number">7.</span> <span class="toc-text">深入浅出pandas-1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BASeries%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.1.</span> <span class="toc-text">创建Series对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Series%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">7.2.</span> <span class="toc-text">Series对象的运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E8%BF%90%E7%AE%97"><span class="toc-number">7.2.1.</span> <span class="toc-text">标量运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A2%E9%87%8F%E8%BF%90%E7%AE%97"><span class="toc-number">7.2.2.</span> <span class="toc-text">矢量运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%BF%90%E7%AE%97"><span class="toc-number">7.2.3.</span> <span class="toc-text">索引运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95-1"><span class="toc-number">7.2.3.1.</span> <span class="toc-text">普通索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%B4%A2%E5%BC%95-1"><span class="toc-number">7.2.3.2.</span> <span class="toc-text">切片索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8A%B1%E5%BC%8F%E7%B4%A2%E5%BC%95-1"><span class="toc-number">7.2.3.3.</span> <span class="toc-text">花式索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%B4%A2%E5%BC%95-1"><span class="toc-number">7.2.3.4.</span> <span class="toc-text">布尔索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Series%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.</span> <span class="toc-text">Series对象的属性和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E7%9B%B8%E5%85%B3"><span class="toc-number">7.3.1.</span> <span class="toc-text">统计相关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE"><span class="toc-number">7.3.2.</span> <span class="toc-text">处理数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E5%A4%B4%E9%83%A8%E5%80%BC%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="toc-number">7.3.3.</span> <span class="toc-text">取头部值和排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8"><span class="toc-number">7.3.4.</span> <span class="toc-text">绘制图表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BApandas-2"><span class="toc-number">8.</span> <span class="toc-text">深入浅出pandas-2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BADataFrame%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.1.</span> <span class="toc-text">创建DataFrame对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BADataFrame%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.1.1.</span> <span class="toc-text">通过二维数组创建DataFrame对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%AD%97%E5%85%B8%E5%88%9B%E5%BB%BADataFrame%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.1.2.</span> <span class="toc-text">通过字典创建DataFrame对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96CSV%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BADataFrame%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.1.3.</span> <span class="toc-text">读取CSV文件创建DataFrame对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96Excel%E5%B7%A5%E4%BD%9C%E8%A1%A8%E5%88%9B%E5%BB%BADataFrame%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.1.4.</span> <span class="toc-text">读取Excel工作表创建DataFrame对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8C%E7%BB%B4%E8%A1%A8%E5%88%9B%E5%BB%BADataFrame%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.1.5.</span> <span class="toc-text">读取关系数据库二维表创建DataFrame对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">基本属性和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE"><span class="toc-number">8.3.</span> <span class="toc-text">操作数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%92%8C%E5%88%87%E7%89%87"><span class="toc-number">8.3.1.</span> <span class="toc-text">索引和切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%AD%9B%E9%80%89"><span class="toc-number">8.3.2.</span> <span class="toc-text">数据筛选</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BApandas-3"><span class="toc-number">9.</span> <span class="toc-text">深入浅出pandas-3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A1%91"><span class="toc-number">9.1.</span> <span class="toc-text">数据重塑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97"><span class="toc-number">9.2.</span> <span class="toc-text">数据清洗</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E5%A4%B1%E5%80%BC"><span class="toc-number">9.2.1.</span> <span class="toc-text">缺失值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E5%80%BC"><span class="toc-number">9.2.2.</span> <span class="toc-text">重复值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%80%BC"><span class="toc-number">9.2.3.</span> <span class="toc-text">异常值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">9.2.4.</span> <span class="toc-text">预处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BApandas-4"><span class="toc-number">10.</span> <span class="toc-text">深入浅出pandas-4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%8F%E8%A7%86"><span class="toc-number">10.1.</span> <span class="toc-text">数据透视</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%8F%8F%E8%BF%B0%E6%80%A7%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="toc-number">10.1.1.</span> <span class="toc-text">获取描述性统计信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%92%8C%E5%8F%96%E5%A4%B4%E9%83%A8%E5%80%BC"><span class="toc-number">10.1.2.</span> <span class="toc-text">排序和取头部值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E8%81%9A%E5%90%88"><span class="toc-number">10.1.3.</span> <span class="toc-text">分组聚合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%8F%E8%A7%86%E8%A1%A8%E5%92%8C%E4%BA%A4%E5%8F%89%E8%A1%A8"><span class="toc-number">10.1.4.</span> <span class="toc-text">透视表和交叉表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%91%88%E7%8E%B0"><span class="toc-number">10.2.</span> <span class="toc-text">数据呈现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BApandas-5"><span class="toc-number">11.</span> <span class="toc-text">深入浅出pandas-5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%90%8C%E6%AF%94%E7%8E%AF%E6%AF%94"><span class="toc-number">11.1.</span> <span class="toc-text">计算同比环比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E8%AE%A1%E7%AE%97"><span class="toc-number">11.2.</span> <span class="toc-text">窗口计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%80%A7%E5%88%A4%E5%AE%9A"><span class="toc-number">11.3.</span> <span class="toc-text">相关性判定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BApandas-6"><span class="toc-number">12.</span> <span class="toc-text">深入浅出pandas-6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E7%B4%A2%E5%BC%95"><span class="toc-number">12.1.</span> <span class="toc-text">范围索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E7%B4%A2%E5%BC%95"><span class="toc-number">12.2.</span> <span class="toc-text">分类索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">12.3.</span> <span class="toc-text">多级索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E9%9A%94%E7%B4%A2%E5%BC%95"><span class="toc-number">12.4.</span> <span class="toc-text">间隔索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B4%A2%E5%BC%95"><span class="toc-number">12.5.</span> <span class="toc-text">日期时间索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-1"><span class="toc-number">13.</span> <span class="toc-text">数据可视化-1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="toc-number">13.1.</span> <span class="toc-text">导入和配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%94%BB%E5%B8%83"><span class="toc-number">13.2.</span> <span class="toc-text">创建画布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-number">13.3.</span> <span class="toc-text">创建坐标系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F"><span class="toc-number">13.4.</span> <span class="toc-text">绘制图像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E7%BA%BF%E5%9B%BE"><span class="toc-number">13.4.1.</span> <span class="toc-text">折线图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E7%82%B9%E5%9B%BE"><span class="toc-number">13.4.2.</span> <span class="toc-text">散点图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%B1%E7%8A%B6%E5%9B%BE"><span class="toc-number">13.4.3.</span> <span class="toc-text">柱状图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%BC%E7%8A%B6%E5%9B%BE"><span class="toc-number">13.4.4.</span> <span class="toc-text">饼状图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%96%B9%E5%9B%BE"><span class="toc-number">13.4.5.</span> <span class="toc-text">直方图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%B1%E7%BA%BF%E5%9B%BE"><span class="toc-number">13.4.6.</span> <span class="toc-text">箱线图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%88%96%E4%BF%9D%E5%AD%98%E5%9B%BE%E5%83%8F"><span class="toc-number">13.5.</span> <span class="toc-text">显示或保存图像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%9B%BE%E8%A1%A8"><span class="toc-number">13.6.</span> <span class="toc-text">其他图表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-2"><span class="toc-number">14.</span> <span class="toc-text">数据可视化-2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%94%E6%B3%A1%E5%9B%BE"><span class="toc-number">14.1.</span> <span class="toc-text">气泡图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E7%A7%AF%E5%9B%BE"><span class="toc-number">14.2.</span> <span class="toc-text">面积图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B7%E8%BE%BE%E5%9B%BE"><span class="toc-number">14.3.</span> <span class="toc-text">雷达图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AB%E7%91%B0%E5%9B%BE"><span class="toc-number">14.4.</span> <span class="toc-text">玫瑰图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3D%E5%9B%BE"><span class="toc-number">14.5.</span> <span class="toc-text">3D图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-3"><span class="toc-number">15.</span> <span class="toc-text">数据可视化-3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Seaborn"><span class="toc-number">15.1.</span> <span class="toc-text">Seaborn</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pyecharts"><span class="toc-number">15.2.</span> <span class="toc-text">Pyecharts</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">感悟🧬</p><div class="bg-ad"><div>可能是我太封建了，认为谈恋爱就要结婚，谈恋爱不是儿戏，在这个快餐式爱情的时代下，我仍然抱着结婚的结果来谈恋爱，与这个时代格格不入，我只知道我仍会坚守着我的底线，我的家教和思想告诉我，如果你脱了一个女孩的衣服，就要为她穿上婚纱，即使这个时代变了，我也要一往无前，现在的社会一顿酒局，就可以带一个妹子回家，两个小时就可以到另外一个城市，三言两语就可以成为挚友，认识两三天就可以成为男女朋友，辛辛苦苦维持了几年的感情，可以因为一件小事而崩塌，我讨厌这样的社会，这是一个花钱就可以买到爱情的年代，领一张证就可以成为妻子，微信一删就是永别，晚风吹人醒，万事藏于心，我没说不公平，也没说苦，我说我知道了，生活在催我挣钱，年龄在催我成熟懂事，这些年生活把我熬成了清粥，没了味道，也没了样子，渐渐也没有勇气。</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/personal/about/web/">建设进程</a><a href="/personal/talk/">我的唠叨</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a href="https://jiaming-blog.top/" title="嘉明のBlog🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/12/22/-1.png" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2023 - 2024</b></span><span><b>&nbsp;&nbsp;By 马嘉明</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.bitiful.net/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn/#/Integrated/index" style="margin-inline:5px" title="本站已在湘进行备案"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/湘ICP备-2022004213号.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.20.0/algoliasearch-lite.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.60.0/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.jiaming-blog.top',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(init,0)
    else getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(init)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.jiaming-blog.top',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
      GLOBAL_CONFIG_SITE.isPost && getCount()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer data-pjax src="/js/emoji.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/cursor.js"></script><script async src="//at.alicdn.com/t/c/font_4385886_8vora7enkcx.js"></script><div class="aplayer no-destroy" data-id="9100062335" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="true" muted></div><script defer data-pjax src="/js/cat.js"></script><script src="/js/share.js"></script><script src="/js/f12.js"></script><script src="/js/card_weibo.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/lunar.js"></script><script defer src="/js/day.js"></script><script src="/js/sun_moon.js" async></script><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><script type="text/javascript" src="https://cdn1.tianli0.top/npm/jquery@latest/dist/jquery.min.js"></script><script type="text/javascript" src="/js/rightmenu.js"></script><script defer src="/js/runtime.js"></script><script async src="/js/console.js"></script><script async src="/js/fps.js"></script><canvas id="snow"></canvas><script async src="/js/snow.js"></script><script async src="/js/title.js"></script><script>let tianliGPT_postSelector = '\#post \#article-container';let tianliGPT_key = 'ed7f8e3599c55a0ea403';</script><script src="https://cdn1.tianli0.top/gh/zhheo/Post-Abstract-AI@0.14/tianli_gpt.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU,萱,我,喜欢,你" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.20.0/algoliasearch-lite.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instantsearch.js/4.60.0/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '8476721885524aaaa3cb09a8528ec253';
  var gaud_map_key = '84c29f2def64828ea55f3d9d50abd7da';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picture.jiaming-blog.top/wallpaper/62.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-12-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">Markdown语法与外挂标签写法汇总</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/166dd676.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picture.jiaming-blog.top/wallpaper/27.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-12-28</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/166dd676.html&quot;);" href="javascript:void(0);" alt="">Github图床上传</a><div class="blog-slider__text">图片管理</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/166dd676.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/8625e77e.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://newssrc.onlinedown.net/d/file/20160911/1473583278595.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-12-28</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/8625e77e.html&quot;);" href="javascript:void(0);" alt="">Font-matter的写法</a><div class="blog-slider__text">Font-matter的写法汇总</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/8625e77e.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/dab7fdc5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picture.jiaming-blog.top/wallpaper/102.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/dab7fdc5.html&quot;);" href="javascript:void(0);" alt="">爬虫闯关练习</a><div class="blog-slider__text">学习爬虫记录</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/dab7fdc5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/b169dca9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picture.jiaming-blog.top/wallpaper/107.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/b169dca9.html&quot;);" href="javascript:void(0);" alt="">爬虫实战案例</a><div class="blog-slider__text">爬虫实战</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/b169dca9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;post/adf0912f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picture.jiaming-blog.top/wallpaper/68.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-23</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;post/adf0912f.html&quot;);" href="javascript:void(0);" alt="">刷新博客搜索内容</a><div class="blog-slider__text">刷新博客搜索内容的</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;post/adf0912f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/personal/about/'|| '/personal/about/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://gitcalendar.jiaming-blog.top/api?MJM-13309559213",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'MJM-13309559213')
    }
  </script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>